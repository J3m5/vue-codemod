diff --git a/lib/def/type-annotations.js b/lib/def/type-annotations.js
index df87430199a0c31b2c1f39c9f2ec7adec45b110e..9d1a8395bc30070670daa0bf0b64dfe010a01004 100644
--- a/lib/def/type-annotations.js
+++ b/lib/def/type-annotations.js
@@ -1,42 +1,68 @@
-"use strict";
+'use strict'
 /**
  * Type annotation defs shared between Flow and TypeScript.
  * These defs could not be defined in ./flow.ts or ./typescript.ts directly
  * because they use the same name.
  */
-Object.defineProperty(exports, "__esModule", { value: true });
-var tslib_1 = require("tslib");
-var types_1 = tslib_1.__importDefault(require("../types"));
-var shared_1 = tslib_1.__importStar(require("../shared"));
+Object.defineProperty(exports, '__esModule', { value: true })
+var tslib_1 = require('tslib')
+var types_1 = tslib_1.__importDefault(require('../types'))
+var shared_1 = tslib_1.__importStar(require('../shared'))
 function default_1(fork) {
-    var types = fork.use(types_1.default);
-    var def = types.Type.def;
-    var or = types.Type.or;
-    var defaults = fork.use(shared_1.default).defaults;
-    var TypeAnnotation = or(def("TypeAnnotation"), def("TSTypeAnnotation"), null);
-    var TypeParamDecl = or(def("TypeParameterDeclaration"), def("TSTypeParameterDeclaration"), null);
-    def("Identifier")
-        .field("typeAnnotation", TypeAnnotation, defaults["null"]);
-    def("ObjectPattern")
-        .field("typeAnnotation", TypeAnnotation, defaults["null"]);
-    def("Function")
-        .field("returnType", TypeAnnotation, defaults["null"])
-        .field("typeParameters", TypeParamDecl, defaults["null"]);
-    def("ClassProperty")
-        .build("key", "value", "typeAnnotation", "static")
-        .field("value", or(def("Expression"), null))
-        .field("static", Boolean, defaults["false"])
-        .field("typeAnnotation", TypeAnnotation, defaults["null"]);
-    ["ClassDeclaration",
-        "ClassExpression",
-    ].forEach(function (typeName) {
-        def(typeName)
-            .field("typeParameters", TypeParamDecl, defaults["null"])
-            .field("superTypeParameters", or(def("TypeParameterInstantiation"), def("TSTypeParameterInstantiation"), null), defaults["null"])
-            .field("implements", or([def("ClassImplements")], [def("TSExpressionWithTypeArguments")]), defaults.emptyArray);
-    });
+  var types = fork.use(types_1.default)
+  var def = types.Type.def
+  var or = types.Type.or
+  var defaults = fork.use(shared_1.default).defaults
+  var TypeAnnotation = or(def('TypeAnnotation'), def('TSTypeAnnotation'), null)
+  var TypeParamDecl = or(
+    def('TypeParameterDeclaration'),
+    def('TSTypeParameterDeclaration'),
+    null,
+  )
+  def('Identifier').field('typeAnnotation', TypeAnnotation, defaults['null'])
+  def('ObjectPattern').field('typeAnnotation', TypeAnnotation, defaults['null'])
+  def('Function')
+    .field('returnType', TypeAnnotation, defaults['null'])
+    .field('typeParameters', TypeParamDecl, defaults['null'])
+  def('ClassProperty')
+    .build('key', 'value', 'typeAnnotation', 'static')
+    .field('value', or(def('Expression'), null))
+    .field('static', Boolean, defaults['false'])
+    .field('typeAnnotation', TypeAnnotation, defaults['null'])
+
+  def('CallExpression')
+    .bases('Expression')
+    .build('callee', 'arguments')
+    .field('callee', def('Expression'))
+    // See comment for NewExpression above.
+    .field('arguments', [def('Expression')])
+    .field(
+      'typeParameters',
+      or(null, def('TSTypeParameterInstantiation')),
+      defaults['null'],
+    )
+
+  ;['ClassDeclaration', 'ClassExpression'].forEach(function (typeName) {
+    def(typeName)
+      .field('typeParameters', TypeParamDecl, defaults['null'])
+      .field(
+        'superTypeParameters',
+        or(
+          def('TypeParameterInstantiation'),
+          def('TSTypeParameterInstantiation'),
+          null,
+        ),
+        defaults['null'],
+      )
+      .field(
+        'implements',
+        or([def('ClassImplements')], [def('TSExpressionWithTypeArguments')]),
+        defaults.emptyArray,
+      )
+  })
 }
-exports.default = default_1;
-;
-(0, shared_1.maybeSetModuleExports)(function () { return module; });
+exports.default = default_1
+;(0, shared_1.maybeSetModuleExports)(function () {
+  return module
+})
 //# sourceMappingURL=type-annotations.js.map
diff --git a/lib/gen/builders.d.ts b/lib/gen/builders.d.ts
index 1773656ab7fd5ec8d66b53ad995d1adb8a0ae99f..b39453d319d90b834fb71aef2dd7ee1edd65b74e 100644
--- a/lib/gen/builders.d.ts
+++ b/lib/gen/builders.d.ts
@@ -1,2850 +1,3707 @@
-import * as K from "./kinds";
-import { namedTypes } from "./namedTypes";
+import * as K from './kinds'
+import { namedTypes } from './namedTypes'
 export interface FileBuilder {
-    (program: K.ProgramKind, name?: string | null): namedTypes.File;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-        name?: string | null;
-        program: K.ProgramKind;
-    }): namedTypes.File;
+  (program: K.ProgramKind, name?: string | null): namedTypes.File
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+    name?: string | null
+    program: K.ProgramKind
+  }): namedTypes.File
 }
 export interface ProgramBuilder {
-    (body: K.StatementKind[]): namedTypes.Program;
-    from(params: {
-        body: K.StatementKind[];
-        comments?: K.CommentKind[] | null;
-        directives?: K.DirectiveKind[];
-        interpreter?: K.InterpreterDirectiveKind | null;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.Program;
+  (body: K.StatementKind[]): namedTypes.Program
+  from(params: {
+    body: K.StatementKind[]
+    comments?: K.CommentKind[] | null
+    directives?: K.DirectiveKind[]
+    interpreter?: K.InterpreterDirectiveKind | null
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.Program
 }
 export interface IdentifierBuilder {
-    (name: string): namedTypes.Identifier;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-        name: string;
-        optional?: boolean;
-        typeAnnotation?: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null;
-    }): namedTypes.Identifier;
+  (name: string): namedTypes.Identifier
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+    name: string
+    optional?: boolean
+    typeAnnotation?: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null
+  }): namedTypes.Identifier
 }
 export interface BlockStatementBuilder {
-    (body: K.StatementKind[]): namedTypes.BlockStatement;
-    from(params: {
-        body: K.StatementKind[];
-        comments?: K.CommentKind[] | null;
-        directives?: K.DirectiveKind[];
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.BlockStatement;
+  (body: K.StatementKind[]): namedTypes.BlockStatement
+  from(params: {
+    body: K.StatementKind[]
+    comments?: K.CommentKind[] | null
+    directives?: K.DirectiveKind[]
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.BlockStatement
 }
 export interface EmptyStatementBuilder {
-    (): namedTypes.EmptyStatement;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.EmptyStatement;
+  (): namedTypes.EmptyStatement
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.EmptyStatement
 }
 export interface ExpressionStatementBuilder {
-    (expression: K.ExpressionKind): namedTypes.ExpressionStatement;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        expression: K.ExpressionKind;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.ExpressionStatement;
+  (expression: K.ExpressionKind): namedTypes.ExpressionStatement
+  from(params: {
+    comments?: K.CommentKind[] | null
+    expression: K.ExpressionKind
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.ExpressionStatement
 }
 export interface IfStatementBuilder {
-    (test: K.ExpressionKind, consequent: K.StatementKind, alternate?: K.StatementKind | null): namedTypes.IfStatement;
-    from(params: {
-        alternate?: K.StatementKind | null;
-        comments?: K.CommentKind[] | null;
-        consequent: K.StatementKind;
-        loc?: K.SourceLocationKind | null;
-        test: K.ExpressionKind;
-    }): namedTypes.IfStatement;
+  (
+    test: K.ExpressionKind,
+    consequent: K.StatementKind,
+    alternate?: K.StatementKind | null,
+  ): namedTypes.IfStatement
+  from(params: {
+    alternate?: K.StatementKind | null
+    comments?: K.CommentKind[] | null
+    consequent: K.StatementKind
+    loc?: K.SourceLocationKind | null
+    test: K.ExpressionKind
+  }): namedTypes.IfStatement
 }
 export interface LabeledStatementBuilder {
-    (label: K.IdentifierKind, body: K.StatementKind): namedTypes.LabeledStatement;
-    from(params: {
-        body: K.StatementKind;
-        comments?: K.CommentKind[] | null;
-        label: K.IdentifierKind;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.LabeledStatement;
+  (label: K.IdentifierKind, body: K.StatementKind): namedTypes.LabeledStatement
+  from(params: {
+    body: K.StatementKind
+    comments?: K.CommentKind[] | null
+    label: K.IdentifierKind
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.LabeledStatement
 }
 export interface BreakStatementBuilder {
-    (label?: K.IdentifierKind | null): namedTypes.BreakStatement;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        label?: K.IdentifierKind | null;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.BreakStatement;
+  (label?: K.IdentifierKind | null): namedTypes.BreakStatement
+  from(params: {
+    comments?: K.CommentKind[] | null
+    label?: K.IdentifierKind | null
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.BreakStatement
 }
 export interface ContinueStatementBuilder {
-    (label?: K.IdentifierKind | null): namedTypes.ContinueStatement;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        label?: K.IdentifierKind | null;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.ContinueStatement;
+  (label?: K.IdentifierKind | null): namedTypes.ContinueStatement
+  from(params: {
+    comments?: K.CommentKind[] | null
+    label?: K.IdentifierKind | null
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.ContinueStatement
 }
 export interface WithStatementBuilder {
-    (object: K.ExpressionKind, body: K.StatementKind): namedTypes.WithStatement;
-    from(params: {
-        body: K.StatementKind;
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-        object: K.ExpressionKind;
-    }): namedTypes.WithStatement;
+  (object: K.ExpressionKind, body: K.StatementKind): namedTypes.WithStatement
+  from(params: {
+    body: K.StatementKind
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+    object: K.ExpressionKind
+  }): namedTypes.WithStatement
 }
 export interface SwitchStatementBuilder {
-    (discriminant: K.ExpressionKind, cases: K.SwitchCaseKind[], lexical?: boolean): namedTypes.SwitchStatement;
-    from(params: {
-        cases: K.SwitchCaseKind[];
-        comments?: K.CommentKind[] | null;
-        discriminant: K.ExpressionKind;
-        lexical?: boolean;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.SwitchStatement;
+  (
+    discriminant: K.ExpressionKind,
+    cases: K.SwitchCaseKind[],
+    lexical?: boolean,
+  ): namedTypes.SwitchStatement
+  from(params: {
+    cases: K.SwitchCaseKind[]
+    comments?: K.CommentKind[] | null
+    discriminant: K.ExpressionKind
+    lexical?: boolean
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.SwitchStatement
 }
 export interface SwitchCaseBuilder {
-    (test: K.ExpressionKind | null, consequent: K.StatementKind[]): namedTypes.SwitchCase;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        consequent: K.StatementKind[];
-        loc?: K.SourceLocationKind | null;
-        test: K.ExpressionKind | null;
-    }): namedTypes.SwitchCase;
+  (
+    test: K.ExpressionKind | null,
+    consequent: K.StatementKind[],
+  ): namedTypes.SwitchCase
+  from(params: {
+    comments?: K.CommentKind[] | null
+    consequent: K.StatementKind[]
+    loc?: K.SourceLocationKind | null
+    test: K.ExpressionKind | null
+  }): namedTypes.SwitchCase
 }
 export interface ReturnStatementBuilder {
-    (argument: K.ExpressionKind | null): namedTypes.ReturnStatement;
-    from(params: {
-        argument: K.ExpressionKind | null;
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.ReturnStatement;
+  (argument: K.ExpressionKind | null): namedTypes.ReturnStatement
+  from(params: {
+    argument: K.ExpressionKind | null
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.ReturnStatement
 }
 export interface ThrowStatementBuilder {
-    (argument: K.ExpressionKind): namedTypes.ThrowStatement;
-    from(params: {
-        argument: K.ExpressionKind;
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.ThrowStatement;
+  (argument: K.ExpressionKind): namedTypes.ThrowStatement
+  from(params: {
+    argument: K.ExpressionKind
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.ThrowStatement
 }
 export interface TryStatementBuilder {
-    (block: K.BlockStatementKind, handler?: K.CatchClauseKind | null, finalizer?: K.BlockStatementKind | null): namedTypes.TryStatement;
-    from(params: {
-        block: K.BlockStatementKind;
-        comments?: K.CommentKind[] | null;
-        finalizer?: K.BlockStatementKind | null;
-        guardedHandlers?: K.CatchClauseKind[];
-        handler?: K.CatchClauseKind | null;
-        handlers?: K.CatchClauseKind[];
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.TryStatement;
+  (
+    block: K.BlockStatementKind,
+    handler?: K.CatchClauseKind | null,
+    finalizer?: K.BlockStatementKind | null,
+  ): namedTypes.TryStatement
+  from(params: {
+    block: K.BlockStatementKind
+    comments?: K.CommentKind[] | null
+    finalizer?: K.BlockStatementKind | null
+    guardedHandlers?: K.CatchClauseKind[]
+    handler?: K.CatchClauseKind | null
+    handlers?: K.CatchClauseKind[]
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.TryStatement
 }
 export interface CatchClauseBuilder {
-    (param: K.PatternKind | null | undefined, guard: K.ExpressionKind | null | undefined, body: K.BlockStatementKind): namedTypes.CatchClause;
-    from(params: {
-        body: K.BlockStatementKind;
-        comments?: K.CommentKind[] | null;
-        guard?: K.ExpressionKind | null;
-        loc?: K.SourceLocationKind | null;
-        param?: K.PatternKind | null;
-    }): namedTypes.CatchClause;
+  (
+    param: K.PatternKind | null | undefined,
+    guard: K.ExpressionKind | null | undefined,
+    body: K.BlockStatementKind,
+  ): namedTypes.CatchClause
+  from(params: {
+    body: K.BlockStatementKind
+    comments?: K.CommentKind[] | null
+    guard?: K.ExpressionKind | null
+    loc?: K.SourceLocationKind | null
+    param?: K.PatternKind | null
+  }): namedTypes.CatchClause
 }
 export interface WhileStatementBuilder {
-    (test: K.ExpressionKind, body: K.StatementKind): namedTypes.WhileStatement;
-    from(params: {
-        body: K.StatementKind;
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-        test: K.ExpressionKind;
-    }): namedTypes.WhileStatement;
+  (test: K.ExpressionKind, body: K.StatementKind): namedTypes.WhileStatement
+  from(params: {
+    body: K.StatementKind
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+    test: K.ExpressionKind
+  }): namedTypes.WhileStatement
 }
 export interface DoWhileStatementBuilder {
-    (body: K.StatementKind, test: K.ExpressionKind): namedTypes.DoWhileStatement;
-    from(params: {
-        body: K.StatementKind;
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-        test: K.ExpressionKind;
-    }): namedTypes.DoWhileStatement;
+  (body: K.StatementKind, test: K.ExpressionKind): namedTypes.DoWhileStatement
+  from(params: {
+    body: K.StatementKind
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+    test: K.ExpressionKind
+  }): namedTypes.DoWhileStatement
 }
 export interface ForStatementBuilder {
-    (init: K.VariableDeclarationKind | K.ExpressionKind | null, test: K.ExpressionKind | null, update: K.ExpressionKind | null, body: K.StatementKind): namedTypes.ForStatement;
-    from(params: {
-        body: K.StatementKind;
-        comments?: K.CommentKind[] | null;
-        init: K.VariableDeclarationKind | K.ExpressionKind | null;
-        loc?: K.SourceLocationKind | null;
-        test: K.ExpressionKind | null;
-        update: K.ExpressionKind | null;
-    }): namedTypes.ForStatement;
+  (
+    init: K.VariableDeclarationKind | K.ExpressionKind | null,
+    test: K.ExpressionKind | null,
+    update: K.ExpressionKind | null,
+    body: K.StatementKind,
+  ): namedTypes.ForStatement
+  from(params: {
+    body: K.StatementKind
+    comments?: K.CommentKind[] | null
+    init: K.VariableDeclarationKind | K.ExpressionKind | null
+    loc?: K.SourceLocationKind | null
+    test: K.ExpressionKind | null
+    update: K.ExpressionKind | null
+  }): namedTypes.ForStatement
 }
 export interface VariableDeclarationBuilder {
-    (kind: "var" | "let" | "const", declarations: (K.VariableDeclaratorKind | K.IdentifierKind)[]): namedTypes.VariableDeclaration;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        declarations: (K.VariableDeclaratorKind | K.IdentifierKind)[];
-        kind: "var" | "let" | "const";
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.VariableDeclaration;
+  (
+    kind: 'var' | 'let' | 'const',
+    declarations: (K.VariableDeclaratorKind | K.IdentifierKind)[],
+  ): namedTypes.VariableDeclaration
+  from(params: {
+    comments?: K.CommentKind[] | null
+    declarations: (K.VariableDeclaratorKind | K.IdentifierKind)[]
+    kind: 'var' | 'let' | 'const'
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.VariableDeclaration
 }
 export interface ForInStatementBuilder {
-    (left: K.VariableDeclarationKind | K.ExpressionKind, right: K.ExpressionKind, body: K.StatementKind): namedTypes.ForInStatement;
-    from(params: {
-        body: K.StatementKind;
-        comments?: K.CommentKind[] | null;
-        left: K.VariableDeclarationKind | K.ExpressionKind;
-        loc?: K.SourceLocationKind | null;
-        right: K.ExpressionKind;
-    }): namedTypes.ForInStatement;
+  (
+    left: K.VariableDeclarationKind | K.ExpressionKind,
+    right: K.ExpressionKind,
+    body: K.StatementKind,
+  ): namedTypes.ForInStatement
+  from(params: {
+    body: K.StatementKind
+    comments?: K.CommentKind[] | null
+    left: K.VariableDeclarationKind | K.ExpressionKind
+    loc?: K.SourceLocationKind | null
+    right: K.ExpressionKind
+  }): namedTypes.ForInStatement
 }
 export interface DebuggerStatementBuilder {
-    (): namedTypes.DebuggerStatement;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.DebuggerStatement;
+  (): namedTypes.DebuggerStatement
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.DebuggerStatement
 }
 export interface FunctionDeclarationBuilder {
-    (id: K.IdentifierKind | null, params: K.PatternKind[], body: K.BlockStatementKind, generator?: boolean, expression?: boolean): namedTypes.FunctionDeclaration;
-    from(params: {
-        async?: boolean;
-        body: K.BlockStatementKind;
-        comments?: K.CommentKind[] | null;
-        defaults?: (K.ExpressionKind | null)[];
-        expression?: boolean;
-        generator?: boolean;
-        id: K.IdentifierKind | null;
-        loc?: K.SourceLocationKind | null;
-        params: K.PatternKind[];
-        predicate?: K.FlowPredicateKind | null;
-        rest?: K.IdentifierKind | null;
-        returnType?: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null;
-        typeParameters?: K.TypeParameterDeclarationKind | K.TSTypeParameterDeclarationKind | null;
-    }): namedTypes.FunctionDeclaration;
+  (
+    id: K.IdentifierKind | null,
+    params: K.PatternKind[],
+    body: K.BlockStatementKind,
+    generator?: boolean,
+    expression?: boolean,
+  ): namedTypes.FunctionDeclaration
+  from(params: {
+    async?: boolean
+    body: K.BlockStatementKind
+    comments?: K.CommentKind[] | null
+    defaults?: (K.ExpressionKind | null)[]
+    expression?: boolean
+    generator?: boolean
+    id: K.IdentifierKind | null
+    loc?: K.SourceLocationKind | null
+    params: K.PatternKind[]
+    predicate?: K.FlowPredicateKind | null
+    rest?: K.IdentifierKind | null
+    returnType?: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null
+    typeParameters?:
+      | K.TypeParameterDeclarationKind
+      | K.TSTypeParameterDeclarationKind
+      | null
+  }): namedTypes.FunctionDeclaration
 }
 export interface FunctionExpressionBuilder {
-    (id: K.IdentifierKind | null | undefined, params: K.PatternKind[], body: K.BlockStatementKind, generator?: boolean, expression?: boolean): namedTypes.FunctionExpression;
-    from(params: {
-        async?: boolean;
-        body: K.BlockStatementKind;
-        comments?: K.CommentKind[] | null;
-        defaults?: (K.ExpressionKind | null)[];
-        expression?: boolean;
-        generator?: boolean;
-        id?: K.IdentifierKind | null;
-        loc?: K.SourceLocationKind | null;
-        params: K.PatternKind[];
-        predicate?: K.FlowPredicateKind | null;
-        rest?: K.IdentifierKind | null;
-        returnType?: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null;
-        typeParameters?: K.TypeParameterDeclarationKind | K.TSTypeParameterDeclarationKind | null;
-    }): namedTypes.FunctionExpression;
+  (
+    id: K.IdentifierKind | null | undefined,
+    params: K.PatternKind[],
+    body: K.BlockStatementKind,
+    generator?: boolean,
+    expression?: boolean,
+  ): namedTypes.FunctionExpression
+  from(params: {
+    async?: boolean
+    body: K.BlockStatementKind
+    comments?: K.CommentKind[] | null
+    defaults?: (K.ExpressionKind | null)[]
+    expression?: boolean
+    generator?: boolean
+    id?: K.IdentifierKind | null
+    loc?: K.SourceLocationKind | null
+    params: K.PatternKind[]
+    predicate?: K.FlowPredicateKind | null
+    rest?: K.IdentifierKind | null
+    returnType?: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null
+    typeParameters?:
+      | K.TypeParameterDeclarationKind
+      | K.TSTypeParameterDeclarationKind
+      | null
+  }): namedTypes.FunctionExpression
 }
 export interface VariableDeclaratorBuilder {
-    (id: K.PatternKind, init?: K.ExpressionKind | null): namedTypes.VariableDeclarator;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        id: K.PatternKind;
-        init?: K.ExpressionKind | null;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.VariableDeclarator;
+  (
+    id: K.PatternKind,
+    init?: K.ExpressionKind | null,
+  ): namedTypes.VariableDeclarator
+  from(params: {
+    comments?: K.CommentKind[] | null
+    id: K.PatternKind
+    init?: K.ExpressionKind | null
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.VariableDeclarator
 }
 export interface ThisExpressionBuilder {
-    (): namedTypes.ThisExpression;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.ThisExpression;
+  (): namedTypes.ThisExpression
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.ThisExpression
 }
 export interface ArrayExpressionBuilder {
-    (elements: (K.ExpressionKind | K.SpreadElementKind | K.RestElementKind | null)[]): namedTypes.ArrayExpression;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        elements: (K.ExpressionKind | K.SpreadElementKind | K.RestElementKind | null)[];
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.ArrayExpression;
+  (
+    elements: (
+      | K.ExpressionKind
+      | K.SpreadElementKind
+      | K.RestElementKind
+      | null
+    )[],
+  ): namedTypes.ArrayExpression
+  from(params: {
+    comments?: K.CommentKind[] | null
+    elements: (
+      | K.ExpressionKind
+      | K.SpreadElementKind
+      | K.RestElementKind
+      | null
+    )[]
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.ArrayExpression
 }
 export interface ObjectExpressionBuilder {
-    (properties: (K.PropertyKind | K.ObjectMethodKind | K.ObjectPropertyKind | K.SpreadPropertyKind | K.SpreadElementKind)[]): namedTypes.ObjectExpression;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-        properties: (K.PropertyKind | K.ObjectMethodKind | K.ObjectPropertyKind | K.SpreadPropertyKind | K.SpreadElementKind)[];
-    }): namedTypes.ObjectExpression;
+  (
+    properties: (
+      | K.PropertyKind
+      | K.ObjectMethodKind
+      | K.ObjectPropertyKind
+      | K.SpreadPropertyKind
+      | K.SpreadElementKind
+    )[],
+  ): namedTypes.ObjectExpression
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+    properties: (
+      | K.PropertyKind
+      | K.ObjectMethodKind
+      | K.ObjectPropertyKind
+      | K.SpreadPropertyKind
+      | K.SpreadElementKind
+    )[]
+  }): namedTypes.ObjectExpression
 }
 export interface PropertyBuilder {
-    (kind: "init" | "get" | "set", key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind, value: K.ExpressionKind | K.PatternKind): namedTypes.Property;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        computed?: boolean;
-        decorators?: K.DecoratorKind[] | null;
-        key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind;
-        kind: "init" | "get" | "set";
-        loc?: K.SourceLocationKind | null;
-        method?: boolean;
-        shorthand?: boolean;
-        value: K.ExpressionKind | K.PatternKind;
-    }): namedTypes.Property;
+  (
+    kind: 'init' | 'get' | 'set',
+    key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind,
+    value: K.ExpressionKind | K.PatternKind,
+  ): namedTypes.Property
+  from(params: {
+    comments?: K.CommentKind[] | null
+    computed?: boolean
+    decorators?: K.DecoratorKind[] | null
+    key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind
+    kind: 'init' | 'get' | 'set'
+    loc?: K.SourceLocationKind | null
+    method?: boolean
+    shorthand?: boolean
+    value: K.ExpressionKind | K.PatternKind
+  }): namedTypes.Property
 }
 export interface LiteralBuilder {
-    (value: string | boolean | null | number | RegExp | BigInt): namedTypes.Literal;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-        value: string | boolean | null | number | RegExp | BigInt;
-    }): namedTypes.Literal;
+  (
+    value: string | boolean | null | number | RegExp | BigInt,
+  ): namedTypes.Literal
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+    value: string | boolean | null | number | RegExp | BigInt
+  }): namedTypes.Literal
 }
 export interface SequenceExpressionBuilder {
-    (expressions: K.ExpressionKind[]): namedTypes.SequenceExpression;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        expressions: K.ExpressionKind[];
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.SequenceExpression;
+  (expressions: K.ExpressionKind[]): namedTypes.SequenceExpression
+  from(params: {
+    comments?: K.CommentKind[] | null
+    expressions: K.ExpressionKind[]
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.SequenceExpression
 }
 export interface UnaryExpressionBuilder {
-    (operator: "-" | "+" | "!" | "~" | "typeof" | "void" | "delete", argument: K.ExpressionKind, prefix?: boolean): namedTypes.UnaryExpression;
-    from(params: {
-        argument: K.ExpressionKind;
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-        operator: "-" | "+" | "!" | "~" | "typeof" | "void" | "delete";
-        prefix?: boolean;
-    }): namedTypes.UnaryExpression;
+  (
+    operator: '-' | '+' | '!' | '~' | 'typeof' | 'void' | 'delete',
+    argument: K.ExpressionKind,
+    prefix?: boolean,
+  ): namedTypes.UnaryExpression
+  from(params: {
+    argument: K.ExpressionKind
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+    operator: '-' | '+' | '!' | '~' | 'typeof' | 'void' | 'delete'
+    prefix?: boolean
+  }): namedTypes.UnaryExpression
 }
 export interface BinaryExpressionBuilder {
-    (operator: "==" | "!=" | "===" | "!==" | "<" | "<=" | ">" | ">=" | "<<" | ">>" | ">>>" | "+" | "-" | "*" | "/" | "%" | "&" | "|" | "^" | "in" | "instanceof" | "**", left: K.ExpressionKind, right: K.ExpressionKind): namedTypes.BinaryExpression;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        left: K.ExpressionKind;
-        loc?: K.SourceLocationKind | null;
-        operator: "==" | "!=" | "===" | "!==" | "<" | "<=" | ">" | ">=" | "<<" | ">>" | ">>>" | "+" | "-" | "*" | "/" | "%" | "&" | "|" | "^" | "in" | "instanceof" | "**";
-        right: K.ExpressionKind;
-    }): namedTypes.BinaryExpression;
+  (
+    operator:
+      | '=='
+      | '!='
+      | '==='
+      | '!=='
+      | '<'
+      | '<='
+      | '>'
+      | '>='
+      | '<<'
+      | '>>'
+      | '>>>'
+      | '+'
+      | '-'
+      | '*'
+      | '/'
+      | '%'
+      | '&'
+      | '|'
+      | '^'
+      | 'in'
+      | 'instanceof'
+      | '**',
+    left: K.ExpressionKind,
+    right: K.ExpressionKind,
+  ): namedTypes.BinaryExpression
+  from(params: {
+    comments?: K.CommentKind[] | null
+    left: K.ExpressionKind
+    loc?: K.SourceLocationKind | null
+    operator:
+      | '=='
+      | '!='
+      | '==='
+      | '!=='
+      | '<'
+      | '<='
+      | '>'
+      | '>='
+      | '<<'
+      | '>>'
+      | '>>>'
+      | '+'
+      | '-'
+      | '*'
+      | '/'
+      | '%'
+      | '&'
+      | '|'
+      | '^'
+      | 'in'
+      | 'instanceof'
+      | '**'
+    right: K.ExpressionKind
+  }): namedTypes.BinaryExpression
 }
 export interface AssignmentExpressionBuilder {
-    (operator: "=" | "+=" | "-=" | "*=" | "/=" | "%=" | "<<=" | ">>=" | ">>>=" | "|=" | "^=" | "&=" | "**=" | "||=" | "&&=" | "??=", left: K.PatternKind | K.MemberExpressionKind, right: K.ExpressionKind): namedTypes.AssignmentExpression;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        left: K.PatternKind | K.MemberExpressionKind;
-        loc?: K.SourceLocationKind | null;
-        operator: "=" | "+=" | "-=" | "*=" | "/=" | "%=" | "<<=" | ">>=" | ">>>=" | "|=" | "^=" | "&=" | "**=" | "||=" | "&&=" | "??=";
-        right: K.ExpressionKind;
-    }): namedTypes.AssignmentExpression;
+  (
+    operator:
+      | '='
+      | '+='
+      | '-='
+      | '*='
+      | '/='
+      | '%='
+      | '<<='
+      | '>>='
+      | '>>>='
+      | '|='
+      | '^='
+      | '&='
+      | '**='
+      | '||='
+      | '&&='
+      | '??=',
+    left: K.PatternKind | K.MemberExpressionKind,
+    right: K.ExpressionKind,
+  ): namedTypes.AssignmentExpression
+  from(params: {
+    comments?: K.CommentKind[] | null
+    left: K.PatternKind | K.MemberExpressionKind
+    loc?: K.SourceLocationKind | null
+    operator:
+      | '='
+      | '+='
+      | '-='
+      | '*='
+      | '/='
+      | '%='
+      | '<<='
+      | '>>='
+      | '>>>='
+      | '|='
+      | '^='
+      | '&='
+      | '**='
+      | '||='
+      | '&&='
+      | '??='
+    right: K.ExpressionKind
+  }): namedTypes.AssignmentExpression
 }
 export interface MemberExpressionBuilder {
-    (object: K.ExpressionKind, property: K.IdentifierKind | K.ExpressionKind, computed?: boolean): namedTypes.MemberExpression;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        computed?: boolean;
-        loc?: K.SourceLocationKind | null;
-        object: K.ExpressionKind;
-        optional?: boolean;
-        property: K.IdentifierKind | K.ExpressionKind;
-    }): namedTypes.MemberExpression;
+  (
+    object: K.ExpressionKind,
+    property: K.IdentifierKind | K.ExpressionKind,
+    computed?: boolean,
+  ): namedTypes.MemberExpression
+  from(params: {
+    comments?: K.CommentKind[] | null
+    computed?: boolean
+    loc?: K.SourceLocationKind | null
+    object: K.ExpressionKind
+    optional?: boolean
+    property: K.IdentifierKind | K.ExpressionKind
+  }): namedTypes.MemberExpression
 }
 export interface UpdateExpressionBuilder {
-    (operator: "++" | "--", argument: K.ExpressionKind, prefix: boolean): namedTypes.UpdateExpression;
-    from(params: {
-        argument: K.ExpressionKind;
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-        operator: "++" | "--";
-        prefix: boolean;
-    }): namedTypes.UpdateExpression;
+  (
+    operator: '++' | '--',
+    argument: K.ExpressionKind,
+    prefix: boolean,
+  ): namedTypes.UpdateExpression
+  from(params: {
+    argument: K.ExpressionKind
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+    operator: '++' | '--'
+    prefix: boolean
+  }): namedTypes.UpdateExpression
 }
 export interface LogicalExpressionBuilder {
-    (operator: "||" | "&&" | "??", left: K.ExpressionKind, right: K.ExpressionKind): namedTypes.LogicalExpression;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        left: K.ExpressionKind;
-        loc?: K.SourceLocationKind | null;
-        operator: "||" | "&&" | "??";
-        right: K.ExpressionKind;
-    }): namedTypes.LogicalExpression;
+  (
+    operator: '||' | '&&' | '??',
+    left: K.ExpressionKind,
+    right: K.ExpressionKind,
+  ): namedTypes.LogicalExpression
+  from(params: {
+    comments?: K.CommentKind[] | null
+    left: K.ExpressionKind
+    loc?: K.SourceLocationKind | null
+    operator: '||' | '&&' | '??'
+    right: K.ExpressionKind
+  }): namedTypes.LogicalExpression
 }
 export interface ConditionalExpressionBuilder {
-    (test: K.ExpressionKind, consequent: K.ExpressionKind, alternate: K.ExpressionKind): namedTypes.ConditionalExpression;
-    from(params: {
-        alternate: K.ExpressionKind;
-        comments?: K.CommentKind[] | null;
-        consequent: K.ExpressionKind;
-        loc?: K.SourceLocationKind | null;
-        test: K.ExpressionKind;
-    }): namedTypes.ConditionalExpression;
+  (
+    test: K.ExpressionKind,
+    consequent: K.ExpressionKind,
+    alternate: K.ExpressionKind,
+  ): namedTypes.ConditionalExpression
+  from(params: {
+    alternate: K.ExpressionKind
+    comments?: K.CommentKind[] | null
+    consequent: K.ExpressionKind
+    loc?: K.SourceLocationKind | null
+    test: K.ExpressionKind
+  }): namedTypes.ConditionalExpression
 }
 export interface NewExpressionBuilder {
-    (callee: K.ExpressionKind, argumentsParam: (K.ExpressionKind | K.SpreadElementKind)[]): namedTypes.NewExpression;
-    from(params: {
-        arguments: (K.ExpressionKind | K.SpreadElementKind)[];
-        callee: K.ExpressionKind;
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-        typeArguments?: null | K.TypeParameterInstantiationKind;
-    }): namedTypes.NewExpression;
+  (
+    callee: K.ExpressionKind,
+    argumentsParam: (K.ExpressionKind | K.SpreadElementKind)[],
+  ): namedTypes.NewExpression
+  from(params: {
+    arguments: (K.ExpressionKind | K.SpreadElementKind)[]
+    callee: K.ExpressionKind
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+    typeArguments?: null | K.TypeParameterInstantiationKind
+  }): namedTypes.NewExpression
 }
 export interface CallExpressionBuilder {
-    (callee: K.ExpressionKind, argumentsParam: (K.ExpressionKind | K.SpreadElementKind)[]): namedTypes.CallExpression;
-    from(params: {
-        arguments: (K.ExpressionKind | K.SpreadElementKind)[];
-        callee: K.ExpressionKind;
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-        optional?: boolean;
-        typeArguments?: null | K.TypeParameterInstantiationKind;
-    }): namedTypes.CallExpression;
+  (
+    callee: K.ExpressionKind,
+    argumentsParam: (K.ExpressionKind | K.SpreadElementKind)[],
+  ): namedTypes.CallExpression
+  from(params: {
+    arguments: (K.ExpressionKind | K.SpreadElementKind)[]
+    callee: K.ExpressionKind
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+    optional?: boolean
+    typeArguments?: null | K.TypeParameterInstantiationKind
+    typeParameters?: null | K.TSTypeParameterInstantiationKind
+  }): namedTypes.CallExpression
 }
 export interface RestElementBuilder {
-    (argument: K.PatternKind): namedTypes.RestElement;
-    from(params: {
-        argument: K.PatternKind;
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-        typeAnnotation?: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null;
-    }): namedTypes.RestElement;
+  (argument: K.PatternKind): namedTypes.RestElement
+  from(params: {
+    argument: K.PatternKind
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+    typeAnnotation?: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null
+  }): namedTypes.RestElement
 }
 export interface TypeAnnotationBuilder {
-    (typeAnnotation: K.FlowTypeKind): namedTypes.TypeAnnotation;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-        typeAnnotation: K.FlowTypeKind;
-    }): namedTypes.TypeAnnotation;
+  (typeAnnotation: K.FlowTypeKind): namedTypes.TypeAnnotation
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+    typeAnnotation: K.FlowTypeKind
+  }): namedTypes.TypeAnnotation
 }
 export interface TSTypeAnnotationBuilder {
-    (typeAnnotation: K.TSTypeKind | K.TSTypeAnnotationKind): namedTypes.TSTypeAnnotation;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-        typeAnnotation: K.TSTypeKind | K.TSTypeAnnotationKind;
-    }): namedTypes.TSTypeAnnotation;
+  (
+    typeAnnotation: K.TSTypeKind | K.TSTypeAnnotationKind,
+  ): namedTypes.TSTypeAnnotation
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+    typeAnnotation: K.TSTypeKind | K.TSTypeAnnotationKind
+  }): namedTypes.TSTypeAnnotation
 }
 export interface SpreadElementPatternBuilder {
-    (argument: K.PatternKind): namedTypes.SpreadElementPattern;
-    from(params: {
-        argument: K.PatternKind;
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.SpreadElementPattern;
+  (argument: K.PatternKind): namedTypes.SpreadElementPattern
+  from(params: {
+    argument: K.PatternKind
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.SpreadElementPattern
 }
 export interface ArrowFunctionExpressionBuilder {
-    (params: K.PatternKind[], body: K.BlockStatementKind | K.ExpressionKind, expression?: boolean): namedTypes.ArrowFunctionExpression;
-    from(params: {
-        async?: boolean;
-        body: K.BlockStatementKind | K.ExpressionKind;
-        comments?: K.CommentKind[] | null;
-        defaults?: (K.ExpressionKind | null)[];
-        expression?: boolean;
-        generator?: false;
-        id?: null;
-        loc?: K.SourceLocationKind | null;
-        params: K.PatternKind[];
-        predicate?: K.FlowPredicateKind | null;
-        rest?: K.IdentifierKind | null;
-        returnType?: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null;
-        typeParameters?: K.TypeParameterDeclarationKind | K.TSTypeParameterDeclarationKind | null;
-    }): namedTypes.ArrowFunctionExpression;
+  (
+    params: K.PatternKind[],
+    body: K.BlockStatementKind | K.ExpressionKind,
+    expression?: boolean,
+  ): namedTypes.ArrowFunctionExpression
+  from(params: {
+    async?: boolean
+    body: K.BlockStatementKind | K.ExpressionKind
+    comments?: K.CommentKind[] | null
+    defaults?: (K.ExpressionKind | null)[]
+    expression?: boolean
+    generator?: false
+    id?: null
+    loc?: K.SourceLocationKind | null
+    params: K.PatternKind[]
+    predicate?: K.FlowPredicateKind | null
+    rest?: K.IdentifierKind | null
+    returnType?: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null
+    typeParameters?:
+      | K.TypeParameterDeclarationKind
+      | K.TSTypeParameterDeclarationKind
+      | null
+  }): namedTypes.ArrowFunctionExpression
 }
 export interface ForOfStatementBuilder {
-    (left: K.VariableDeclarationKind | K.PatternKind, right: K.ExpressionKind, body: K.StatementKind): namedTypes.ForOfStatement;
-    from(params: {
-        await?: boolean;
-        body: K.StatementKind;
-        comments?: K.CommentKind[] | null;
-        left: K.VariableDeclarationKind | K.PatternKind;
-        loc?: K.SourceLocationKind | null;
-        right: K.ExpressionKind;
-    }): namedTypes.ForOfStatement;
+  (
+    left: K.VariableDeclarationKind | K.PatternKind,
+    right: K.ExpressionKind,
+    body: K.StatementKind,
+  ): namedTypes.ForOfStatement
+  from(params: {
+    await?: boolean
+    body: K.StatementKind
+    comments?: K.CommentKind[] | null
+    left: K.VariableDeclarationKind | K.PatternKind
+    loc?: K.SourceLocationKind | null
+    right: K.ExpressionKind
+  }): namedTypes.ForOfStatement
 }
 export interface YieldExpressionBuilder {
-    (argument: K.ExpressionKind | null, delegate?: boolean): namedTypes.YieldExpression;
-    from(params: {
-        argument: K.ExpressionKind | null;
-        comments?: K.CommentKind[] | null;
-        delegate?: boolean;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.YieldExpression;
+  (
+    argument: K.ExpressionKind | null,
+    delegate?: boolean,
+  ): namedTypes.YieldExpression
+  from(params: {
+    argument: K.ExpressionKind | null
+    comments?: K.CommentKind[] | null
+    delegate?: boolean
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.YieldExpression
 }
 export interface GeneratorExpressionBuilder {
-    (body: K.ExpressionKind, blocks: K.ComprehensionBlockKind[], filter: K.ExpressionKind | null): namedTypes.GeneratorExpression;
-    from(params: {
-        blocks: K.ComprehensionBlockKind[];
-        body: K.ExpressionKind;
-        comments?: K.CommentKind[] | null;
-        filter: K.ExpressionKind | null;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.GeneratorExpression;
+  (
+    body: K.ExpressionKind,
+    blocks: K.ComprehensionBlockKind[],
+    filter: K.ExpressionKind | null,
+  ): namedTypes.GeneratorExpression
+  from(params: {
+    blocks: K.ComprehensionBlockKind[]
+    body: K.ExpressionKind
+    comments?: K.CommentKind[] | null
+    filter: K.ExpressionKind | null
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.GeneratorExpression
 }
 export interface ComprehensionBlockBuilder {
-    (left: K.PatternKind, right: K.ExpressionKind, each: boolean): namedTypes.ComprehensionBlock;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        each: boolean;
-        left: K.PatternKind;
-        loc?: K.SourceLocationKind | null;
-        right: K.ExpressionKind;
-    }): namedTypes.ComprehensionBlock;
+  (
+    left: K.PatternKind,
+    right: K.ExpressionKind,
+    each: boolean,
+  ): namedTypes.ComprehensionBlock
+  from(params: {
+    comments?: K.CommentKind[] | null
+    each: boolean
+    left: K.PatternKind
+    loc?: K.SourceLocationKind | null
+    right: K.ExpressionKind
+  }): namedTypes.ComprehensionBlock
 }
 export interface ComprehensionExpressionBuilder {
-    (body: K.ExpressionKind, blocks: K.ComprehensionBlockKind[], filter: K.ExpressionKind | null): namedTypes.ComprehensionExpression;
-    from(params: {
-        blocks: K.ComprehensionBlockKind[];
-        body: K.ExpressionKind;
-        comments?: K.CommentKind[] | null;
-        filter: K.ExpressionKind | null;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.ComprehensionExpression;
+  (
+    body: K.ExpressionKind,
+    blocks: K.ComprehensionBlockKind[],
+    filter: K.ExpressionKind | null,
+  ): namedTypes.ComprehensionExpression
+  from(params: {
+    blocks: K.ComprehensionBlockKind[]
+    body: K.ExpressionKind
+    comments?: K.CommentKind[] | null
+    filter: K.ExpressionKind | null
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.ComprehensionExpression
 }
 export interface ObjectPropertyBuilder {
-    (key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind, value: K.ExpressionKind | K.PatternKind): namedTypes.ObjectProperty;
-    from(params: {
-        accessibility?: K.LiteralKind | null;
-        comments?: K.CommentKind[] | null;
-        computed?: boolean;
-        key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind;
-        loc?: K.SourceLocationKind | null;
-        shorthand?: boolean;
-        value: K.ExpressionKind | K.PatternKind;
-    }): namedTypes.ObjectProperty;
+  (
+    key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind,
+    value: K.ExpressionKind | K.PatternKind,
+  ): namedTypes.ObjectProperty
+  from(params: {
+    accessibility?: K.LiteralKind | null
+    comments?: K.CommentKind[] | null
+    computed?: boolean
+    key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind
+    loc?: K.SourceLocationKind | null
+    shorthand?: boolean
+    value: K.ExpressionKind | K.PatternKind
+  }): namedTypes.ObjectProperty
 }
 export interface PropertyPatternBuilder {
-    (key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind, pattern: K.PatternKind): namedTypes.PropertyPattern;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        computed?: boolean;
-        key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind;
-        loc?: K.SourceLocationKind | null;
-        pattern: K.PatternKind;
-    }): namedTypes.PropertyPattern;
+  (
+    key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind,
+    pattern: K.PatternKind,
+  ): namedTypes.PropertyPattern
+  from(params: {
+    comments?: K.CommentKind[] | null
+    computed?: boolean
+    key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind
+    loc?: K.SourceLocationKind | null
+    pattern: K.PatternKind
+  }): namedTypes.PropertyPattern
 }
 export interface ObjectPatternBuilder {
-    (properties: (K.PropertyKind | K.PropertyPatternKind | K.SpreadPropertyPatternKind | K.SpreadPropertyKind | K.ObjectPropertyKind | K.RestPropertyKind | K.RestElementKind)[]): namedTypes.ObjectPattern;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        decorators?: K.DecoratorKind[] | null;
-        loc?: K.SourceLocationKind | null;
-        properties: (K.PropertyKind | K.PropertyPatternKind | K.SpreadPropertyPatternKind | K.SpreadPropertyKind | K.ObjectPropertyKind | K.RestPropertyKind | K.RestElementKind)[];
-        typeAnnotation?: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null;
-    }): namedTypes.ObjectPattern;
+  (
+    properties: (
+      | K.PropertyKind
+      | K.PropertyPatternKind
+      | K.SpreadPropertyPatternKind
+      | K.SpreadPropertyKind
+      | K.ObjectPropertyKind
+      | K.RestPropertyKind
+      | K.RestElementKind
+    )[],
+  ): namedTypes.ObjectPattern
+  from(params: {
+    comments?: K.CommentKind[] | null
+    decorators?: K.DecoratorKind[] | null
+    loc?: K.SourceLocationKind | null
+    properties: (
+      | K.PropertyKind
+      | K.PropertyPatternKind
+      | K.SpreadPropertyPatternKind
+      | K.SpreadPropertyKind
+      | K.ObjectPropertyKind
+      | K.RestPropertyKind
+      | K.RestElementKind
+    )[]
+    typeAnnotation?: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null
+  }): namedTypes.ObjectPattern
 }
 export interface ArrayPatternBuilder {
-    (elements: (K.PatternKind | K.SpreadElementKind | null)[]): namedTypes.ArrayPattern;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        elements: (K.PatternKind | K.SpreadElementKind | null)[];
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.ArrayPattern;
+  (
+    elements: (K.PatternKind | K.SpreadElementKind | null)[],
+  ): namedTypes.ArrayPattern
+  from(params: {
+    comments?: K.CommentKind[] | null
+    elements: (K.PatternKind | K.SpreadElementKind | null)[]
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.ArrayPattern
 }
 export interface SpreadElementBuilder {
-    (argument: K.ExpressionKind): namedTypes.SpreadElement;
-    from(params: {
-        argument: K.ExpressionKind;
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.SpreadElement;
+  (argument: K.ExpressionKind): namedTypes.SpreadElement
+  from(params: {
+    argument: K.ExpressionKind
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.SpreadElement
 }
 export interface AssignmentPatternBuilder {
-    (left: K.PatternKind, right: K.ExpressionKind): namedTypes.AssignmentPattern;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        left: K.PatternKind;
-        loc?: K.SourceLocationKind | null;
-        right: K.ExpressionKind;
-    }): namedTypes.AssignmentPattern;
+  (left: K.PatternKind, right: K.ExpressionKind): namedTypes.AssignmentPattern
+  from(params: {
+    comments?: K.CommentKind[] | null
+    left: K.PatternKind
+    loc?: K.SourceLocationKind | null
+    right: K.ExpressionKind
+  }): namedTypes.AssignmentPattern
 }
 export interface MethodDefinitionBuilder {
-    (kind: "constructor" | "method" | "get" | "set", key: K.ExpressionKind, value: K.FunctionKind, staticParam?: boolean): namedTypes.MethodDefinition;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        computed?: boolean;
-        decorators?: K.DecoratorKind[] | null;
-        key: K.ExpressionKind;
-        kind: "constructor" | "method" | "get" | "set";
-        loc?: K.SourceLocationKind | null;
-        static?: boolean;
-        value: K.FunctionKind;
-    }): namedTypes.MethodDefinition;
+  (
+    kind: 'constructor' | 'method' | 'get' | 'set',
+    key: K.ExpressionKind,
+    value: K.FunctionKind,
+    staticParam?: boolean,
+  ): namedTypes.MethodDefinition
+  from(params: {
+    comments?: K.CommentKind[] | null
+    computed?: boolean
+    decorators?: K.DecoratorKind[] | null
+    key: K.ExpressionKind
+    kind: 'constructor' | 'method' | 'get' | 'set'
+    loc?: K.SourceLocationKind | null
+    static?: boolean
+    value: K.FunctionKind
+  }): namedTypes.MethodDefinition
 }
 export interface ClassPropertyDefinitionBuilder {
-    (definition: K.MethodDefinitionKind | K.VariableDeclaratorKind | K.ClassPropertyDefinitionKind | K.ClassPropertyKind | K.StaticBlockKind): namedTypes.ClassPropertyDefinition;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        definition: K.MethodDefinitionKind | K.VariableDeclaratorKind | K.ClassPropertyDefinitionKind | K.ClassPropertyKind | K.StaticBlockKind;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.ClassPropertyDefinition;
+  (
+    definition:
+      | K.MethodDefinitionKind
+      | K.VariableDeclaratorKind
+      | K.ClassPropertyDefinitionKind
+      | K.ClassPropertyKind
+      | K.StaticBlockKind,
+  ): namedTypes.ClassPropertyDefinition
+  from(params: {
+    comments?: K.CommentKind[] | null
+    definition:
+      | K.MethodDefinitionKind
+      | K.VariableDeclaratorKind
+      | K.ClassPropertyDefinitionKind
+      | K.ClassPropertyKind
+      | K.StaticBlockKind
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.ClassPropertyDefinition
 }
 export interface ClassPropertyBuilder {
-    (key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind, value: K.ExpressionKind | null, typeAnnotation?: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null, staticParam?: boolean): namedTypes.ClassProperty;
-    from(params: {
-        access?: "public" | "private" | "protected" | undefined;
-        comments?: K.CommentKind[] | null;
-        computed?: boolean;
-        key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind;
-        loc?: K.SourceLocationKind | null;
-        static?: boolean;
-        typeAnnotation?: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null;
-        value: K.ExpressionKind | null;
-        variance?: K.VarianceKind | "plus" | "minus" | null;
-    }): namedTypes.ClassProperty;
+  (
+    key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind,
+    value: K.ExpressionKind | null,
+    typeAnnotation?: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null,
+    staticParam?: boolean,
+  ): namedTypes.ClassProperty
+  from(params: {
+    access?: 'public' | 'private' | 'protected' | undefined
+    comments?: K.CommentKind[] | null
+    computed?: boolean
+    key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind
+    loc?: K.SourceLocationKind | null
+    static?: boolean
+    typeAnnotation?: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null
+    value: K.ExpressionKind | null
+    variance?: K.VarianceKind | 'plus' | 'minus' | null
+  }): namedTypes.ClassProperty
 }
 export interface StaticBlockBuilder {
-    (body: K.StatementKind[]): namedTypes.StaticBlock;
-    from(params: {
-        body: K.StatementKind[];
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.StaticBlock;
+  (body: K.StatementKind[]): namedTypes.StaticBlock
+  from(params: {
+    body: K.StatementKind[]
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.StaticBlock
 }
 export interface ClassBodyBuilder {
-    (body: (K.MethodDefinitionKind | K.VariableDeclaratorKind | K.ClassPropertyDefinitionKind | K.ClassPropertyKind | K.ClassPrivatePropertyKind | K.ClassAccessorPropertyKind | K.ClassMethodKind | K.ClassPrivateMethodKind | K.StaticBlockKind | K.TSDeclareMethodKind | K.TSCallSignatureDeclarationKind | K.TSConstructSignatureDeclarationKind | K.TSIndexSignatureKind | K.TSMethodSignatureKind | K.TSPropertySignatureKind)[]): namedTypes.ClassBody;
-    from(params: {
-        body: (K.MethodDefinitionKind | K.VariableDeclaratorKind | K.ClassPropertyDefinitionKind | K.ClassPropertyKind | K.ClassPrivatePropertyKind | K.ClassAccessorPropertyKind | K.ClassMethodKind | K.ClassPrivateMethodKind | K.StaticBlockKind | K.TSDeclareMethodKind | K.TSCallSignatureDeclarationKind | K.TSConstructSignatureDeclarationKind | K.TSIndexSignatureKind | K.TSMethodSignatureKind | K.TSPropertySignatureKind)[];
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.ClassBody;
+  (
+    body: (
+      | K.MethodDefinitionKind
+      | K.VariableDeclaratorKind
+      | K.ClassPropertyDefinitionKind
+      | K.ClassPropertyKind
+      | K.ClassPrivatePropertyKind
+      | K.ClassAccessorPropertyKind
+      | K.ClassMethodKind
+      | K.ClassPrivateMethodKind
+      | K.StaticBlockKind
+      | K.TSDeclareMethodKind
+      | K.TSCallSignatureDeclarationKind
+      | K.TSConstructSignatureDeclarationKind
+      | K.TSIndexSignatureKind
+      | K.TSMethodSignatureKind
+      | K.TSPropertySignatureKind
+    )[],
+  ): namedTypes.ClassBody
+  from(params: {
+    body: (
+      | K.MethodDefinitionKind
+      | K.VariableDeclaratorKind
+      | K.ClassPropertyDefinitionKind
+      | K.ClassPropertyKind
+      | K.ClassPrivatePropertyKind
+      | K.ClassAccessorPropertyKind
+      | K.ClassMethodKind
+      | K.ClassPrivateMethodKind
+      | K.StaticBlockKind
+      | K.TSDeclareMethodKind
+      | K.TSCallSignatureDeclarationKind
+      | K.TSConstructSignatureDeclarationKind
+      | K.TSIndexSignatureKind
+      | K.TSMethodSignatureKind
+      | K.TSPropertySignatureKind
+    )[]
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.ClassBody
 }
 export interface ClassDeclarationBuilder {
-    (id: K.IdentifierKind | null, body: K.ClassBodyKind, superClass?: K.ExpressionKind | null): namedTypes.ClassDeclaration;
-    from(params: {
-        body: K.ClassBodyKind;
-        comments?: K.CommentKind[] | null;
-        id: K.IdentifierKind | null;
-        implements?: K.ClassImplementsKind[] | K.TSExpressionWithTypeArgumentsKind[];
-        loc?: K.SourceLocationKind | null;
-        superClass?: K.ExpressionKind | null;
-        superTypeParameters?: K.TypeParameterInstantiationKind | K.TSTypeParameterInstantiationKind | null;
-        typeParameters?: K.TypeParameterDeclarationKind | K.TSTypeParameterDeclarationKind | null;
-    }): namedTypes.ClassDeclaration;
+  (
+    id: K.IdentifierKind | null,
+    body: K.ClassBodyKind,
+    superClass?: K.ExpressionKind | null,
+  ): namedTypes.ClassDeclaration
+  from(params: {
+    body: K.ClassBodyKind
+    comments?: K.CommentKind[] | null
+    id: K.IdentifierKind | null
+    implements?: K.ClassImplementsKind[] | K.TSExpressionWithTypeArgumentsKind[]
+    loc?: K.SourceLocationKind | null
+    superClass?: K.ExpressionKind | null
+    superTypeParameters?:
+      | K.TypeParameterInstantiationKind
+      | K.TSTypeParameterInstantiationKind
+      | null
+    typeParameters?:
+      | K.TypeParameterDeclarationKind
+      | K.TSTypeParameterDeclarationKind
+      | null
+  }): namedTypes.ClassDeclaration
 }
 export interface ClassExpressionBuilder {
-    (id: K.IdentifierKind | null | undefined, body: K.ClassBodyKind, superClass?: K.ExpressionKind | null): namedTypes.ClassExpression;
-    from(params: {
-        body: K.ClassBodyKind;
-        comments?: K.CommentKind[] | null;
-        id?: K.IdentifierKind | null;
-        implements?: K.ClassImplementsKind[] | K.TSExpressionWithTypeArgumentsKind[];
-        loc?: K.SourceLocationKind | null;
-        superClass?: K.ExpressionKind | null;
-        superTypeParameters?: K.TypeParameterInstantiationKind | K.TSTypeParameterInstantiationKind | null;
-        typeParameters?: K.TypeParameterDeclarationKind | K.TSTypeParameterDeclarationKind | null;
-    }): namedTypes.ClassExpression;
+  (
+    id: K.IdentifierKind | null | undefined,
+    body: K.ClassBodyKind,
+    superClass?: K.ExpressionKind | null,
+  ): namedTypes.ClassExpression
+  from(params: {
+    body: K.ClassBodyKind
+    comments?: K.CommentKind[] | null
+    id?: K.IdentifierKind | null
+    implements?: K.ClassImplementsKind[] | K.TSExpressionWithTypeArgumentsKind[]
+    loc?: K.SourceLocationKind | null
+    superClass?: K.ExpressionKind | null
+    superTypeParameters?:
+      | K.TypeParameterInstantiationKind
+      | K.TSTypeParameterInstantiationKind
+      | null
+    typeParameters?:
+      | K.TypeParameterDeclarationKind
+      | K.TSTypeParameterDeclarationKind
+      | null
+  }): namedTypes.ClassExpression
 }
 export interface SuperBuilder {
-    (): namedTypes.Super;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.Super;
+  (): namedTypes.Super
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.Super
 }
 export interface ImportSpecifierBuilder {
-    (imported: K.IdentifierKind, local?: K.IdentifierKind | null): namedTypes.ImportSpecifier;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        id?: K.IdentifierKind | null;
-        imported: K.IdentifierKind;
-        loc?: K.SourceLocationKind | null;
-        local?: K.IdentifierKind | null;
-        name?: K.IdentifierKind | null;
-    }): namedTypes.ImportSpecifier;
+  (
+    imported: K.IdentifierKind,
+    local?: K.IdentifierKind | null,
+  ): namedTypes.ImportSpecifier
+  from(params: {
+    comments?: K.CommentKind[] | null
+    id?: K.IdentifierKind | null
+    imported: K.IdentifierKind
+    loc?: K.SourceLocationKind | null
+    local?: K.IdentifierKind | null
+    name?: K.IdentifierKind | null
+  }): namedTypes.ImportSpecifier
 }
 export interface ImportDefaultSpecifierBuilder {
-    (local?: K.IdentifierKind | null): namedTypes.ImportDefaultSpecifier;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        id?: K.IdentifierKind | null;
-        loc?: K.SourceLocationKind | null;
-        local?: K.IdentifierKind | null;
-        name?: K.IdentifierKind | null;
-    }): namedTypes.ImportDefaultSpecifier;
+  (local?: K.IdentifierKind | null): namedTypes.ImportDefaultSpecifier
+  from(params: {
+    comments?: K.CommentKind[] | null
+    id?: K.IdentifierKind | null
+    loc?: K.SourceLocationKind | null
+    local?: K.IdentifierKind | null
+    name?: K.IdentifierKind | null
+  }): namedTypes.ImportDefaultSpecifier
 }
 export interface ImportNamespaceSpecifierBuilder {
-    (local?: K.IdentifierKind | null): namedTypes.ImportNamespaceSpecifier;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        id?: K.IdentifierKind | null;
-        loc?: K.SourceLocationKind | null;
-        local?: K.IdentifierKind | null;
-        name?: K.IdentifierKind | null;
-    }): namedTypes.ImportNamespaceSpecifier;
+  (local?: K.IdentifierKind | null): namedTypes.ImportNamespaceSpecifier
+  from(params: {
+    comments?: K.CommentKind[] | null
+    id?: K.IdentifierKind | null
+    loc?: K.SourceLocationKind | null
+    local?: K.IdentifierKind | null
+    name?: K.IdentifierKind | null
+  }): namedTypes.ImportNamespaceSpecifier
 }
 export interface ImportDeclarationBuilder {
-    (specifiers: (K.ImportSpecifierKind | K.ImportNamespaceSpecifierKind | K.ImportDefaultSpecifierKind)[] | undefined, source: K.LiteralKind, importKind?: "value" | "type" | "typeof"): namedTypes.ImportDeclaration;
-    from(params: {
-        assertions?: K.ImportAttributeKind[];
-        comments?: K.CommentKind[] | null;
-        importKind?: "value" | "type" | "typeof";
-        loc?: K.SourceLocationKind | null;
-        source: K.LiteralKind;
-        specifiers?: (K.ImportSpecifierKind | K.ImportNamespaceSpecifierKind | K.ImportDefaultSpecifierKind)[];
-    }): namedTypes.ImportDeclaration;
+  (
+    specifiers:
+      | (
+          | K.ImportSpecifierKind
+          | K.ImportNamespaceSpecifierKind
+          | K.ImportDefaultSpecifierKind
+        )[]
+      | undefined,
+    source: K.LiteralKind,
+    importKind?: 'value' | 'type' | 'typeof',
+  ): namedTypes.ImportDeclaration
+  from(params: {
+    assertions?: K.ImportAttributeKind[]
+    comments?: K.CommentKind[] | null
+    importKind?: 'value' | 'type' | 'typeof'
+    loc?: K.SourceLocationKind | null
+    source: K.LiteralKind
+    specifiers?: (
+      | K.ImportSpecifierKind
+      | K.ImportNamespaceSpecifierKind
+      | K.ImportDefaultSpecifierKind
+    )[]
+  }): namedTypes.ImportDeclaration
 }
 export interface ExportNamedDeclarationBuilder {
-    (declaration: K.DeclarationKind | null, specifiers?: K.ExportSpecifierKind[], source?: K.LiteralKind | null): namedTypes.ExportNamedDeclaration;
-    from(params: {
-        assertions?: K.ImportAttributeKind[];
-        comments?: K.CommentKind[] | null;
-        declaration: K.DeclarationKind | null;
-        loc?: K.SourceLocationKind | null;
-        source?: K.LiteralKind | null;
-        specifiers?: K.ExportSpecifierKind[];
-    }): namedTypes.ExportNamedDeclaration;
+  (
+    declaration: K.DeclarationKind | null,
+    specifiers?: K.ExportSpecifierKind[],
+    source?: K.LiteralKind | null,
+  ): namedTypes.ExportNamedDeclaration
+  from(params: {
+    assertions?: K.ImportAttributeKind[]
+    comments?: K.CommentKind[] | null
+    declaration: K.DeclarationKind | null
+    loc?: K.SourceLocationKind | null
+    source?: K.LiteralKind | null
+    specifiers?: K.ExportSpecifierKind[]
+  }): namedTypes.ExportNamedDeclaration
 }
 export interface ExportSpecifierBuilder {
-    (id?: K.IdentifierKind | null, name?: K.IdentifierKind | null): namedTypes.ExportSpecifier;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        exported: K.IdentifierKind;
-        id?: K.IdentifierKind | null;
-        loc?: K.SourceLocationKind | null;
-        local?: K.IdentifierKind | null;
-        name?: K.IdentifierKind | null;
-    }): namedTypes.ExportSpecifier;
+  (
+    id?: K.IdentifierKind | null,
+    name?: K.IdentifierKind | null,
+  ): namedTypes.ExportSpecifier
+  from(params: {
+    comments?: K.CommentKind[] | null
+    exported: K.IdentifierKind
+    id?: K.IdentifierKind | null
+    loc?: K.SourceLocationKind | null
+    local?: K.IdentifierKind | null
+    name?: K.IdentifierKind | null
+  }): namedTypes.ExportSpecifier
 }
 export interface ExportDefaultDeclarationBuilder {
-    (declaration: K.DeclarationKind | K.ExpressionKind): namedTypes.ExportDefaultDeclaration;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        declaration: K.DeclarationKind | K.ExpressionKind;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.ExportDefaultDeclaration;
+  (
+    declaration: K.DeclarationKind | K.ExpressionKind,
+  ): namedTypes.ExportDefaultDeclaration
+  from(params: {
+    comments?: K.CommentKind[] | null
+    declaration: K.DeclarationKind | K.ExpressionKind
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.ExportDefaultDeclaration
 }
 export interface ExportAllDeclarationBuilder {
-    (source: K.LiteralKind, exported?: K.IdentifierKind | null | undefined): namedTypes.ExportAllDeclaration;
-    from(params: {
-        assertions?: K.ImportAttributeKind[];
-        comments?: K.CommentKind[] | null;
-        exported?: K.IdentifierKind | null | undefined;
-        loc?: K.SourceLocationKind | null;
-        source: K.LiteralKind;
-    }): namedTypes.ExportAllDeclaration;
+  (
+    source: K.LiteralKind,
+    exported?: K.IdentifierKind | null | undefined,
+  ): namedTypes.ExportAllDeclaration
+  from(params: {
+    assertions?: K.ImportAttributeKind[]
+    comments?: K.CommentKind[] | null
+    exported?: K.IdentifierKind | null | undefined
+    loc?: K.SourceLocationKind | null
+    source: K.LiteralKind
+  }): namedTypes.ExportAllDeclaration
 }
 export interface TaggedTemplateExpressionBuilder {
-    (tag: K.ExpressionKind, quasi: K.TemplateLiteralKind): namedTypes.TaggedTemplateExpression;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-        quasi: K.TemplateLiteralKind;
-        tag: K.ExpressionKind;
-    }): namedTypes.TaggedTemplateExpression;
+  (
+    tag: K.ExpressionKind,
+    quasi: K.TemplateLiteralKind,
+  ): namedTypes.TaggedTemplateExpression
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+    quasi: K.TemplateLiteralKind
+    tag: K.ExpressionKind
+  }): namedTypes.TaggedTemplateExpression
 }
 export interface TemplateLiteralBuilder {
-    (quasis: K.TemplateElementKind[], expressions: K.ExpressionKind[] | K.TSTypeKind[]): namedTypes.TemplateLiteral;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        expressions: K.ExpressionKind[] | K.TSTypeKind[];
-        loc?: K.SourceLocationKind | null;
-        quasis: K.TemplateElementKind[];
-    }): namedTypes.TemplateLiteral;
+  (
+    quasis: K.TemplateElementKind[],
+    expressions: K.ExpressionKind[] | K.TSTypeKind[],
+  ): namedTypes.TemplateLiteral
+  from(params: {
+    comments?: K.CommentKind[] | null
+    expressions: K.ExpressionKind[] | K.TSTypeKind[]
+    loc?: K.SourceLocationKind | null
+    quasis: K.TemplateElementKind[]
+  }): namedTypes.TemplateLiteral
 }
 export interface TemplateElementBuilder {
-    (value: {
-        cooked: string | null;
-        raw: string;
-    }, tail: boolean): namedTypes.TemplateElement;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-        tail: boolean;
-        value: {
-            cooked: string | null;
-            raw: string;
-        };
-    }): namedTypes.TemplateElement;
+  (
+    value: {
+      cooked: string | null
+      raw: string
+    },
+    tail: boolean,
+  ): namedTypes.TemplateElement
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+    tail: boolean
+    value: {
+      cooked: string | null
+      raw: string
+    }
+  }): namedTypes.TemplateElement
 }
 export interface MetaPropertyBuilder {
-    (meta: K.IdentifierKind, property: K.IdentifierKind): namedTypes.MetaProperty;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-        meta: K.IdentifierKind;
-        property: K.IdentifierKind;
-    }): namedTypes.MetaProperty;
+  (meta: K.IdentifierKind, property: K.IdentifierKind): namedTypes.MetaProperty
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+    meta: K.IdentifierKind
+    property: K.IdentifierKind
+  }): namedTypes.MetaProperty
 }
 export interface AwaitExpressionBuilder {
-    (argument: K.ExpressionKind | null, all?: boolean): namedTypes.AwaitExpression;
-    from(params: {
-        all?: boolean;
-        argument: K.ExpressionKind | null;
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.AwaitExpression;
+  (argument: K.ExpressionKind | null, all?: boolean): namedTypes.AwaitExpression
+  from(params: {
+    all?: boolean
+    argument: K.ExpressionKind | null
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.AwaitExpression
 }
 export interface SpreadPropertyBuilder {
-    (argument: K.ExpressionKind): namedTypes.SpreadProperty;
-    from(params: {
-        argument: K.ExpressionKind;
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.SpreadProperty;
+  (argument: K.ExpressionKind): namedTypes.SpreadProperty
+  from(params: {
+    argument: K.ExpressionKind
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.SpreadProperty
 }
 export interface SpreadPropertyPatternBuilder {
-    (argument: K.PatternKind): namedTypes.SpreadPropertyPattern;
-    from(params: {
-        argument: K.PatternKind;
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.SpreadPropertyPattern;
+  (argument: K.PatternKind): namedTypes.SpreadPropertyPattern
+  from(params: {
+    argument: K.PatternKind
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.SpreadPropertyPattern
 }
 export interface ImportExpressionBuilder {
-    (source: K.ExpressionKind): namedTypes.ImportExpression;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-        source: K.ExpressionKind;
-    }): namedTypes.ImportExpression;
+  (source: K.ExpressionKind): namedTypes.ImportExpression
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+    source: K.ExpressionKind
+  }): namedTypes.ImportExpression
 }
 export interface ChainExpressionBuilder {
-    (expression: K.ChainElementKind): namedTypes.ChainExpression;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        expression: K.ChainElementKind;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.ChainExpression;
+  (expression: K.ChainElementKind): namedTypes.ChainExpression
+  from(params: {
+    comments?: K.CommentKind[] | null
+    expression: K.ChainElementKind
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.ChainExpression
 }
 export interface OptionalCallExpressionBuilder {
-    (callee: K.ExpressionKind, argumentsParam: (K.ExpressionKind | K.SpreadElementKind)[], optional?: boolean): namedTypes.OptionalCallExpression;
-    from(params: {
-        arguments: (K.ExpressionKind | K.SpreadElementKind)[];
-        callee: K.ExpressionKind;
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-        optional?: boolean;
-        typeArguments?: null | K.TypeParameterInstantiationKind;
-    }): namedTypes.OptionalCallExpression;
+  (
+    callee: K.ExpressionKind,
+    argumentsParam: (K.ExpressionKind | K.SpreadElementKind)[],
+    optional?: boolean,
+  ): namedTypes.OptionalCallExpression
+  from(params: {
+    arguments: (K.ExpressionKind | K.SpreadElementKind)[]
+    callee: K.ExpressionKind
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+    optional?: boolean
+    typeArguments?: null | K.TypeParameterInstantiationKind
+  }): namedTypes.OptionalCallExpression
 }
 export interface OptionalMemberExpressionBuilder {
-    (object: K.ExpressionKind, property: K.IdentifierKind | K.ExpressionKind, computed?: boolean, optional?: boolean): namedTypes.OptionalMemberExpression;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        computed?: boolean;
-        loc?: K.SourceLocationKind | null;
-        object: K.ExpressionKind;
-        optional?: boolean;
-        property: K.IdentifierKind | K.ExpressionKind;
-    }): namedTypes.OptionalMemberExpression;
+  (
+    object: K.ExpressionKind,
+    property: K.IdentifierKind | K.ExpressionKind,
+    computed?: boolean,
+    optional?: boolean,
+  ): namedTypes.OptionalMemberExpression
+  from(params: {
+    comments?: K.CommentKind[] | null
+    computed?: boolean
+    loc?: K.SourceLocationKind | null
+    object: K.ExpressionKind
+    optional?: boolean
+    property: K.IdentifierKind | K.ExpressionKind
+  }): namedTypes.OptionalMemberExpression
 }
 export interface DecoratorBuilder {
-    (expression: K.ExpressionKind): namedTypes.Decorator;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        expression: K.ExpressionKind;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.Decorator;
+  (expression: K.ExpressionKind): namedTypes.Decorator
+  from(params: {
+    comments?: K.CommentKind[] | null
+    expression: K.ExpressionKind
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.Decorator
 }
 export interface PrivateNameBuilder {
-    (id: K.IdentifierKind): namedTypes.PrivateName;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        id: K.IdentifierKind;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.PrivateName;
+  (id: K.IdentifierKind): namedTypes.PrivateName
+  from(params: {
+    comments?: K.CommentKind[] | null
+    id: K.IdentifierKind
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.PrivateName
 }
 export interface ClassPrivatePropertyBuilder {
-    (key: K.PrivateNameKind, value?: K.ExpressionKind | null): namedTypes.ClassPrivateProperty;
-    from(params: {
-        access?: "public" | "private" | "protected" | undefined;
-        comments?: K.CommentKind[] | null;
-        computed?: boolean;
-        key: K.PrivateNameKind;
-        loc?: K.SourceLocationKind | null;
-        static?: boolean;
-        typeAnnotation?: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null;
-        value?: K.ExpressionKind | null;
-        variance?: K.VarianceKind | "plus" | "minus" | null;
-    }): namedTypes.ClassPrivateProperty;
+  (
+    key: K.PrivateNameKind,
+    value?: K.ExpressionKind | null,
+  ): namedTypes.ClassPrivateProperty
+  from(params: {
+    access?: 'public' | 'private' | 'protected' | undefined
+    comments?: K.CommentKind[] | null
+    computed?: boolean
+    key: K.PrivateNameKind
+    loc?: K.SourceLocationKind | null
+    static?: boolean
+    typeAnnotation?: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null
+    value?: K.ExpressionKind | null
+    variance?: K.VarianceKind | 'plus' | 'minus' | null
+  }): namedTypes.ClassPrivateProperty
 }
 export interface ImportAttributeBuilder {
-    (key: K.IdentifierKind | K.LiteralKind, value: K.ExpressionKind): namedTypes.ImportAttribute;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        key: K.IdentifierKind | K.LiteralKind;
-        loc?: K.SourceLocationKind | null;
-        value: K.ExpressionKind;
-    }): namedTypes.ImportAttribute;
+  (
+    key: K.IdentifierKind | K.LiteralKind,
+    value: K.ExpressionKind,
+  ): namedTypes.ImportAttribute
+  from(params: {
+    comments?: K.CommentKind[] | null
+    key: K.IdentifierKind | K.LiteralKind
+    loc?: K.SourceLocationKind | null
+    value: K.ExpressionKind
+  }): namedTypes.ImportAttribute
 }
 export interface RecordExpressionBuilder {
-    (properties: (K.ObjectPropertyKind | K.ObjectMethodKind | K.SpreadElementKind)[]): namedTypes.RecordExpression;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-        properties: (K.ObjectPropertyKind | K.ObjectMethodKind | K.SpreadElementKind)[];
-    }): namedTypes.RecordExpression;
+  (
+    properties: (
+      | K.ObjectPropertyKind
+      | K.ObjectMethodKind
+      | K.SpreadElementKind
+    )[],
+  ): namedTypes.RecordExpression
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+    properties: (
+      | K.ObjectPropertyKind
+      | K.ObjectMethodKind
+      | K.SpreadElementKind
+    )[]
+  }): namedTypes.RecordExpression
 }
 export interface ObjectMethodBuilder {
-    (kind: "method" | "get" | "set", key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind, params: K.PatternKind[], body: K.BlockStatementKind, computed?: boolean): namedTypes.ObjectMethod;
-    from(params: {
-        accessibility?: K.LiteralKind | null;
-        async?: boolean;
-        body: K.BlockStatementKind;
-        comments?: K.CommentKind[] | null;
-        computed?: boolean;
-        decorators?: K.DecoratorKind[] | null;
-        defaults?: (K.ExpressionKind | null)[];
-        expression?: boolean;
-        generator?: boolean;
-        id?: K.IdentifierKind | null;
-        key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind;
-        kind: "method" | "get" | "set";
-        loc?: K.SourceLocationKind | null;
-        params: K.PatternKind[];
-        predicate?: K.FlowPredicateKind | null;
-        rest?: K.IdentifierKind | null;
-        returnType?: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null;
-        typeParameters?: K.TypeParameterDeclarationKind | K.TSTypeParameterDeclarationKind | null;
-    }): namedTypes.ObjectMethod;
+  (
+    kind: 'method' | 'get' | 'set',
+    key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind,
+    params: K.PatternKind[],
+    body: K.BlockStatementKind,
+    computed?: boolean,
+  ): namedTypes.ObjectMethod
+  from(params: {
+    accessibility?: K.LiteralKind | null
+    async?: boolean
+    body: K.BlockStatementKind
+    comments?: K.CommentKind[] | null
+    computed?: boolean
+    decorators?: K.DecoratorKind[] | null
+    defaults?: (K.ExpressionKind | null)[]
+    expression?: boolean
+    generator?: boolean
+    id?: K.IdentifierKind | null
+    key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind
+    kind: 'method' | 'get' | 'set'
+    loc?: K.SourceLocationKind | null
+    params: K.PatternKind[]
+    predicate?: K.FlowPredicateKind | null
+    rest?: K.IdentifierKind | null
+    returnType?: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null
+    typeParameters?:
+      | K.TypeParameterDeclarationKind
+      | K.TSTypeParameterDeclarationKind
+      | null
+  }): namedTypes.ObjectMethod
 }
 export interface TupleExpressionBuilder {
-    (elements: (K.ExpressionKind | K.SpreadElementKind | null)[]): namedTypes.TupleExpression;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        elements: (K.ExpressionKind | K.SpreadElementKind | null)[];
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.TupleExpression;
+  (
+    elements: (K.ExpressionKind | K.SpreadElementKind | null)[],
+  ): namedTypes.TupleExpression
+  from(params: {
+    comments?: K.CommentKind[] | null
+    elements: (K.ExpressionKind | K.SpreadElementKind | null)[]
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.TupleExpression
 }
 export interface ModuleExpressionBuilder {
-    (body: K.ProgramKind): namedTypes.ModuleExpression;
-    from(params: {
-        body: K.ProgramKind;
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.ModuleExpression;
+  (body: K.ProgramKind): namedTypes.ModuleExpression
+  from(params: {
+    body: K.ProgramKind
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.ModuleExpression
 }
 export interface JSXAttributeBuilder {
-    (name: K.JSXIdentifierKind | K.JSXNamespacedNameKind, value?: K.LiteralKind | K.JSXExpressionContainerKind | K.JSXElementKind | K.JSXFragmentKind | null): namedTypes.JSXAttribute;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-        name: K.JSXIdentifierKind | K.JSXNamespacedNameKind;
-        value?: K.LiteralKind | K.JSXExpressionContainerKind | K.JSXElementKind | K.JSXFragmentKind | null;
-    }): namedTypes.JSXAttribute;
+  (
+    name: K.JSXIdentifierKind | K.JSXNamespacedNameKind,
+    value?:
+      | K.LiteralKind
+      | K.JSXExpressionContainerKind
+      | K.JSXElementKind
+      | K.JSXFragmentKind
+      | null,
+  ): namedTypes.JSXAttribute
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+    name: K.JSXIdentifierKind | K.JSXNamespacedNameKind
+    value?:
+      | K.LiteralKind
+      | K.JSXExpressionContainerKind
+      | K.JSXElementKind
+      | K.JSXFragmentKind
+      | null
+  }): namedTypes.JSXAttribute
 }
 export interface JSXIdentifierBuilder {
-    (name: string): namedTypes.JSXIdentifier;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-        name: string;
-        optional?: boolean;
-        typeAnnotation?: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null;
-    }): namedTypes.JSXIdentifier;
+  (name: string): namedTypes.JSXIdentifier
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+    name: string
+    optional?: boolean
+    typeAnnotation?: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null
+  }): namedTypes.JSXIdentifier
 }
 export interface JSXNamespacedNameBuilder {
-    (namespace: K.JSXIdentifierKind, name: K.JSXIdentifierKind): namedTypes.JSXNamespacedName;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-        name: K.JSXIdentifierKind;
-        namespace: K.JSXIdentifierKind;
-    }): namedTypes.JSXNamespacedName;
+  (
+    namespace: K.JSXIdentifierKind,
+    name: K.JSXIdentifierKind,
+  ): namedTypes.JSXNamespacedName
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+    name: K.JSXIdentifierKind
+    namespace: K.JSXIdentifierKind
+  }): namedTypes.JSXNamespacedName
 }
 export interface JSXExpressionContainerBuilder {
-    (expression: K.ExpressionKind | K.JSXEmptyExpressionKind): namedTypes.JSXExpressionContainer;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        expression: K.ExpressionKind | K.JSXEmptyExpressionKind;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.JSXExpressionContainer;
+  (
+    expression: K.ExpressionKind | K.JSXEmptyExpressionKind,
+  ): namedTypes.JSXExpressionContainer
+  from(params: {
+    comments?: K.CommentKind[] | null
+    expression: K.ExpressionKind | K.JSXEmptyExpressionKind
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.JSXExpressionContainer
 }
 export interface JSXElementBuilder {
-    (openingElement: K.JSXOpeningElementKind, closingElement?: K.JSXClosingElementKind | null, children?: (K.JSXTextKind | K.JSXExpressionContainerKind | K.JSXSpreadChildKind | K.JSXElementKind | K.JSXFragmentKind | K.LiteralKind)[]): namedTypes.JSXElement;
-    from(params: {
-        attributes?: (K.JSXAttributeKind | K.JSXSpreadAttributeKind)[];
-        children?: (K.JSXTextKind | K.JSXExpressionContainerKind | K.JSXSpreadChildKind | K.JSXElementKind | K.JSXFragmentKind | K.LiteralKind)[];
-        closingElement?: K.JSXClosingElementKind | null;
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-        name?: K.JSXIdentifierKind | K.JSXNamespacedNameKind | K.JSXMemberExpressionKind;
-        openingElement: K.JSXOpeningElementKind;
-        selfClosing?: boolean;
-    }): namedTypes.JSXElement;
+  (
+    openingElement: K.JSXOpeningElementKind,
+    closingElement?: K.JSXClosingElementKind | null,
+    children?: (
+      | K.JSXTextKind
+      | K.JSXExpressionContainerKind
+      | K.JSXSpreadChildKind
+      | K.JSXElementKind
+      | K.JSXFragmentKind
+      | K.LiteralKind
+    )[],
+  ): namedTypes.JSXElement
+  from(params: {
+    attributes?: (K.JSXAttributeKind | K.JSXSpreadAttributeKind)[]
+    children?: (
+      | K.JSXTextKind
+      | K.JSXExpressionContainerKind
+      | K.JSXSpreadChildKind
+      | K.JSXElementKind
+      | K.JSXFragmentKind
+      | K.LiteralKind
+    )[]
+    closingElement?: K.JSXClosingElementKind | null
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+    name?:
+      | K.JSXIdentifierKind
+      | K.JSXNamespacedNameKind
+      | K.JSXMemberExpressionKind
+    openingElement: K.JSXOpeningElementKind
+    selfClosing?: boolean
+  }): namedTypes.JSXElement
 }
 export interface JSXFragmentBuilder {
-    (openingFragment: K.JSXOpeningFragmentKind, closingFragment: K.JSXClosingFragmentKind, children?: (K.JSXTextKind | K.JSXExpressionContainerKind | K.JSXSpreadChildKind | K.JSXElementKind | K.JSXFragmentKind | K.LiteralKind)[]): namedTypes.JSXFragment;
-    from(params: {
-        children?: (K.JSXTextKind | K.JSXExpressionContainerKind | K.JSXSpreadChildKind | K.JSXElementKind | K.JSXFragmentKind | K.LiteralKind)[];
-        closingFragment: K.JSXClosingFragmentKind;
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-        openingFragment: K.JSXOpeningFragmentKind;
-    }): namedTypes.JSXFragment;
+  (
+    openingFragment: K.JSXOpeningFragmentKind,
+    closingFragment: K.JSXClosingFragmentKind,
+    children?: (
+      | K.JSXTextKind
+      | K.JSXExpressionContainerKind
+      | K.JSXSpreadChildKind
+      | K.JSXElementKind
+      | K.JSXFragmentKind
+      | K.LiteralKind
+    )[],
+  ): namedTypes.JSXFragment
+  from(params: {
+    children?: (
+      | K.JSXTextKind
+      | K.JSXExpressionContainerKind
+      | K.JSXSpreadChildKind
+      | K.JSXElementKind
+      | K.JSXFragmentKind
+      | K.LiteralKind
+    )[]
+    closingFragment: K.JSXClosingFragmentKind
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+    openingFragment: K.JSXOpeningFragmentKind
+  }): namedTypes.JSXFragment
 }
 export interface JSXMemberExpressionBuilder {
-    (object: K.JSXIdentifierKind | K.JSXMemberExpressionKind, property: K.JSXIdentifierKind): namedTypes.JSXMemberExpression;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        computed?: boolean;
-        loc?: K.SourceLocationKind | null;
-        object: K.JSXIdentifierKind | K.JSXMemberExpressionKind;
-        optional?: boolean;
-        property: K.JSXIdentifierKind;
-    }): namedTypes.JSXMemberExpression;
+  (
+    object: K.JSXIdentifierKind | K.JSXMemberExpressionKind,
+    property: K.JSXIdentifierKind,
+  ): namedTypes.JSXMemberExpression
+  from(params: {
+    comments?: K.CommentKind[] | null
+    computed?: boolean
+    loc?: K.SourceLocationKind | null
+    object: K.JSXIdentifierKind | K.JSXMemberExpressionKind
+    optional?: boolean
+    property: K.JSXIdentifierKind
+  }): namedTypes.JSXMemberExpression
 }
 export interface JSXSpreadAttributeBuilder {
-    (argument: K.ExpressionKind): namedTypes.JSXSpreadAttribute;
-    from(params: {
-        argument: K.ExpressionKind;
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.JSXSpreadAttribute;
+  (argument: K.ExpressionKind): namedTypes.JSXSpreadAttribute
+  from(params: {
+    argument: K.ExpressionKind
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.JSXSpreadAttribute
 }
 export interface JSXEmptyExpressionBuilder {
-    (): namedTypes.JSXEmptyExpression;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.JSXEmptyExpression;
+  (): namedTypes.JSXEmptyExpression
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.JSXEmptyExpression
 }
 export interface JSXTextBuilder {
-    (value: string, raw?: string): namedTypes.JSXText;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-        raw?: string;
-        value: string;
-    }): namedTypes.JSXText;
+  (value: string, raw?: string): namedTypes.JSXText
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+    raw?: string
+    value: string
+  }): namedTypes.JSXText
 }
 export interface JSXSpreadChildBuilder {
-    (expression: K.ExpressionKind): namedTypes.JSXSpreadChild;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        expression: K.ExpressionKind;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.JSXSpreadChild;
+  (expression: K.ExpressionKind): namedTypes.JSXSpreadChild
+  from(params: {
+    comments?: K.CommentKind[] | null
+    expression: K.ExpressionKind
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.JSXSpreadChild
 }
 export interface JSXOpeningElementBuilder {
-    (name: K.JSXIdentifierKind | K.JSXNamespacedNameKind | K.JSXMemberExpressionKind, attributes?: (K.JSXAttributeKind | K.JSXSpreadAttributeKind)[], selfClosing?: boolean): namedTypes.JSXOpeningElement;
-    from(params: {
-        attributes?: (K.JSXAttributeKind | K.JSXSpreadAttributeKind)[];
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-        name: K.JSXIdentifierKind | K.JSXNamespacedNameKind | K.JSXMemberExpressionKind;
-        selfClosing?: boolean;
-    }): namedTypes.JSXOpeningElement;
+  (
+    name:
+      | K.JSXIdentifierKind
+      | K.JSXNamespacedNameKind
+      | K.JSXMemberExpressionKind,
+    attributes?: (K.JSXAttributeKind | K.JSXSpreadAttributeKind)[],
+    selfClosing?: boolean,
+  ): namedTypes.JSXOpeningElement
+  from(params: {
+    attributes?: (K.JSXAttributeKind | K.JSXSpreadAttributeKind)[]
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+    name:
+      | K.JSXIdentifierKind
+      | K.JSXNamespacedNameKind
+      | K.JSXMemberExpressionKind
+    selfClosing?: boolean
+  }): namedTypes.JSXOpeningElement
 }
 export interface JSXClosingElementBuilder {
-    (name: K.JSXIdentifierKind | K.JSXNamespacedNameKind | K.JSXMemberExpressionKind): namedTypes.JSXClosingElement;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-        name: K.JSXIdentifierKind | K.JSXNamespacedNameKind | K.JSXMemberExpressionKind;
-    }): namedTypes.JSXClosingElement;
+  (
+    name:
+      | K.JSXIdentifierKind
+      | K.JSXNamespacedNameKind
+      | K.JSXMemberExpressionKind,
+  ): namedTypes.JSXClosingElement
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+    name:
+      | K.JSXIdentifierKind
+      | K.JSXNamespacedNameKind
+      | K.JSXMemberExpressionKind
+  }): namedTypes.JSXClosingElement
 }
 export interface JSXOpeningFragmentBuilder {
-    (): namedTypes.JSXOpeningFragment;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.JSXOpeningFragment;
+  (): namedTypes.JSXOpeningFragment
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.JSXOpeningFragment
 }
 export interface JSXClosingFragmentBuilder {
-    (): namedTypes.JSXClosingFragment;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.JSXClosingFragment;
+  (): namedTypes.JSXClosingFragment
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.JSXClosingFragment
 }
 export interface TypeParameterDeclarationBuilder {
-    (params: K.TypeParameterKind[]): namedTypes.TypeParameterDeclaration;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-        params: K.TypeParameterKind[];
-    }): namedTypes.TypeParameterDeclaration;
+  (params: K.TypeParameterKind[]): namedTypes.TypeParameterDeclaration
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+    params: K.TypeParameterKind[]
+  }): namedTypes.TypeParameterDeclaration
 }
 export interface TSTypeParameterDeclarationBuilder {
-    (params: K.TSTypeParameterKind[]): namedTypes.TSTypeParameterDeclaration;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-        params: K.TSTypeParameterKind[];
-    }): namedTypes.TSTypeParameterDeclaration;
+  (params: K.TSTypeParameterKind[]): namedTypes.TSTypeParameterDeclaration
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+    params: K.TSTypeParameterKind[]
+  }): namedTypes.TSTypeParameterDeclaration
 }
 export interface TypeParameterInstantiationBuilder {
-    (params: K.FlowTypeKind[]): namedTypes.TypeParameterInstantiation;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-        params: K.FlowTypeKind[];
-    }): namedTypes.TypeParameterInstantiation;
+  (params: K.FlowTypeKind[]): namedTypes.TypeParameterInstantiation
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+    params: K.FlowTypeKind[]
+  }): namedTypes.TypeParameterInstantiation
 }
 export interface TSTypeParameterInstantiationBuilder {
-    (params: K.TSTypeKind[]): namedTypes.TSTypeParameterInstantiation;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-        params: K.TSTypeKind[];
-    }): namedTypes.TSTypeParameterInstantiation;
+  (params: K.TSTypeKind[]): namedTypes.TSTypeParameterInstantiation
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+    params: K.TSTypeKind[]
+  }): namedTypes.TSTypeParameterInstantiation
 }
 export interface ClassImplementsBuilder {
-    (id: K.IdentifierKind): namedTypes.ClassImplements;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        id: K.IdentifierKind;
-        loc?: K.SourceLocationKind | null;
-        superClass?: K.ExpressionKind | null;
-        typeParameters?: K.TypeParameterInstantiationKind | null;
-    }): namedTypes.ClassImplements;
+  (id: K.IdentifierKind): namedTypes.ClassImplements
+  from(params: {
+    comments?: K.CommentKind[] | null
+    id: K.IdentifierKind
+    loc?: K.SourceLocationKind | null
+    superClass?: K.ExpressionKind | null
+    typeParameters?: K.TypeParameterInstantiationKind | null
+  }): namedTypes.ClassImplements
 }
 export interface TSExpressionWithTypeArgumentsBuilder {
-    (expression: K.IdentifierKind | K.TSQualifiedNameKind, typeParameters?: K.TSTypeParameterInstantiationKind | null): namedTypes.TSExpressionWithTypeArguments;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        expression: K.IdentifierKind | K.TSQualifiedNameKind;
-        loc?: K.SourceLocationKind | null;
-        typeParameters?: K.TSTypeParameterInstantiationKind | null;
-    }): namedTypes.TSExpressionWithTypeArguments;
+  (
+    expression: K.IdentifierKind | K.TSQualifiedNameKind,
+    typeParameters?: K.TSTypeParameterInstantiationKind | null,
+  ): namedTypes.TSExpressionWithTypeArguments
+  from(params: {
+    comments?: K.CommentKind[] | null
+    expression: K.IdentifierKind | K.TSQualifiedNameKind
+    loc?: K.SourceLocationKind | null
+    typeParameters?: K.TSTypeParameterInstantiationKind | null
+  }): namedTypes.TSExpressionWithTypeArguments
 }
 export interface AnyTypeAnnotationBuilder {
-    (): namedTypes.AnyTypeAnnotation;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.AnyTypeAnnotation;
+  (): namedTypes.AnyTypeAnnotation
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.AnyTypeAnnotation
 }
 export interface EmptyTypeAnnotationBuilder {
-    (): namedTypes.EmptyTypeAnnotation;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.EmptyTypeAnnotation;
+  (): namedTypes.EmptyTypeAnnotation
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.EmptyTypeAnnotation
 }
 export interface MixedTypeAnnotationBuilder {
-    (): namedTypes.MixedTypeAnnotation;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.MixedTypeAnnotation;
+  (): namedTypes.MixedTypeAnnotation
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.MixedTypeAnnotation
 }
 export interface VoidTypeAnnotationBuilder {
-    (): namedTypes.VoidTypeAnnotation;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.VoidTypeAnnotation;
+  (): namedTypes.VoidTypeAnnotation
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.VoidTypeAnnotation
 }
 export interface SymbolTypeAnnotationBuilder {
-    (): namedTypes.SymbolTypeAnnotation;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.SymbolTypeAnnotation;
+  (): namedTypes.SymbolTypeAnnotation
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.SymbolTypeAnnotation
 }
 export interface NumberTypeAnnotationBuilder {
-    (): namedTypes.NumberTypeAnnotation;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.NumberTypeAnnotation;
+  (): namedTypes.NumberTypeAnnotation
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.NumberTypeAnnotation
 }
 export interface BigIntTypeAnnotationBuilder {
-    (): namedTypes.BigIntTypeAnnotation;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.BigIntTypeAnnotation;
+  (): namedTypes.BigIntTypeAnnotation
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.BigIntTypeAnnotation
 }
 export interface NumberLiteralTypeAnnotationBuilder {
-    (value: number, raw: string): namedTypes.NumberLiteralTypeAnnotation;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-        raw: string;
-        value: number;
-    }): namedTypes.NumberLiteralTypeAnnotation;
+  (value: number, raw: string): namedTypes.NumberLiteralTypeAnnotation
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+    raw: string
+    value: number
+  }): namedTypes.NumberLiteralTypeAnnotation
 }
 export interface NumericLiteralTypeAnnotationBuilder {
-    (value: number, raw: string): namedTypes.NumericLiteralTypeAnnotation;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-        raw: string;
-        value: number;
-    }): namedTypes.NumericLiteralTypeAnnotation;
+  (value: number, raw: string): namedTypes.NumericLiteralTypeAnnotation
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+    raw: string
+    value: number
+  }): namedTypes.NumericLiteralTypeAnnotation
 }
 export interface BigIntLiteralTypeAnnotationBuilder {
-    (value: null, raw: string): namedTypes.BigIntLiteralTypeAnnotation;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-        raw: string;
-        value: null;
-    }): namedTypes.BigIntLiteralTypeAnnotation;
+  (value: null, raw: string): namedTypes.BigIntLiteralTypeAnnotation
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+    raw: string
+    value: null
+  }): namedTypes.BigIntLiteralTypeAnnotation
 }
 export interface StringTypeAnnotationBuilder {
-    (): namedTypes.StringTypeAnnotation;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.StringTypeAnnotation;
+  (): namedTypes.StringTypeAnnotation
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.StringTypeAnnotation
 }
 export interface StringLiteralTypeAnnotationBuilder {
-    (value: string, raw: string): namedTypes.StringLiteralTypeAnnotation;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-        raw: string;
-        value: string;
-    }): namedTypes.StringLiteralTypeAnnotation;
+  (value: string, raw: string): namedTypes.StringLiteralTypeAnnotation
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+    raw: string
+    value: string
+  }): namedTypes.StringLiteralTypeAnnotation
 }
 export interface BooleanTypeAnnotationBuilder {
-    (): namedTypes.BooleanTypeAnnotation;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.BooleanTypeAnnotation;
+  (): namedTypes.BooleanTypeAnnotation
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.BooleanTypeAnnotation
 }
 export interface BooleanLiteralTypeAnnotationBuilder {
-    (value: boolean, raw: string): namedTypes.BooleanLiteralTypeAnnotation;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-        raw: string;
-        value: boolean;
-    }): namedTypes.BooleanLiteralTypeAnnotation;
+  (value: boolean, raw: string): namedTypes.BooleanLiteralTypeAnnotation
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+    raw: string
+    value: boolean
+  }): namedTypes.BooleanLiteralTypeAnnotation
 }
 export interface NullableTypeAnnotationBuilder {
-    (typeAnnotation: K.FlowTypeKind): namedTypes.NullableTypeAnnotation;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-        typeAnnotation: K.FlowTypeKind;
-    }): namedTypes.NullableTypeAnnotation;
+  (typeAnnotation: K.FlowTypeKind): namedTypes.NullableTypeAnnotation
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+    typeAnnotation: K.FlowTypeKind
+  }): namedTypes.NullableTypeAnnotation
 }
 export interface NullLiteralTypeAnnotationBuilder {
-    (): namedTypes.NullLiteralTypeAnnotation;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.NullLiteralTypeAnnotation;
+  (): namedTypes.NullLiteralTypeAnnotation
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.NullLiteralTypeAnnotation
 }
 export interface NullTypeAnnotationBuilder {
-    (): namedTypes.NullTypeAnnotation;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.NullTypeAnnotation;
+  (): namedTypes.NullTypeAnnotation
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.NullTypeAnnotation
 }
 export interface ThisTypeAnnotationBuilder {
-    (): namedTypes.ThisTypeAnnotation;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.ThisTypeAnnotation;
+  (): namedTypes.ThisTypeAnnotation
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.ThisTypeAnnotation
 }
 export interface ExistsTypeAnnotationBuilder {
-    (): namedTypes.ExistsTypeAnnotation;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.ExistsTypeAnnotation;
+  (): namedTypes.ExistsTypeAnnotation
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.ExistsTypeAnnotation
 }
 export interface ExistentialTypeParamBuilder {
-    (): namedTypes.ExistentialTypeParam;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.ExistentialTypeParam;
+  (): namedTypes.ExistentialTypeParam
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.ExistentialTypeParam
 }
 export interface FunctionTypeAnnotationBuilder {
-    (params: K.FunctionTypeParamKind[], returnType: K.FlowTypeKind, rest: K.FunctionTypeParamKind | null, typeParameters: K.TypeParameterDeclarationKind | null): namedTypes.FunctionTypeAnnotation;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-        params: K.FunctionTypeParamKind[];
-        rest: K.FunctionTypeParamKind | null;
-        returnType: K.FlowTypeKind;
-        typeParameters: K.TypeParameterDeclarationKind | null;
-    }): namedTypes.FunctionTypeAnnotation;
+  (
+    params: K.FunctionTypeParamKind[],
+    returnType: K.FlowTypeKind,
+    rest: K.FunctionTypeParamKind | null,
+    typeParameters: K.TypeParameterDeclarationKind | null,
+  ): namedTypes.FunctionTypeAnnotation
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+    params: K.FunctionTypeParamKind[]
+    rest: K.FunctionTypeParamKind | null
+    returnType: K.FlowTypeKind
+    typeParameters: K.TypeParameterDeclarationKind | null
+  }): namedTypes.FunctionTypeAnnotation
 }
 export interface FunctionTypeParamBuilder {
-    (name: K.IdentifierKind | null, typeAnnotation: K.FlowTypeKind, optional: boolean): namedTypes.FunctionTypeParam;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-        name: K.IdentifierKind | null;
-        optional: boolean;
-        typeAnnotation: K.FlowTypeKind;
-    }): namedTypes.FunctionTypeParam;
+  (
+    name: K.IdentifierKind | null,
+    typeAnnotation: K.FlowTypeKind,
+    optional: boolean,
+  ): namedTypes.FunctionTypeParam
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+    name: K.IdentifierKind | null
+    optional: boolean
+    typeAnnotation: K.FlowTypeKind
+  }): namedTypes.FunctionTypeParam
 }
 export interface ArrayTypeAnnotationBuilder {
-    (elementType: K.FlowTypeKind): namedTypes.ArrayTypeAnnotation;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        elementType: K.FlowTypeKind;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.ArrayTypeAnnotation;
+  (elementType: K.FlowTypeKind): namedTypes.ArrayTypeAnnotation
+  from(params: {
+    comments?: K.CommentKind[] | null
+    elementType: K.FlowTypeKind
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.ArrayTypeAnnotation
 }
 export interface ObjectTypeAnnotationBuilder {
-    (properties: (K.ObjectTypePropertyKind | K.ObjectTypeSpreadPropertyKind)[], indexers?: K.ObjectTypeIndexerKind[], callProperties?: K.ObjectTypeCallPropertyKind[]): namedTypes.ObjectTypeAnnotation;
-    from(params: {
-        callProperties?: K.ObjectTypeCallPropertyKind[];
-        comments?: K.CommentKind[] | null;
-        exact?: boolean;
-        indexers?: K.ObjectTypeIndexerKind[];
-        inexact?: boolean | undefined;
-        internalSlots?: K.ObjectTypeInternalSlotKind[];
-        loc?: K.SourceLocationKind | null;
-        properties: (K.ObjectTypePropertyKind | K.ObjectTypeSpreadPropertyKind)[];
-    }): namedTypes.ObjectTypeAnnotation;
+  (
+    properties: (K.ObjectTypePropertyKind | K.ObjectTypeSpreadPropertyKind)[],
+    indexers?: K.ObjectTypeIndexerKind[],
+    callProperties?: K.ObjectTypeCallPropertyKind[],
+  ): namedTypes.ObjectTypeAnnotation
+  from(params: {
+    callProperties?: K.ObjectTypeCallPropertyKind[]
+    comments?: K.CommentKind[] | null
+    exact?: boolean
+    indexers?: K.ObjectTypeIndexerKind[]
+    inexact?: boolean | undefined
+    internalSlots?: K.ObjectTypeInternalSlotKind[]
+    loc?: K.SourceLocationKind | null
+    properties: (K.ObjectTypePropertyKind | K.ObjectTypeSpreadPropertyKind)[]
+  }): namedTypes.ObjectTypeAnnotation
 }
 export interface ObjectTypePropertyBuilder {
-    (key: K.LiteralKind | K.IdentifierKind, value: K.FlowTypeKind, optional: boolean): namedTypes.ObjectTypeProperty;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        key: K.LiteralKind | K.IdentifierKind;
-        loc?: K.SourceLocationKind | null;
-        optional: boolean;
-        value: K.FlowTypeKind;
-        variance?: K.VarianceKind | "plus" | "minus" | null;
-    }): namedTypes.ObjectTypeProperty;
+  (
+    key: K.LiteralKind | K.IdentifierKind,
+    value: K.FlowTypeKind,
+    optional: boolean,
+  ): namedTypes.ObjectTypeProperty
+  from(params: {
+    comments?: K.CommentKind[] | null
+    key: K.LiteralKind | K.IdentifierKind
+    loc?: K.SourceLocationKind | null
+    optional: boolean
+    value: K.FlowTypeKind
+    variance?: K.VarianceKind | 'plus' | 'minus' | null
+  }): namedTypes.ObjectTypeProperty
 }
 export interface ObjectTypeSpreadPropertyBuilder {
-    (argument: K.FlowTypeKind): namedTypes.ObjectTypeSpreadProperty;
-    from(params: {
-        argument: K.FlowTypeKind;
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.ObjectTypeSpreadProperty;
+  (argument: K.FlowTypeKind): namedTypes.ObjectTypeSpreadProperty
+  from(params: {
+    argument: K.FlowTypeKind
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.ObjectTypeSpreadProperty
 }
 export interface ObjectTypeIndexerBuilder {
-    (id: K.IdentifierKind, key: K.FlowTypeKind, value: K.FlowTypeKind): namedTypes.ObjectTypeIndexer;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        id: K.IdentifierKind;
-        key: K.FlowTypeKind;
-        loc?: K.SourceLocationKind | null;
-        static?: boolean;
-        value: K.FlowTypeKind;
-        variance?: K.VarianceKind | "plus" | "minus" | null;
-    }): namedTypes.ObjectTypeIndexer;
+  (
+    id: K.IdentifierKind,
+    key: K.FlowTypeKind,
+    value: K.FlowTypeKind,
+  ): namedTypes.ObjectTypeIndexer
+  from(params: {
+    comments?: K.CommentKind[] | null
+    id: K.IdentifierKind
+    key: K.FlowTypeKind
+    loc?: K.SourceLocationKind | null
+    static?: boolean
+    value: K.FlowTypeKind
+    variance?: K.VarianceKind | 'plus' | 'minus' | null
+  }): namedTypes.ObjectTypeIndexer
 }
 export interface ObjectTypeCallPropertyBuilder {
-    (value: K.FunctionTypeAnnotationKind): namedTypes.ObjectTypeCallProperty;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-        static?: boolean;
-        value: K.FunctionTypeAnnotationKind;
-    }): namedTypes.ObjectTypeCallProperty;
+  (value: K.FunctionTypeAnnotationKind): namedTypes.ObjectTypeCallProperty
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+    static?: boolean
+    value: K.FunctionTypeAnnotationKind
+  }): namedTypes.ObjectTypeCallProperty
 }
 export interface ObjectTypeInternalSlotBuilder {
-    (id: K.IdentifierKind, value: K.FlowTypeKind, optional: boolean, staticParam: boolean, method: boolean): namedTypes.ObjectTypeInternalSlot;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        id: K.IdentifierKind;
-        loc?: K.SourceLocationKind | null;
-        method: boolean;
-        optional: boolean;
-        static: boolean;
-        value: K.FlowTypeKind;
-    }): namedTypes.ObjectTypeInternalSlot;
+  (
+    id: K.IdentifierKind,
+    value: K.FlowTypeKind,
+    optional: boolean,
+    staticParam: boolean,
+    method: boolean,
+  ): namedTypes.ObjectTypeInternalSlot
+  from(params: {
+    comments?: K.CommentKind[] | null
+    id: K.IdentifierKind
+    loc?: K.SourceLocationKind | null
+    method: boolean
+    optional: boolean
+    static: boolean
+    value: K.FlowTypeKind
+  }): namedTypes.ObjectTypeInternalSlot
 }
 export interface VarianceBuilder {
-    (kind: "plus" | "minus"): namedTypes.Variance;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        kind: "plus" | "minus";
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.Variance;
+  (kind: 'plus' | 'minus'): namedTypes.Variance
+  from(params: {
+    comments?: K.CommentKind[] | null
+    kind: 'plus' | 'minus'
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.Variance
 }
 export interface QualifiedTypeIdentifierBuilder {
-    (qualification: K.IdentifierKind | K.QualifiedTypeIdentifierKind, id: K.IdentifierKind): namedTypes.QualifiedTypeIdentifier;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        id: K.IdentifierKind;
-        loc?: K.SourceLocationKind | null;
-        qualification: K.IdentifierKind | K.QualifiedTypeIdentifierKind;
-    }): namedTypes.QualifiedTypeIdentifier;
+  (
+    qualification: K.IdentifierKind | K.QualifiedTypeIdentifierKind,
+    id: K.IdentifierKind,
+  ): namedTypes.QualifiedTypeIdentifier
+  from(params: {
+    comments?: K.CommentKind[] | null
+    id: K.IdentifierKind
+    loc?: K.SourceLocationKind | null
+    qualification: K.IdentifierKind | K.QualifiedTypeIdentifierKind
+  }): namedTypes.QualifiedTypeIdentifier
 }
 export interface GenericTypeAnnotationBuilder {
-    (id: K.IdentifierKind | K.QualifiedTypeIdentifierKind, typeParameters: K.TypeParameterInstantiationKind | null): namedTypes.GenericTypeAnnotation;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        id: K.IdentifierKind | K.QualifiedTypeIdentifierKind;
-        loc?: K.SourceLocationKind | null;
-        typeParameters: K.TypeParameterInstantiationKind | null;
-    }): namedTypes.GenericTypeAnnotation;
+  (
+    id: K.IdentifierKind | K.QualifiedTypeIdentifierKind,
+    typeParameters: K.TypeParameterInstantiationKind | null,
+  ): namedTypes.GenericTypeAnnotation
+  from(params: {
+    comments?: K.CommentKind[] | null
+    id: K.IdentifierKind | K.QualifiedTypeIdentifierKind
+    loc?: K.SourceLocationKind | null
+    typeParameters: K.TypeParameterInstantiationKind | null
+  }): namedTypes.GenericTypeAnnotation
 }
 export interface MemberTypeAnnotationBuilder {
-    (object: K.IdentifierKind, property: K.MemberTypeAnnotationKind | K.GenericTypeAnnotationKind): namedTypes.MemberTypeAnnotation;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-        object: K.IdentifierKind;
-        property: K.MemberTypeAnnotationKind | K.GenericTypeAnnotationKind;
-    }): namedTypes.MemberTypeAnnotation;
+  (
+    object: K.IdentifierKind,
+    property: K.MemberTypeAnnotationKind | K.GenericTypeAnnotationKind,
+  ): namedTypes.MemberTypeAnnotation
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+    object: K.IdentifierKind
+    property: K.MemberTypeAnnotationKind | K.GenericTypeAnnotationKind
+  }): namedTypes.MemberTypeAnnotation
 }
 export interface IndexedAccessTypeBuilder {
-    (objectType: K.FlowTypeKind, indexType: K.FlowTypeKind): namedTypes.IndexedAccessType;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        indexType: K.FlowTypeKind;
-        loc?: K.SourceLocationKind | null;
-        objectType: K.FlowTypeKind;
-    }): namedTypes.IndexedAccessType;
+  (
+    objectType: K.FlowTypeKind,
+    indexType: K.FlowTypeKind,
+  ): namedTypes.IndexedAccessType
+  from(params: {
+    comments?: K.CommentKind[] | null
+    indexType: K.FlowTypeKind
+    loc?: K.SourceLocationKind | null
+    objectType: K.FlowTypeKind
+  }): namedTypes.IndexedAccessType
 }
 export interface OptionalIndexedAccessTypeBuilder {
-    (objectType: K.FlowTypeKind, indexType: K.FlowTypeKind, optional: boolean): namedTypes.OptionalIndexedAccessType;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        indexType: K.FlowTypeKind;
-        loc?: K.SourceLocationKind | null;
-        objectType: K.FlowTypeKind;
-        optional: boolean;
-    }): namedTypes.OptionalIndexedAccessType;
+  (
+    objectType: K.FlowTypeKind,
+    indexType: K.FlowTypeKind,
+    optional: boolean,
+  ): namedTypes.OptionalIndexedAccessType
+  from(params: {
+    comments?: K.CommentKind[] | null
+    indexType: K.FlowTypeKind
+    loc?: K.SourceLocationKind | null
+    objectType: K.FlowTypeKind
+    optional: boolean
+  }): namedTypes.OptionalIndexedAccessType
 }
 export interface UnionTypeAnnotationBuilder {
-    (types: K.FlowTypeKind[]): namedTypes.UnionTypeAnnotation;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-        types: K.FlowTypeKind[];
-    }): namedTypes.UnionTypeAnnotation;
+  (types: K.FlowTypeKind[]): namedTypes.UnionTypeAnnotation
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+    types: K.FlowTypeKind[]
+  }): namedTypes.UnionTypeAnnotation
 }
 export interface IntersectionTypeAnnotationBuilder {
-    (types: K.FlowTypeKind[]): namedTypes.IntersectionTypeAnnotation;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-        types: K.FlowTypeKind[];
-    }): namedTypes.IntersectionTypeAnnotation;
+  (types: K.FlowTypeKind[]): namedTypes.IntersectionTypeAnnotation
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+    types: K.FlowTypeKind[]
+  }): namedTypes.IntersectionTypeAnnotation
 }
 export interface TypeofTypeAnnotationBuilder {
-    (argument: K.FlowTypeKind): namedTypes.TypeofTypeAnnotation;
-    from(params: {
-        argument: K.FlowTypeKind;
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.TypeofTypeAnnotation;
+  (argument: K.FlowTypeKind): namedTypes.TypeofTypeAnnotation
+  from(params: {
+    argument: K.FlowTypeKind
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.TypeofTypeAnnotation
 }
 export interface TypeParameterBuilder {
-    (name: string, variance?: K.VarianceKind | "plus" | "minus" | null, bound?: K.TypeAnnotationKind | null, defaultParam?: K.FlowTypeKind | null): namedTypes.TypeParameter;
-    from(params: {
-        bound?: K.TypeAnnotationKind | null;
-        comments?: K.CommentKind[] | null;
-        default?: K.FlowTypeKind | null;
-        loc?: K.SourceLocationKind | null;
-        name: string;
-        variance?: K.VarianceKind | "plus" | "minus" | null;
-    }): namedTypes.TypeParameter;
+  (
+    name: string,
+    variance?: K.VarianceKind | 'plus' | 'minus' | null,
+    bound?: K.TypeAnnotationKind | null,
+    defaultParam?: K.FlowTypeKind | null,
+  ): namedTypes.TypeParameter
+  from(params: {
+    bound?: K.TypeAnnotationKind | null
+    comments?: K.CommentKind[] | null
+    default?: K.FlowTypeKind | null
+    loc?: K.SourceLocationKind | null
+    name: string
+    variance?: K.VarianceKind | 'plus' | 'minus' | null
+  }): namedTypes.TypeParameter
 }
 export interface InterfaceTypeAnnotationBuilder {
-    (body: K.ObjectTypeAnnotationKind, extendsParam?: K.InterfaceExtendsKind[] | null): namedTypes.InterfaceTypeAnnotation;
-    from(params: {
-        body: K.ObjectTypeAnnotationKind;
-        comments?: K.CommentKind[] | null;
-        extends?: K.InterfaceExtendsKind[] | null;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.InterfaceTypeAnnotation;
+  (
+    body: K.ObjectTypeAnnotationKind,
+    extendsParam?: K.InterfaceExtendsKind[] | null,
+  ): namedTypes.InterfaceTypeAnnotation
+  from(params: {
+    body: K.ObjectTypeAnnotationKind
+    comments?: K.CommentKind[] | null
+    extends?: K.InterfaceExtendsKind[] | null
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.InterfaceTypeAnnotation
 }
 export interface InterfaceExtendsBuilder {
-    (id: K.IdentifierKind): namedTypes.InterfaceExtends;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        id: K.IdentifierKind;
-        loc?: K.SourceLocationKind | null;
-        typeParameters?: K.TypeParameterInstantiationKind | null;
-    }): namedTypes.InterfaceExtends;
+  (id: K.IdentifierKind): namedTypes.InterfaceExtends
+  from(params: {
+    comments?: K.CommentKind[] | null
+    id: K.IdentifierKind
+    loc?: K.SourceLocationKind | null
+    typeParameters?: K.TypeParameterInstantiationKind | null
+  }): namedTypes.InterfaceExtends
 }
 export interface InterfaceDeclarationBuilder {
-    (id: K.IdentifierKind, body: K.ObjectTypeAnnotationKind, extendsParam: K.InterfaceExtendsKind[]): namedTypes.InterfaceDeclaration;
-    from(params: {
-        body: K.ObjectTypeAnnotationKind;
-        comments?: K.CommentKind[] | null;
-        extends: K.InterfaceExtendsKind[];
-        id: K.IdentifierKind;
-        loc?: K.SourceLocationKind | null;
-        typeParameters?: K.TypeParameterDeclarationKind | null;
-    }): namedTypes.InterfaceDeclaration;
+  (
+    id: K.IdentifierKind,
+    body: K.ObjectTypeAnnotationKind,
+    extendsParam: K.InterfaceExtendsKind[],
+  ): namedTypes.InterfaceDeclaration
+  from(params: {
+    body: K.ObjectTypeAnnotationKind
+    comments?: K.CommentKind[] | null
+    extends: K.InterfaceExtendsKind[]
+    id: K.IdentifierKind
+    loc?: K.SourceLocationKind | null
+    typeParameters?: K.TypeParameterDeclarationKind | null
+  }): namedTypes.InterfaceDeclaration
 }
 export interface DeclareInterfaceBuilder {
-    (id: K.IdentifierKind, body: K.ObjectTypeAnnotationKind, extendsParam: K.InterfaceExtendsKind[]): namedTypes.DeclareInterface;
-    from(params: {
-        body: K.ObjectTypeAnnotationKind;
-        comments?: K.CommentKind[] | null;
-        extends: K.InterfaceExtendsKind[];
-        id: K.IdentifierKind;
-        loc?: K.SourceLocationKind | null;
-        typeParameters?: K.TypeParameterDeclarationKind | null;
-    }): namedTypes.DeclareInterface;
+  (
+    id: K.IdentifierKind,
+    body: K.ObjectTypeAnnotationKind,
+    extendsParam: K.InterfaceExtendsKind[],
+  ): namedTypes.DeclareInterface
+  from(params: {
+    body: K.ObjectTypeAnnotationKind
+    comments?: K.CommentKind[] | null
+    extends: K.InterfaceExtendsKind[]
+    id: K.IdentifierKind
+    loc?: K.SourceLocationKind | null
+    typeParameters?: K.TypeParameterDeclarationKind | null
+  }): namedTypes.DeclareInterface
 }
 export interface TypeAliasBuilder {
-    (id: K.IdentifierKind, typeParameters: K.TypeParameterDeclarationKind | null, right: K.FlowTypeKind): namedTypes.TypeAlias;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        id: K.IdentifierKind;
-        loc?: K.SourceLocationKind | null;
-        right: K.FlowTypeKind;
-        typeParameters: K.TypeParameterDeclarationKind | null;
-    }): namedTypes.TypeAlias;
+  (
+    id: K.IdentifierKind,
+    typeParameters: K.TypeParameterDeclarationKind | null,
+    right: K.FlowTypeKind,
+  ): namedTypes.TypeAlias
+  from(params: {
+    comments?: K.CommentKind[] | null
+    id: K.IdentifierKind
+    loc?: K.SourceLocationKind | null
+    right: K.FlowTypeKind
+    typeParameters: K.TypeParameterDeclarationKind | null
+  }): namedTypes.TypeAlias
 }
 export interface DeclareTypeAliasBuilder {
-    (id: K.IdentifierKind, typeParameters: K.TypeParameterDeclarationKind | null, right: K.FlowTypeKind): namedTypes.DeclareTypeAlias;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        id: K.IdentifierKind;
-        loc?: K.SourceLocationKind | null;
-        right: K.FlowTypeKind;
-        typeParameters: K.TypeParameterDeclarationKind | null;
-    }): namedTypes.DeclareTypeAlias;
+  (
+    id: K.IdentifierKind,
+    typeParameters: K.TypeParameterDeclarationKind | null,
+    right: K.FlowTypeKind,
+  ): namedTypes.DeclareTypeAlias
+  from(params: {
+    comments?: K.CommentKind[] | null
+    id: K.IdentifierKind
+    loc?: K.SourceLocationKind | null
+    right: K.FlowTypeKind
+    typeParameters: K.TypeParameterDeclarationKind | null
+  }): namedTypes.DeclareTypeAlias
 }
 export interface OpaqueTypeBuilder {
-    (id: K.IdentifierKind, typeParameters: K.TypeParameterDeclarationKind | null, impltype: K.FlowTypeKind, supertype: K.FlowTypeKind | null): namedTypes.OpaqueType;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        id: K.IdentifierKind;
-        impltype: K.FlowTypeKind;
-        loc?: K.SourceLocationKind | null;
-        supertype: K.FlowTypeKind | null;
-        typeParameters: K.TypeParameterDeclarationKind | null;
-    }): namedTypes.OpaqueType;
+  (
+    id: K.IdentifierKind,
+    typeParameters: K.TypeParameterDeclarationKind | null,
+    impltype: K.FlowTypeKind,
+    supertype: K.FlowTypeKind | null,
+  ): namedTypes.OpaqueType
+  from(params: {
+    comments?: K.CommentKind[] | null
+    id: K.IdentifierKind
+    impltype: K.FlowTypeKind
+    loc?: K.SourceLocationKind | null
+    supertype: K.FlowTypeKind | null
+    typeParameters: K.TypeParameterDeclarationKind | null
+  }): namedTypes.OpaqueType
 }
 export interface DeclareOpaqueTypeBuilder {
-    (id: K.IdentifierKind, typeParameters: K.TypeParameterDeclarationKind | null, supertype: K.FlowTypeKind | null): namedTypes.DeclareOpaqueType;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        id: K.IdentifierKind;
-        impltype: K.FlowTypeKind | null;
-        loc?: K.SourceLocationKind | null;
-        supertype: K.FlowTypeKind | null;
-        typeParameters: K.TypeParameterDeclarationKind | null;
-    }): namedTypes.DeclareOpaqueType;
+  (
+    id: K.IdentifierKind,
+    typeParameters: K.TypeParameterDeclarationKind | null,
+    supertype: K.FlowTypeKind | null,
+  ): namedTypes.DeclareOpaqueType
+  from(params: {
+    comments?: K.CommentKind[] | null
+    id: K.IdentifierKind
+    impltype: K.FlowTypeKind | null
+    loc?: K.SourceLocationKind | null
+    supertype: K.FlowTypeKind | null
+    typeParameters: K.TypeParameterDeclarationKind | null
+  }): namedTypes.DeclareOpaqueType
 }
 export interface TypeCastExpressionBuilder {
-    (expression: K.ExpressionKind, typeAnnotation: K.TypeAnnotationKind): namedTypes.TypeCastExpression;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        expression: K.ExpressionKind;
-        loc?: K.SourceLocationKind | null;
-        typeAnnotation: K.TypeAnnotationKind;
-    }): namedTypes.TypeCastExpression;
+  (
+    expression: K.ExpressionKind,
+    typeAnnotation: K.TypeAnnotationKind,
+  ): namedTypes.TypeCastExpression
+  from(params: {
+    comments?: K.CommentKind[] | null
+    expression: K.ExpressionKind
+    loc?: K.SourceLocationKind | null
+    typeAnnotation: K.TypeAnnotationKind
+  }): namedTypes.TypeCastExpression
 }
 export interface TupleTypeAnnotationBuilder {
-    (types: K.FlowTypeKind[]): namedTypes.TupleTypeAnnotation;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-        types: K.FlowTypeKind[];
-    }): namedTypes.TupleTypeAnnotation;
+  (types: K.FlowTypeKind[]): namedTypes.TupleTypeAnnotation
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+    types: K.FlowTypeKind[]
+  }): namedTypes.TupleTypeAnnotation
 }
 export interface DeclareVariableBuilder {
-    (id: K.IdentifierKind): namedTypes.DeclareVariable;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        id: K.IdentifierKind;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.DeclareVariable;
+  (id: K.IdentifierKind): namedTypes.DeclareVariable
+  from(params: {
+    comments?: K.CommentKind[] | null
+    id: K.IdentifierKind
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.DeclareVariable
 }
 export interface DeclareFunctionBuilder {
-    (id: K.IdentifierKind): namedTypes.DeclareFunction;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        id: K.IdentifierKind;
-        loc?: K.SourceLocationKind | null;
-        predicate?: K.FlowPredicateKind | null;
-    }): namedTypes.DeclareFunction;
+  (id: K.IdentifierKind): namedTypes.DeclareFunction
+  from(params: {
+    comments?: K.CommentKind[] | null
+    id: K.IdentifierKind
+    loc?: K.SourceLocationKind | null
+    predicate?: K.FlowPredicateKind | null
+  }): namedTypes.DeclareFunction
 }
 export interface DeclareClassBuilder {
-    (id: K.IdentifierKind): namedTypes.DeclareClass;
-    from(params: {
-        body: K.ObjectTypeAnnotationKind;
-        comments?: K.CommentKind[] | null;
-        extends: K.InterfaceExtendsKind[];
-        id: K.IdentifierKind;
-        loc?: K.SourceLocationKind | null;
-        typeParameters?: K.TypeParameterDeclarationKind | null;
-    }): namedTypes.DeclareClass;
+  (id: K.IdentifierKind): namedTypes.DeclareClass
+  from(params: {
+    body: K.ObjectTypeAnnotationKind
+    comments?: K.CommentKind[] | null
+    extends: K.InterfaceExtendsKind[]
+    id: K.IdentifierKind
+    loc?: K.SourceLocationKind | null
+    typeParameters?: K.TypeParameterDeclarationKind | null
+  }): namedTypes.DeclareClass
 }
 export interface DeclareModuleBuilder {
-    (id: K.IdentifierKind | K.LiteralKind, body: K.BlockStatementKind): namedTypes.DeclareModule;
-    from(params: {
-        body: K.BlockStatementKind;
-        comments?: K.CommentKind[] | null;
-        id: K.IdentifierKind | K.LiteralKind;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.DeclareModule;
+  (
+    id: K.IdentifierKind | K.LiteralKind,
+    body: K.BlockStatementKind,
+  ): namedTypes.DeclareModule
+  from(params: {
+    body: K.BlockStatementKind
+    comments?: K.CommentKind[] | null
+    id: K.IdentifierKind | K.LiteralKind
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.DeclareModule
 }
 export interface DeclareModuleExportsBuilder {
-    (typeAnnotation: K.TypeAnnotationKind): namedTypes.DeclareModuleExports;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-        typeAnnotation: K.TypeAnnotationKind;
-    }): namedTypes.DeclareModuleExports;
+  (typeAnnotation: K.TypeAnnotationKind): namedTypes.DeclareModuleExports
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+    typeAnnotation: K.TypeAnnotationKind
+  }): namedTypes.DeclareModuleExports
 }
 export interface DeclareExportDeclarationBuilder {
-    (defaultParam: boolean, declaration: K.DeclareVariableKind | K.DeclareFunctionKind | K.DeclareClassKind | K.FlowTypeKind | K.TypeAliasKind | K.DeclareOpaqueTypeKind | K.InterfaceDeclarationKind | null, specifiers?: (K.ExportSpecifierKind | K.ExportBatchSpecifierKind)[], source?: K.LiteralKind | null): namedTypes.DeclareExportDeclaration;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        declaration: K.DeclareVariableKind | K.DeclareFunctionKind | K.DeclareClassKind | K.FlowTypeKind | K.TypeAliasKind | K.DeclareOpaqueTypeKind | K.InterfaceDeclarationKind | null;
-        default: boolean;
-        loc?: K.SourceLocationKind | null;
-        source?: K.LiteralKind | null;
-        specifiers?: (K.ExportSpecifierKind | K.ExportBatchSpecifierKind)[];
-    }): namedTypes.DeclareExportDeclaration;
+  (
+    defaultParam: boolean,
+    declaration:
+      | K.DeclareVariableKind
+      | K.DeclareFunctionKind
+      | K.DeclareClassKind
+      | K.FlowTypeKind
+      | K.TypeAliasKind
+      | K.DeclareOpaqueTypeKind
+      | K.InterfaceDeclarationKind
+      | null,
+    specifiers?: (K.ExportSpecifierKind | K.ExportBatchSpecifierKind)[],
+    source?: K.LiteralKind | null,
+  ): namedTypes.DeclareExportDeclaration
+  from(params: {
+    comments?: K.CommentKind[] | null
+    declaration:
+      | K.DeclareVariableKind
+      | K.DeclareFunctionKind
+      | K.DeclareClassKind
+      | K.FlowTypeKind
+      | K.TypeAliasKind
+      | K.DeclareOpaqueTypeKind
+      | K.InterfaceDeclarationKind
+      | null
+    default: boolean
+    loc?: K.SourceLocationKind | null
+    source?: K.LiteralKind | null
+    specifiers?: (K.ExportSpecifierKind | K.ExportBatchSpecifierKind)[]
+  }): namedTypes.DeclareExportDeclaration
 }
 export interface ExportBatchSpecifierBuilder {
-    (): namedTypes.ExportBatchSpecifier;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.ExportBatchSpecifier;
+  (): namedTypes.ExportBatchSpecifier
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.ExportBatchSpecifier
 }
 export interface DeclareExportAllDeclarationBuilder {
-    (source?: K.LiteralKind | null): namedTypes.DeclareExportAllDeclaration;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-        source?: K.LiteralKind | null;
-    }): namedTypes.DeclareExportAllDeclaration;
+  (source?: K.LiteralKind | null): namedTypes.DeclareExportAllDeclaration
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+    source?: K.LiteralKind | null
+  }): namedTypes.DeclareExportAllDeclaration
 }
 export interface InferredPredicateBuilder {
-    (): namedTypes.InferredPredicate;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.InferredPredicate;
+  (): namedTypes.InferredPredicate
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.InferredPredicate
 }
 export interface DeclaredPredicateBuilder {
-    (value: K.ExpressionKind): namedTypes.DeclaredPredicate;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-        value: K.ExpressionKind;
-    }): namedTypes.DeclaredPredicate;
+  (value: K.ExpressionKind): namedTypes.DeclaredPredicate
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+    value: K.ExpressionKind
+  }): namedTypes.DeclaredPredicate
 }
 export interface EnumDeclarationBuilder {
-    (id: K.IdentifierKind, body: K.EnumBooleanBodyKind | K.EnumNumberBodyKind | K.EnumStringBodyKind | K.EnumSymbolBodyKind): namedTypes.EnumDeclaration;
-    from(params: {
-        body: K.EnumBooleanBodyKind | K.EnumNumberBodyKind | K.EnumStringBodyKind | K.EnumSymbolBodyKind;
-        comments?: K.CommentKind[] | null;
-        id: K.IdentifierKind;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.EnumDeclaration;
+  (
+    id: K.IdentifierKind,
+    body:
+      | K.EnumBooleanBodyKind
+      | K.EnumNumberBodyKind
+      | K.EnumStringBodyKind
+      | K.EnumSymbolBodyKind,
+  ): namedTypes.EnumDeclaration
+  from(params: {
+    body:
+      | K.EnumBooleanBodyKind
+      | K.EnumNumberBodyKind
+      | K.EnumStringBodyKind
+      | K.EnumSymbolBodyKind
+    comments?: K.CommentKind[] | null
+    id: K.IdentifierKind
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.EnumDeclaration
 }
 export interface EnumBooleanBodyBuilder {
-    (members: K.EnumBooleanMemberKind[], explicitType: boolean): namedTypes.EnumBooleanBody;
-    from(params: {
-        explicitType: boolean;
-        members: K.EnumBooleanMemberKind[];
-    }): namedTypes.EnumBooleanBody;
+  (
+    members: K.EnumBooleanMemberKind[],
+    explicitType: boolean,
+  ): namedTypes.EnumBooleanBody
+  from(params: {
+    explicitType: boolean
+    members: K.EnumBooleanMemberKind[]
+  }): namedTypes.EnumBooleanBody
 }
 export interface EnumNumberBodyBuilder {
-    (members: K.EnumNumberMemberKind[], explicitType: boolean): namedTypes.EnumNumberBody;
-    from(params: {
-        explicitType: boolean;
-        members: K.EnumNumberMemberKind[];
-    }): namedTypes.EnumNumberBody;
+  (
+    members: K.EnumNumberMemberKind[],
+    explicitType: boolean,
+  ): namedTypes.EnumNumberBody
+  from(params: {
+    explicitType: boolean
+    members: K.EnumNumberMemberKind[]
+  }): namedTypes.EnumNumberBody
 }
 export interface EnumStringBodyBuilder {
-    (members: K.EnumStringMemberKind[] | K.EnumDefaultedMemberKind[], explicitType: boolean): namedTypes.EnumStringBody;
-    from(params: {
-        explicitType: boolean;
-        members: K.EnumStringMemberKind[] | K.EnumDefaultedMemberKind[];
-    }): namedTypes.EnumStringBody;
+  (
+    members: K.EnumStringMemberKind[] | K.EnumDefaultedMemberKind[],
+    explicitType: boolean,
+  ): namedTypes.EnumStringBody
+  from(params: {
+    explicitType: boolean
+    members: K.EnumStringMemberKind[] | K.EnumDefaultedMemberKind[]
+  }): namedTypes.EnumStringBody
 }
 export interface EnumSymbolBodyBuilder {
-    (members: K.EnumDefaultedMemberKind[]): namedTypes.EnumSymbolBody;
-    from(params: {
-        members: K.EnumDefaultedMemberKind[];
-    }): namedTypes.EnumSymbolBody;
+  (members: K.EnumDefaultedMemberKind[]): namedTypes.EnumSymbolBody
+  from(params: {
+    members: K.EnumDefaultedMemberKind[]
+  }): namedTypes.EnumSymbolBody
 }
 export interface EnumBooleanMemberBuilder {
-    (id: K.IdentifierKind, init: K.LiteralKind | boolean): namedTypes.EnumBooleanMember;
-    from(params: {
-        id: K.IdentifierKind;
-        init: K.LiteralKind | boolean;
-    }): namedTypes.EnumBooleanMember;
+  (
+    id: K.IdentifierKind,
+    init: K.LiteralKind | boolean,
+  ): namedTypes.EnumBooleanMember
+  from(params: {
+    id: K.IdentifierKind
+    init: K.LiteralKind | boolean
+  }): namedTypes.EnumBooleanMember
 }
 export interface EnumNumberMemberBuilder {
-    (id: K.IdentifierKind, init: K.LiteralKind): namedTypes.EnumNumberMember;
-    from(params: {
-        id: K.IdentifierKind;
-        init: K.LiteralKind;
-    }): namedTypes.EnumNumberMember;
+  (id: K.IdentifierKind, init: K.LiteralKind): namedTypes.EnumNumberMember
+  from(params: {
+    id: K.IdentifierKind
+    init: K.LiteralKind
+  }): namedTypes.EnumNumberMember
 }
 export interface EnumStringMemberBuilder {
-    (id: K.IdentifierKind, init: K.LiteralKind): namedTypes.EnumStringMember;
-    from(params: {
-        id: K.IdentifierKind;
-        init: K.LiteralKind;
-    }): namedTypes.EnumStringMember;
+  (id: K.IdentifierKind, init: K.LiteralKind): namedTypes.EnumStringMember
+  from(params: {
+    id: K.IdentifierKind
+    init: K.LiteralKind
+  }): namedTypes.EnumStringMember
 }
 export interface EnumDefaultedMemberBuilder {
-    (id: K.IdentifierKind): namedTypes.EnumDefaultedMember;
-    from(params: {
-        id: K.IdentifierKind;
-    }): namedTypes.EnumDefaultedMember;
+  (id: K.IdentifierKind): namedTypes.EnumDefaultedMember
+  from(params: { id: K.IdentifierKind }): namedTypes.EnumDefaultedMember
 }
 export interface ExportDeclarationBuilder {
-    (defaultParam: boolean, declaration: K.DeclarationKind | K.ExpressionKind | null, specifiers?: (K.ExportSpecifierKind | K.ExportBatchSpecifierKind)[], source?: K.LiteralKind | null): namedTypes.ExportDeclaration;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        declaration: K.DeclarationKind | K.ExpressionKind | null;
-        default: boolean;
-        loc?: K.SourceLocationKind | null;
-        source?: K.LiteralKind | null;
-        specifiers?: (K.ExportSpecifierKind | K.ExportBatchSpecifierKind)[];
-    }): namedTypes.ExportDeclaration;
+  (
+    defaultParam: boolean,
+    declaration: K.DeclarationKind | K.ExpressionKind | null,
+    specifiers?: (K.ExportSpecifierKind | K.ExportBatchSpecifierKind)[],
+    source?: K.LiteralKind | null,
+  ): namedTypes.ExportDeclaration
+  from(params: {
+    comments?: K.CommentKind[] | null
+    declaration: K.DeclarationKind | K.ExpressionKind | null
+    default: boolean
+    loc?: K.SourceLocationKind | null
+    source?: K.LiteralKind | null
+    specifiers?: (K.ExportSpecifierKind | K.ExportBatchSpecifierKind)[]
+  }): namedTypes.ExportDeclaration
 }
 export interface BlockBuilder {
-    (value: string, leading?: boolean, trailing?: boolean): namedTypes.Block;
-    from(params: {
-        leading?: boolean;
-        loc?: K.SourceLocationKind | null;
-        trailing?: boolean;
-        value: string;
-    }): namedTypes.Block;
+  (value: string, leading?: boolean, trailing?: boolean): namedTypes.Block
+  from(params: {
+    leading?: boolean
+    loc?: K.SourceLocationKind | null
+    trailing?: boolean
+    value: string
+  }): namedTypes.Block
 }
 export interface LineBuilder {
-    (value: string, leading?: boolean, trailing?: boolean): namedTypes.Line;
-    from(params: {
-        leading?: boolean;
-        loc?: K.SourceLocationKind | null;
-        trailing?: boolean;
-        value: string;
-    }): namedTypes.Line;
+  (value: string, leading?: boolean, trailing?: boolean): namedTypes.Line
+  from(params: {
+    leading?: boolean
+    loc?: K.SourceLocationKind | null
+    trailing?: boolean
+    value: string
+  }): namedTypes.Line
 }
 export interface NoopBuilder {
-    (): namedTypes.Noop;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.Noop;
+  (): namedTypes.Noop
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.Noop
 }
 export interface DoExpressionBuilder {
-    (body: K.StatementKind[]): namedTypes.DoExpression;
-    from(params: {
-        body: K.StatementKind[];
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.DoExpression;
+  (body: K.StatementKind[]): namedTypes.DoExpression
+  from(params: {
+    body: K.StatementKind[]
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.DoExpression
 }
 export interface BindExpressionBuilder {
-    (object: K.ExpressionKind | null, callee: K.ExpressionKind): namedTypes.BindExpression;
-    from(params: {
-        callee: K.ExpressionKind;
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-        object: K.ExpressionKind | null;
-    }): namedTypes.BindExpression;
+  (
+    object: K.ExpressionKind | null,
+    callee: K.ExpressionKind,
+  ): namedTypes.BindExpression
+  from(params: {
+    callee: K.ExpressionKind
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+    object: K.ExpressionKind | null
+  }): namedTypes.BindExpression
 }
 export interface ParenthesizedExpressionBuilder {
-    (expression: K.ExpressionKind): namedTypes.ParenthesizedExpression;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        expression: K.ExpressionKind;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.ParenthesizedExpression;
+  (expression: K.ExpressionKind): namedTypes.ParenthesizedExpression
+  from(params: {
+    comments?: K.CommentKind[] | null
+    expression: K.ExpressionKind
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.ParenthesizedExpression
 }
 export interface ExportNamespaceSpecifierBuilder {
-    (exported: K.IdentifierKind): namedTypes.ExportNamespaceSpecifier;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        exported: K.IdentifierKind;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.ExportNamespaceSpecifier;
+  (exported: K.IdentifierKind): namedTypes.ExportNamespaceSpecifier
+  from(params: {
+    comments?: K.CommentKind[] | null
+    exported: K.IdentifierKind
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.ExportNamespaceSpecifier
 }
 export interface ExportDefaultSpecifierBuilder {
-    (exported: K.IdentifierKind): namedTypes.ExportDefaultSpecifier;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        exported: K.IdentifierKind;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.ExportDefaultSpecifier;
+  (exported: K.IdentifierKind): namedTypes.ExportDefaultSpecifier
+  from(params: {
+    comments?: K.CommentKind[] | null
+    exported: K.IdentifierKind
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.ExportDefaultSpecifier
 }
 export interface CommentBlockBuilder {
-    (value: string, leading?: boolean, trailing?: boolean): namedTypes.CommentBlock;
-    from(params: {
-        leading?: boolean;
-        loc?: K.SourceLocationKind | null;
-        trailing?: boolean;
-        value: string;
-    }): namedTypes.CommentBlock;
+  (
+    value: string,
+    leading?: boolean,
+    trailing?: boolean,
+  ): namedTypes.CommentBlock
+  from(params: {
+    leading?: boolean
+    loc?: K.SourceLocationKind | null
+    trailing?: boolean
+    value: string
+  }): namedTypes.CommentBlock
 }
 export interface CommentLineBuilder {
-    (value: string, leading?: boolean, trailing?: boolean): namedTypes.CommentLine;
-    from(params: {
-        leading?: boolean;
-        loc?: K.SourceLocationKind | null;
-        trailing?: boolean;
-        value: string;
-    }): namedTypes.CommentLine;
+  (value: string, leading?: boolean, trailing?: boolean): namedTypes.CommentLine
+  from(params: {
+    leading?: boolean
+    loc?: K.SourceLocationKind | null
+    trailing?: boolean
+    value: string
+  }): namedTypes.CommentLine
 }
 export interface DirectiveBuilder {
-    (value: K.DirectiveLiteralKind): namedTypes.Directive;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-        value: K.DirectiveLiteralKind;
-    }): namedTypes.Directive;
+  (value: K.DirectiveLiteralKind): namedTypes.Directive
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+    value: K.DirectiveLiteralKind
+  }): namedTypes.Directive
 }
 export interface DirectiveLiteralBuilder {
-    (value?: string): namedTypes.DirectiveLiteral;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-        value?: string;
-    }): namedTypes.DirectiveLiteral;
+  (value?: string): namedTypes.DirectiveLiteral
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+    value?: string
+  }): namedTypes.DirectiveLiteral
 }
 export interface InterpreterDirectiveBuilder {
-    (value: string): namedTypes.InterpreterDirective;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-        value: string;
-    }): namedTypes.InterpreterDirective;
+  (value: string): namedTypes.InterpreterDirective
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+    value: string
+  }): namedTypes.InterpreterDirective
 }
 export interface StringLiteralBuilder {
-    (value: string): namedTypes.StringLiteral;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        extra?: {
-            rawValue: string;
-            raw: string;
-        };
-        loc?: K.SourceLocationKind | null;
-        value: string;
-    }): namedTypes.StringLiteral;
+  (value: string): namedTypes.StringLiteral
+  from(params: {
+    comments?: K.CommentKind[] | null
+    extra?: {
+      rawValue: string
+      raw: string
+    }
+    loc?: K.SourceLocationKind | null
+    value: string
+  }): namedTypes.StringLiteral
 }
 export interface NumericLiteralBuilder {
-    (value: number): namedTypes.NumericLiteral;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        extra?: {
-            rawValue: number;
-            raw: string;
-        };
-        loc?: K.SourceLocationKind | null;
-        raw?: string | null;
-        value: number;
-    }): namedTypes.NumericLiteral;
+  (value: number): namedTypes.NumericLiteral
+  from(params: {
+    comments?: K.CommentKind[] | null
+    extra?: {
+      rawValue: number
+      raw: string
+    }
+    loc?: K.SourceLocationKind | null
+    raw?: string | null
+    value: number
+  }): namedTypes.NumericLiteral
 }
 export interface BigIntLiteralBuilder {
-    (value: string | number): namedTypes.BigIntLiteral;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        extra?: {
-            rawValue: string;
-            raw: string;
-        };
-        loc?: K.SourceLocationKind | null;
-        value: string | number;
-    }): namedTypes.BigIntLiteral;
+  (value: string | number): namedTypes.BigIntLiteral
+  from(params: {
+    comments?: K.CommentKind[] | null
+    extra?: {
+      rawValue: string
+      raw: string
+    }
+    loc?: K.SourceLocationKind | null
+    value: string | number
+  }): namedTypes.BigIntLiteral
 }
 export interface DecimalLiteralBuilder {
-    (value: string): namedTypes.DecimalLiteral;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        extra?: {
-            rawValue: string;
-            raw: string;
-        };
-        loc?: K.SourceLocationKind | null;
-        value: string;
-    }): namedTypes.DecimalLiteral;
+  (value: string): namedTypes.DecimalLiteral
+  from(params: {
+    comments?: K.CommentKind[] | null
+    extra?: {
+      rawValue: string
+      raw: string
+    }
+    loc?: K.SourceLocationKind | null
+    value: string
+  }): namedTypes.DecimalLiteral
 }
 export interface NullLiteralBuilder {
-    (): namedTypes.NullLiteral;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-        value?: null;
-    }): namedTypes.NullLiteral;
+  (): namedTypes.NullLiteral
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+    value?: null
+  }): namedTypes.NullLiteral
 }
 export interface BooleanLiteralBuilder {
-    (value: boolean): namedTypes.BooleanLiteral;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-        value: boolean;
-    }): namedTypes.BooleanLiteral;
+  (value: boolean): namedTypes.BooleanLiteral
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+    value: boolean
+  }): namedTypes.BooleanLiteral
 }
 export interface RegExpLiteralBuilder {
-    (pattern: string, flags: string): namedTypes.RegExpLiteral;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        extra?: {
-            rawValue: RegExp | undefined;
-            raw: string;
-        };
-        flags: string;
-        loc?: K.SourceLocationKind | null;
-        pattern: string;
-        regex?: {
-            pattern: string;
-            flags: string;
-        };
-        value?: RegExp;
-    }): namedTypes.RegExpLiteral;
+  (pattern: string, flags: string): namedTypes.RegExpLiteral
+  from(params: {
+    comments?: K.CommentKind[] | null
+    extra?: {
+      rawValue: RegExp | undefined
+      raw: string
+    }
+    flags: string
+    loc?: K.SourceLocationKind | null
+    pattern: string
+    regex?: {
+      pattern: string
+      flags: string
+    }
+    value?: RegExp
+  }): namedTypes.RegExpLiteral
 }
 export interface ClassMethodBuilder {
-    (kind: "get" | "set" | "method" | "constructor" | undefined, key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind, params: K.PatternKind[], body: K.BlockStatementKind, computed?: boolean, staticParam?: boolean): namedTypes.ClassMethod;
-    from(params: {
-        abstract?: boolean;
-        access?: "public" | "private" | "protected" | null;
-        accessibility?: "public" | "private" | "protected" | null;
-        async?: boolean;
-        body: K.BlockStatementKind;
-        comments?: K.CommentKind[] | null;
-        computed?: boolean;
-        decorators?: K.DecoratorKind[] | null;
-        defaults?: (K.ExpressionKind | null)[];
-        definite?: boolean;
-        expression?: boolean;
-        generator?: boolean;
-        id?: K.IdentifierKind | null;
-        key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind;
-        kind?: "get" | "set" | "method" | "constructor";
-        loc?: K.SourceLocationKind | null;
-        optional?: boolean;
-        override?: boolean;
-        params: K.PatternKind[];
-        predicate?: K.FlowPredicateKind | null;
-        readonly?: boolean;
-        rest?: K.IdentifierKind | null;
-        returnType?: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null;
-        static?: boolean;
-        typeParameters?: K.TypeParameterDeclarationKind | K.TSTypeParameterDeclarationKind | null;
-    }): namedTypes.ClassMethod;
+  (
+    kind: 'get' | 'set' | 'method' | 'constructor' | undefined,
+    key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind,
+    params: K.PatternKind[],
+    body: K.BlockStatementKind,
+    computed?: boolean,
+    staticParam?: boolean,
+  ): namedTypes.ClassMethod
+  from(params: {
+    abstract?: boolean
+    access?: 'public' | 'private' | 'protected' | null
+    accessibility?: 'public' | 'private' | 'protected' | null
+    async?: boolean
+    body: K.BlockStatementKind
+    comments?: K.CommentKind[] | null
+    computed?: boolean
+    decorators?: K.DecoratorKind[] | null
+    defaults?: (K.ExpressionKind | null)[]
+    definite?: boolean
+    expression?: boolean
+    generator?: boolean
+    id?: K.IdentifierKind | null
+    key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind
+    kind?: 'get' | 'set' | 'method' | 'constructor'
+    loc?: K.SourceLocationKind | null
+    optional?: boolean
+    override?: boolean
+    params: K.PatternKind[]
+    predicate?: K.FlowPredicateKind | null
+    readonly?: boolean
+    rest?: K.IdentifierKind | null
+    returnType?: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null
+    static?: boolean
+    typeParameters?:
+      | K.TypeParameterDeclarationKind
+      | K.TSTypeParameterDeclarationKind
+      | null
+  }): namedTypes.ClassMethod
 }
 export interface ClassPrivateMethodBuilder {
-    (key: K.PrivateNameKind, params: K.PatternKind[], body: K.BlockStatementKind, kind?: "get" | "set" | "method" | "constructor", computed?: boolean, staticParam?: boolean): namedTypes.ClassPrivateMethod;
-    from(params: {
-        abstract?: boolean;
-        access?: "public" | "private" | "protected" | null;
-        accessibility?: "public" | "private" | "protected" | null;
-        async?: boolean;
-        body: K.BlockStatementKind;
-        comments?: K.CommentKind[] | null;
-        computed?: boolean;
-        decorators?: K.DecoratorKind[] | null;
-        defaults?: (K.ExpressionKind | null)[];
-        definite?: boolean;
-        expression?: boolean;
-        generator?: boolean;
-        id?: K.IdentifierKind | null;
-        key: K.PrivateNameKind;
-        kind?: "get" | "set" | "method" | "constructor";
-        loc?: K.SourceLocationKind | null;
-        optional?: boolean;
-        override?: boolean;
-        params: K.PatternKind[];
-        predicate?: K.FlowPredicateKind | null;
-        readonly?: boolean;
-        rest?: K.IdentifierKind | null;
-        returnType?: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null;
-        static?: boolean;
-        typeParameters?: K.TypeParameterDeclarationKind | K.TSTypeParameterDeclarationKind | null;
-    }): namedTypes.ClassPrivateMethod;
+  (
+    key: K.PrivateNameKind,
+    params: K.PatternKind[],
+    body: K.BlockStatementKind,
+    kind?: 'get' | 'set' | 'method' | 'constructor',
+    computed?: boolean,
+    staticParam?: boolean,
+  ): namedTypes.ClassPrivateMethod
+  from(params: {
+    abstract?: boolean
+    access?: 'public' | 'private' | 'protected' | null
+    accessibility?: 'public' | 'private' | 'protected' | null
+    async?: boolean
+    body: K.BlockStatementKind
+    comments?: K.CommentKind[] | null
+    computed?: boolean
+    decorators?: K.DecoratorKind[] | null
+    defaults?: (K.ExpressionKind | null)[]
+    definite?: boolean
+    expression?: boolean
+    generator?: boolean
+    id?: K.IdentifierKind | null
+    key: K.PrivateNameKind
+    kind?: 'get' | 'set' | 'method' | 'constructor'
+    loc?: K.SourceLocationKind | null
+    optional?: boolean
+    override?: boolean
+    params: K.PatternKind[]
+    predicate?: K.FlowPredicateKind | null
+    readonly?: boolean
+    rest?: K.IdentifierKind | null
+    returnType?: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null
+    static?: boolean
+    typeParameters?:
+      | K.TypeParameterDeclarationKind
+      | K.TSTypeParameterDeclarationKind
+      | null
+  }): namedTypes.ClassPrivateMethod
 }
 export interface ClassAccessorPropertyBuilder {
-    (key: K.LiteralKind | K.IdentifierKind | K.PrivateNameKind | K.ExpressionKind, value?: K.ExpressionKind | null, decorators?: K.DecoratorKind[] | null, computed?: boolean, staticParam?: boolean): namedTypes.ClassAccessorProperty;
-    from(params: {
-        abstract?: boolean;
-        accessibility?: "public" | "private" | "protected" | null;
-        comments?: K.CommentKind[] | null;
-        computed?: boolean;
-        decorators?: K.DecoratorKind[] | null;
-        definite?: boolean;
-        key: K.LiteralKind | K.IdentifierKind | K.PrivateNameKind | K.ExpressionKind;
-        loc?: K.SourceLocationKind | null;
-        optional?: boolean;
-        override?: boolean;
-        readonly?: boolean;
-        static?: boolean;
-        typeAnnotation?: K.TSTypeAnnotationKind | null;
-        value?: K.ExpressionKind | null;
-    }): namedTypes.ClassAccessorProperty;
+  (
+    key:
+      | K.LiteralKind
+      | K.IdentifierKind
+      | K.PrivateNameKind
+      | K.ExpressionKind,
+    value?: K.ExpressionKind | null,
+    decorators?: K.DecoratorKind[] | null,
+    computed?: boolean,
+    staticParam?: boolean,
+  ): namedTypes.ClassAccessorProperty
+  from(params: {
+    abstract?: boolean
+    accessibility?: 'public' | 'private' | 'protected' | null
+    comments?: K.CommentKind[] | null
+    computed?: boolean
+    decorators?: K.DecoratorKind[] | null
+    definite?: boolean
+    key: K.LiteralKind | K.IdentifierKind | K.PrivateNameKind | K.ExpressionKind
+    loc?: K.SourceLocationKind | null
+    optional?: boolean
+    override?: boolean
+    readonly?: boolean
+    static?: boolean
+    typeAnnotation?: K.TSTypeAnnotationKind | null
+    value?: K.ExpressionKind | null
+  }): namedTypes.ClassAccessorProperty
 }
 export interface RestPropertyBuilder {
-    (argument: K.ExpressionKind): namedTypes.RestProperty;
-    from(params: {
-        argument: K.ExpressionKind;
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.RestProperty;
+  (argument: K.ExpressionKind): namedTypes.RestProperty
+  from(params: {
+    argument: K.ExpressionKind
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.RestProperty
 }
 export interface ForAwaitStatementBuilder {
-    (left: K.VariableDeclarationKind | K.ExpressionKind, right: K.ExpressionKind, body: K.StatementKind): namedTypes.ForAwaitStatement;
-    from(params: {
-        body: K.StatementKind;
-        comments?: K.CommentKind[] | null;
-        left: K.VariableDeclarationKind | K.ExpressionKind;
-        loc?: K.SourceLocationKind | null;
-        right: K.ExpressionKind;
-    }): namedTypes.ForAwaitStatement;
+  (
+    left: K.VariableDeclarationKind | K.ExpressionKind,
+    right: K.ExpressionKind,
+    body: K.StatementKind,
+  ): namedTypes.ForAwaitStatement
+  from(params: {
+    body: K.StatementKind
+    comments?: K.CommentKind[] | null
+    left: K.VariableDeclarationKind | K.ExpressionKind
+    loc?: K.SourceLocationKind | null
+    right: K.ExpressionKind
+  }): namedTypes.ForAwaitStatement
 }
 export interface ImportBuilder {
-    (): namedTypes.Import;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.Import;
+  (): namedTypes.Import
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.Import
 }
 export interface V8IntrinsicIdentifierBuilder {
-    (name: string): namedTypes.V8IntrinsicIdentifier;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-        name: string;
-    }): namedTypes.V8IntrinsicIdentifier;
+  (name: string): namedTypes.V8IntrinsicIdentifier
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+    name: string
+  }): namedTypes.V8IntrinsicIdentifier
 }
 export interface TopicReferenceBuilder {
-    (): namedTypes.TopicReference;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.TopicReference;
+  (): namedTypes.TopicReference
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.TopicReference
 }
 export interface TSQualifiedNameBuilder {
-    (left: K.IdentifierKind | K.TSQualifiedNameKind, right: K.IdentifierKind | K.TSQualifiedNameKind): namedTypes.TSQualifiedName;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        left: K.IdentifierKind | K.TSQualifiedNameKind;
-        loc?: K.SourceLocationKind | null;
-        right: K.IdentifierKind | K.TSQualifiedNameKind;
-    }): namedTypes.TSQualifiedName;
+  (
+    left: K.IdentifierKind | K.TSQualifiedNameKind,
+    right: K.IdentifierKind | K.TSQualifiedNameKind,
+  ): namedTypes.TSQualifiedName
+  from(params: {
+    comments?: K.CommentKind[] | null
+    left: K.IdentifierKind | K.TSQualifiedNameKind
+    loc?: K.SourceLocationKind | null
+    right: K.IdentifierKind | K.TSQualifiedNameKind
+  }): namedTypes.TSQualifiedName
 }
 export interface TSTypeReferenceBuilder {
-    (typeName: K.IdentifierKind | K.TSQualifiedNameKind, typeParameters?: K.TSTypeParameterInstantiationKind | null): namedTypes.TSTypeReference;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-        typeName: K.IdentifierKind | K.TSQualifiedNameKind;
-        typeParameters?: K.TSTypeParameterInstantiationKind | null;
-    }): namedTypes.TSTypeReference;
+  (
+    typeName: K.IdentifierKind | K.TSQualifiedNameKind,
+    typeParameters?: K.TSTypeParameterInstantiationKind | null,
+  ): namedTypes.TSTypeReference
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+    typeName: K.IdentifierKind | K.TSQualifiedNameKind
+    typeParameters?: K.TSTypeParameterInstantiationKind | null
+  }): namedTypes.TSTypeReference
 }
 export interface TSAsExpressionBuilder {
-    (expression: K.ExpressionKind, typeAnnotation: K.TSTypeKind): namedTypes.TSAsExpression;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        expression: K.ExpressionKind;
-        extra?: {
-            parenthesized: boolean;
-        } | null;
-        loc?: K.SourceLocationKind | null;
-        typeAnnotation: K.TSTypeKind;
-    }): namedTypes.TSAsExpression;
+  (
+    expression: K.ExpressionKind,
+    typeAnnotation: K.TSTypeKind,
+  ): namedTypes.TSAsExpression
+  from(params: {
+    comments?: K.CommentKind[] | null
+    expression: K.ExpressionKind
+    extra?: {
+      parenthesized: boolean
+    } | null
+    loc?: K.SourceLocationKind | null
+    typeAnnotation: K.TSTypeKind
+  }): namedTypes.TSAsExpression
 }
 export interface TSTypeCastExpressionBuilder {
-    (expression: K.ExpressionKind, typeAnnotation: K.TSTypeKind): namedTypes.TSTypeCastExpression;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        expression: K.ExpressionKind;
-        loc?: K.SourceLocationKind | null;
-        typeAnnotation: K.TSTypeKind;
-    }): namedTypes.TSTypeCastExpression;
+  (
+    expression: K.ExpressionKind,
+    typeAnnotation: K.TSTypeKind,
+  ): namedTypes.TSTypeCastExpression
+  from(params: {
+    comments?: K.CommentKind[] | null
+    expression: K.ExpressionKind
+    loc?: K.SourceLocationKind | null
+    typeAnnotation: K.TSTypeKind
+  }): namedTypes.TSTypeCastExpression
 }
 export interface TSSatisfiesExpressionBuilder {
-    (expression: K.ExpressionKind, typeAnnotation: K.TSTypeKind): namedTypes.TSSatisfiesExpression;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        expression: K.ExpressionKind;
-        loc?: K.SourceLocationKind | null;
-        typeAnnotation: K.TSTypeKind;
-    }): namedTypes.TSSatisfiesExpression;
+  (
+    expression: K.ExpressionKind,
+    typeAnnotation: K.TSTypeKind,
+  ): namedTypes.TSSatisfiesExpression
+  from(params: {
+    comments?: K.CommentKind[] | null
+    expression: K.ExpressionKind
+    loc?: K.SourceLocationKind | null
+    typeAnnotation: K.TSTypeKind
+  }): namedTypes.TSSatisfiesExpression
 }
 export interface TSNonNullExpressionBuilder {
-    (expression: K.ExpressionKind): namedTypes.TSNonNullExpression;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        expression: K.ExpressionKind;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.TSNonNullExpression;
+  (expression: K.ExpressionKind): namedTypes.TSNonNullExpression
+  from(params: {
+    comments?: K.CommentKind[] | null
+    expression: K.ExpressionKind
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.TSNonNullExpression
 }
 export interface TSAnyKeywordBuilder {
-    (): namedTypes.TSAnyKeyword;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.TSAnyKeyword;
+  (): namedTypes.TSAnyKeyword
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.TSAnyKeyword
 }
 export interface TSBigIntKeywordBuilder {
-    (): namedTypes.TSBigIntKeyword;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.TSBigIntKeyword;
+  (): namedTypes.TSBigIntKeyword
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.TSBigIntKeyword
 }
 export interface TSBooleanKeywordBuilder {
-    (): namedTypes.TSBooleanKeyword;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.TSBooleanKeyword;
+  (): namedTypes.TSBooleanKeyword
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.TSBooleanKeyword
 }
 export interface TSNeverKeywordBuilder {
-    (): namedTypes.TSNeverKeyword;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.TSNeverKeyword;
+  (): namedTypes.TSNeverKeyword
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.TSNeverKeyword
 }
 export interface TSNullKeywordBuilder {
-    (): namedTypes.TSNullKeyword;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.TSNullKeyword;
+  (): namedTypes.TSNullKeyword
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.TSNullKeyword
 }
 export interface TSNumberKeywordBuilder {
-    (): namedTypes.TSNumberKeyword;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.TSNumberKeyword;
+  (): namedTypes.TSNumberKeyword
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.TSNumberKeyword
 }
 export interface TSObjectKeywordBuilder {
-    (): namedTypes.TSObjectKeyword;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.TSObjectKeyword;
+  (): namedTypes.TSObjectKeyword
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.TSObjectKeyword
 }
 export interface TSStringKeywordBuilder {
-    (): namedTypes.TSStringKeyword;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.TSStringKeyword;
+  (): namedTypes.TSStringKeyword
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.TSStringKeyword
 }
 export interface TSSymbolKeywordBuilder {
-    (): namedTypes.TSSymbolKeyword;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.TSSymbolKeyword;
+  (): namedTypes.TSSymbolKeyword
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.TSSymbolKeyword
 }
 export interface TSUndefinedKeywordBuilder {
-    (): namedTypes.TSUndefinedKeyword;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.TSUndefinedKeyword;
+  (): namedTypes.TSUndefinedKeyword
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.TSUndefinedKeyword
 }
 export interface TSUnknownKeywordBuilder {
-    (): namedTypes.TSUnknownKeyword;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.TSUnknownKeyword;
+  (): namedTypes.TSUnknownKeyword
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.TSUnknownKeyword
 }
 export interface TSVoidKeywordBuilder {
-    (): namedTypes.TSVoidKeyword;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.TSVoidKeyword;
+  (): namedTypes.TSVoidKeyword
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.TSVoidKeyword
 }
 export interface TSIntrinsicKeywordBuilder {
-    (): namedTypes.TSIntrinsicKeyword;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.TSIntrinsicKeyword;
+  (): namedTypes.TSIntrinsicKeyword
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.TSIntrinsicKeyword
 }
 export interface TSThisTypeBuilder {
-    (): namedTypes.TSThisType;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.TSThisType;
+  (): namedTypes.TSThisType
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.TSThisType
 }
 export interface TSArrayTypeBuilder {
-    (elementType: K.TSTypeKind): namedTypes.TSArrayType;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        elementType: K.TSTypeKind;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.TSArrayType;
+  (elementType: K.TSTypeKind): namedTypes.TSArrayType
+  from(params: {
+    comments?: K.CommentKind[] | null
+    elementType: K.TSTypeKind
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.TSArrayType
 }
 export interface TSLiteralTypeBuilder {
-    (literal: K.NumericLiteralKind | K.StringLiteralKind | K.BooleanLiteralKind | K.TemplateLiteralKind | K.UnaryExpressionKind | K.BigIntLiteralKind): namedTypes.TSLiteralType;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        literal: K.NumericLiteralKind | K.StringLiteralKind | K.BooleanLiteralKind | K.TemplateLiteralKind | K.UnaryExpressionKind | K.BigIntLiteralKind;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.TSLiteralType;
+  (
+    literal:
+      | K.NumericLiteralKind
+      | K.StringLiteralKind
+      | K.BooleanLiteralKind
+      | K.TemplateLiteralKind
+      | K.UnaryExpressionKind
+      | K.BigIntLiteralKind,
+  ): namedTypes.TSLiteralType
+  from(params: {
+    comments?: K.CommentKind[] | null
+    literal:
+      | K.NumericLiteralKind
+      | K.StringLiteralKind
+      | K.BooleanLiteralKind
+      | K.TemplateLiteralKind
+      | K.UnaryExpressionKind
+      | K.BigIntLiteralKind
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.TSLiteralType
 }
 export interface TSUnionTypeBuilder {
-    (types: K.TSTypeKind[]): namedTypes.TSUnionType;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-        types: K.TSTypeKind[];
-    }): namedTypes.TSUnionType;
+  (types: K.TSTypeKind[]): namedTypes.TSUnionType
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+    types: K.TSTypeKind[]
+  }): namedTypes.TSUnionType
 }
 export interface TSIntersectionTypeBuilder {
-    (types: K.TSTypeKind[]): namedTypes.TSIntersectionType;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-        types: K.TSTypeKind[];
-    }): namedTypes.TSIntersectionType;
+  (types: K.TSTypeKind[]): namedTypes.TSIntersectionType
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+    types: K.TSTypeKind[]
+  }): namedTypes.TSIntersectionType
 }
 export interface TSConditionalTypeBuilder {
-    (checkType: K.TSTypeKind, extendsType: K.TSTypeKind, trueType: K.TSTypeKind, falseType: K.TSTypeKind): namedTypes.TSConditionalType;
-    from(params: {
-        checkType: K.TSTypeKind;
-        comments?: K.CommentKind[] | null;
-        extendsType: K.TSTypeKind;
-        falseType: K.TSTypeKind;
-        loc?: K.SourceLocationKind | null;
-        trueType: K.TSTypeKind;
-    }): namedTypes.TSConditionalType;
+  (
+    checkType: K.TSTypeKind,
+    extendsType: K.TSTypeKind,
+    trueType: K.TSTypeKind,
+    falseType: K.TSTypeKind,
+  ): namedTypes.TSConditionalType
+  from(params: {
+    checkType: K.TSTypeKind
+    comments?: K.CommentKind[] | null
+    extendsType: K.TSTypeKind
+    falseType: K.TSTypeKind
+    loc?: K.SourceLocationKind | null
+    trueType: K.TSTypeKind
+  }): namedTypes.TSConditionalType
 }
 export interface TSInferTypeBuilder {
-    (typeParameter: K.TSTypeParameterKind): namedTypes.TSInferType;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-        typeParameter: K.TSTypeParameterKind;
-    }): namedTypes.TSInferType;
+  (typeParameter: K.TSTypeParameterKind): namedTypes.TSInferType
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+    typeParameter: K.TSTypeParameterKind
+  }): namedTypes.TSInferType
 }
 export interface TSTypeParameterBuilder {
-    (name: K.IdentifierKind | string, constraint?: K.TSTypeKind | undefined, defaultParam?: K.TSTypeKind | undefined): namedTypes.TSTypeParameter;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        constraint?: K.TSTypeKind | undefined;
-        default?: K.TSTypeKind | undefined;
-        loc?: K.SourceLocationKind | null;
-        name: K.IdentifierKind | string;
-        optional?: boolean;
-        typeAnnotation?: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null;
-    }): namedTypes.TSTypeParameter;
+  (
+    name: K.IdentifierKind | string,
+    constraint?: K.TSTypeKind | undefined,
+    defaultParam?: K.TSTypeKind | undefined,
+  ): namedTypes.TSTypeParameter
+  from(params: {
+    comments?: K.CommentKind[] | null
+    constraint?: K.TSTypeKind | undefined
+    default?: K.TSTypeKind | undefined
+    loc?: K.SourceLocationKind | null
+    name: K.IdentifierKind | string
+    optional?: boolean
+    typeAnnotation?: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null
+  }): namedTypes.TSTypeParameter
 }
 export interface TSParenthesizedTypeBuilder {
-    (typeAnnotation: K.TSTypeKind): namedTypes.TSParenthesizedType;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-        typeAnnotation: K.TSTypeKind;
-    }): namedTypes.TSParenthesizedType;
+  (typeAnnotation: K.TSTypeKind): namedTypes.TSParenthesizedType
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+    typeAnnotation: K.TSTypeKind
+  }): namedTypes.TSParenthesizedType
 }
 export interface TSFunctionTypeBuilder {
-    (parameters: (K.IdentifierKind | K.RestElementKind | K.ArrayPatternKind | K.ObjectPatternKind)[]): namedTypes.TSFunctionType;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-        parameters: (K.IdentifierKind | K.RestElementKind | K.ArrayPatternKind | K.ObjectPatternKind)[];
-        typeAnnotation?: K.TSTypeAnnotationKind | null;
-        typeParameters?: K.TSTypeParameterDeclarationKind | null | undefined;
-    }): namedTypes.TSFunctionType;
+  (
+    parameters: (
+      | K.IdentifierKind
+      | K.RestElementKind
+      | K.ArrayPatternKind
+      | K.ObjectPatternKind
+    )[],
+  ): namedTypes.TSFunctionType
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+    parameters: (
+      | K.IdentifierKind
+      | K.RestElementKind
+      | K.ArrayPatternKind
+      | K.ObjectPatternKind
+    )[]
+    typeAnnotation?: K.TSTypeAnnotationKind | null
+    typeParameters?: K.TSTypeParameterDeclarationKind | null | undefined
+  }): namedTypes.TSFunctionType
 }
 export interface TSConstructorTypeBuilder {
-    (parameters: (K.IdentifierKind | K.RestElementKind | K.ArrayPatternKind | K.ObjectPatternKind)[]): namedTypes.TSConstructorType;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-        parameters: (K.IdentifierKind | K.RestElementKind | K.ArrayPatternKind | K.ObjectPatternKind)[];
-        typeAnnotation?: K.TSTypeAnnotationKind | null;
-        typeParameters?: K.TSTypeParameterDeclarationKind | null | undefined;
-    }): namedTypes.TSConstructorType;
+  (
+    parameters: (
+      | K.IdentifierKind
+      | K.RestElementKind
+      | K.ArrayPatternKind
+      | K.ObjectPatternKind
+    )[],
+  ): namedTypes.TSConstructorType
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+    parameters: (
+      | K.IdentifierKind
+      | K.RestElementKind
+      | K.ArrayPatternKind
+      | K.ObjectPatternKind
+    )[]
+    typeAnnotation?: K.TSTypeAnnotationKind | null
+    typeParameters?: K.TSTypeParameterDeclarationKind | null | undefined
+  }): namedTypes.TSConstructorType
 }
 export interface TSDeclareFunctionBuilder {
-    (id: K.IdentifierKind | null | undefined, params: K.PatternKind[], returnType?: K.TSTypeAnnotationKind | K.NoopKind | null): namedTypes.TSDeclareFunction;
-    from(params: {
-        async?: boolean;
-        comments?: K.CommentKind[] | null;
-        declare?: boolean;
-        generator?: boolean;
-        id?: K.IdentifierKind | null;
-        loc?: K.SourceLocationKind | null;
-        params: K.PatternKind[];
-        returnType?: K.TSTypeAnnotationKind | K.NoopKind | null;
-        typeParameters?: K.TSTypeParameterDeclarationKind | null | undefined;
-    }): namedTypes.TSDeclareFunction;
+  (
+    id: K.IdentifierKind | null | undefined,
+    params: K.PatternKind[],
+    returnType?: K.TSTypeAnnotationKind | K.NoopKind | null,
+  ): namedTypes.TSDeclareFunction
+  from(params: {
+    async?: boolean
+    comments?: K.CommentKind[] | null
+    declare?: boolean
+    generator?: boolean
+    id?: K.IdentifierKind | null
+    loc?: K.SourceLocationKind | null
+    params: K.PatternKind[]
+    returnType?: K.TSTypeAnnotationKind | K.NoopKind | null
+    typeParameters?: K.TSTypeParameterDeclarationKind | null | undefined
+  }): namedTypes.TSDeclareFunction
 }
 export interface TSDeclareMethodBuilder {
-    (key: K.IdentifierKind | K.StringLiteralKind | K.NumericLiteralKind | K.ExpressionKind, params: K.PatternKind[], returnType?: K.TSTypeAnnotationKind | K.NoopKind | null): namedTypes.TSDeclareMethod;
-    from(params: {
-        abstract?: boolean;
-        access?: "public" | "private" | "protected" | undefined;
-        accessibility?: "public" | "private" | "protected" | undefined;
-        async?: boolean;
-        comments?: K.CommentKind[] | null;
-        computed?: boolean;
-        decorators?: K.DecoratorKind[] | null;
-        generator?: boolean;
-        key: K.IdentifierKind | K.StringLiteralKind | K.NumericLiteralKind | K.ExpressionKind;
-        kind?: "get" | "set" | "method" | "constructor";
-        loc?: K.SourceLocationKind | null;
-        optional?: boolean;
-        params: K.PatternKind[];
-        returnType?: K.TSTypeAnnotationKind | K.NoopKind | null;
-        static?: boolean;
-        typeParameters?: K.TSTypeParameterDeclarationKind | null | undefined;
-    }): namedTypes.TSDeclareMethod;
+  (
+    key:
+      | K.IdentifierKind
+      | K.StringLiteralKind
+      | K.NumericLiteralKind
+      | K.ExpressionKind,
+    params: K.PatternKind[],
+    returnType?: K.TSTypeAnnotationKind | K.NoopKind | null,
+  ): namedTypes.TSDeclareMethod
+  from(params: {
+    abstract?: boolean
+    access?: 'public' | 'private' | 'protected' | undefined
+    accessibility?: 'public' | 'private' | 'protected' | undefined
+    async?: boolean
+    comments?: K.CommentKind[] | null
+    computed?: boolean
+    decorators?: K.DecoratorKind[] | null
+    generator?: boolean
+    key:
+      | K.IdentifierKind
+      | K.StringLiteralKind
+      | K.NumericLiteralKind
+      | K.ExpressionKind
+    kind?: 'get' | 'set' | 'method' | 'constructor'
+    loc?: K.SourceLocationKind | null
+    optional?: boolean
+    params: K.PatternKind[]
+    returnType?: K.TSTypeAnnotationKind | K.NoopKind | null
+    static?: boolean
+    typeParameters?: K.TSTypeParameterDeclarationKind | null | undefined
+  }): namedTypes.TSDeclareMethod
 }
 export interface TSMappedTypeBuilder {
-    (typeParameter: K.TSTypeParameterKind, typeAnnotation?: K.TSTypeKind | null): namedTypes.TSMappedType;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-        optional?: boolean | "+" | "-";
-        readonly?: boolean | "+" | "-";
-        typeAnnotation?: K.TSTypeKind | null;
-        typeParameter: K.TSTypeParameterKind;
-    }): namedTypes.TSMappedType;
+  (
+    typeParameter: K.TSTypeParameterKind,
+    typeAnnotation?: K.TSTypeKind | null,
+  ): namedTypes.TSMappedType
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+    optional?: boolean | '+' | '-'
+    readonly?: boolean | '+' | '-'
+    typeAnnotation?: K.TSTypeKind | null
+    typeParameter: K.TSTypeParameterKind
+  }): namedTypes.TSMappedType
 }
 export interface TSTupleTypeBuilder {
-    (elementTypes: (K.TSTypeKind | K.TSNamedTupleMemberKind)[]): namedTypes.TSTupleType;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        elementTypes: (K.TSTypeKind | K.TSNamedTupleMemberKind)[];
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.TSTupleType;
+  (
+    elementTypes: (K.TSTypeKind | K.TSNamedTupleMemberKind)[],
+  ): namedTypes.TSTupleType
+  from(params: {
+    comments?: K.CommentKind[] | null
+    elementTypes: (K.TSTypeKind | K.TSNamedTupleMemberKind)[]
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.TSTupleType
 }
 export interface TSNamedTupleMemberBuilder {
-    (label: K.IdentifierKind, elementType: K.TSTypeKind, optional?: boolean): namedTypes.TSNamedTupleMember;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        elementType: K.TSTypeKind;
-        label: K.IdentifierKind;
-        loc?: K.SourceLocationKind | null;
-        optional?: boolean;
-    }): namedTypes.TSNamedTupleMember;
+  (
+    label: K.IdentifierKind,
+    elementType: K.TSTypeKind,
+    optional?: boolean,
+  ): namedTypes.TSNamedTupleMember
+  from(params: {
+    comments?: K.CommentKind[] | null
+    elementType: K.TSTypeKind
+    label: K.IdentifierKind
+    loc?: K.SourceLocationKind | null
+    optional?: boolean
+  }): namedTypes.TSNamedTupleMember
 }
 export interface TSRestTypeBuilder {
-    (typeAnnotation: K.TSTypeKind): namedTypes.TSRestType;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-        typeAnnotation: K.TSTypeKind;
-    }): namedTypes.TSRestType;
+  (typeAnnotation: K.TSTypeKind): namedTypes.TSRestType
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+    typeAnnotation: K.TSTypeKind
+  }): namedTypes.TSRestType
 }
 export interface TSOptionalTypeBuilder {
-    (typeAnnotation: K.TSTypeKind): namedTypes.TSOptionalType;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-        typeAnnotation: K.TSTypeKind;
-    }): namedTypes.TSOptionalType;
+  (typeAnnotation: K.TSTypeKind): namedTypes.TSOptionalType
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+    typeAnnotation: K.TSTypeKind
+  }): namedTypes.TSOptionalType
 }
 export interface TSIndexedAccessTypeBuilder {
-    (objectType: K.TSTypeKind, indexType: K.TSTypeKind): namedTypes.TSIndexedAccessType;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        indexType: K.TSTypeKind;
-        loc?: K.SourceLocationKind | null;
-        objectType: K.TSTypeKind;
-    }): namedTypes.TSIndexedAccessType;
+  (
+    objectType: K.TSTypeKind,
+    indexType: K.TSTypeKind,
+  ): namedTypes.TSIndexedAccessType
+  from(params: {
+    comments?: K.CommentKind[] | null
+    indexType: K.TSTypeKind
+    loc?: K.SourceLocationKind | null
+    objectType: K.TSTypeKind
+  }): namedTypes.TSIndexedAccessType
 }
 export interface TSTypeOperatorBuilder {
-    (operator: string): namedTypes.TSTypeOperator;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-        operator: string;
-        typeAnnotation: K.TSTypeKind;
-    }): namedTypes.TSTypeOperator;
+  (operator: string): namedTypes.TSTypeOperator
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+    operator: string
+    typeAnnotation: K.TSTypeKind
+  }): namedTypes.TSTypeOperator
 }
 export interface TSIndexSignatureBuilder {
-    (parameters: K.IdentifierKind[], typeAnnotation?: K.TSTypeAnnotationKind | null): namedTypes.TSIndexSignature;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-        parameters: K.IdentifierKind[];
-        readonly?: boolean;
-        typeAnnotation?: K.TSTypeAnnotationKind | null;
-    }): namedTypes.TSIndexSignature;
+  (
+    parameters: K.IdentifierKind[],
+    typeAnnotation?: K.TSTypeAnnotationKind | null,
+  ): namedTypes.TSIndexSignature
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+    parameters: K.IdentifierKind[]
+    readonly?: boolean
+    typeAnnotation?: K.TSTypeAnnotationKind | null
+  }): namedTypes.TSIndexSignature
 }
 export interface TSPropertySignatureBuilder {
-    (key: K.ExpressionKind, typeAnnotation?: K.TSTypeAnnotationKind | null, optional?: boolean): namedTypes.TSPropertySignature;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        computed?: boolean;
-        initializer?: K.ExpressionKind | null;
-        key: K.ExpressionKind;
-        loc?: K.SourceLocationKind | null;
-        optional?: boolean;
-        readonly?: boolean;
-        typeAnnotation?: K.TSTypeAnnotationKind | null;
-    }): namedTypes.TSPropertySignature;
+  (
+    key: K.ExpressionKind,
+    typeAnnotation?: K.TSTypeAnnotationKind | null,
+    optional?: boolean,
+  ): namedTypes.TSPropertySignature
+  from(params: {
+    comments?: K.CommentKind[] | null
+    computed?: boolean
+    initializer?: K.ExpressionKind | null
+    key: K.ExpressionKind
+    loc?: K.SourceLocationKind | null
+    optional?: boolean
+    readonly?: boolean
+    typeAnnotation?: K.TSTypeAnnotationKind | null
+  }): namedTypes.TSPropertySignature
 }
 export interface TSMethodSignatureBuilder {
-    (key: K.ExpressionKind, parameters: (K.IdentifierKind | K.RestElementKind | K.ArrayPatternKind | K.ObjectPatternKind)[], typeAnnotation?: K.TSTypeAnnotationKind | null): namedTypes.TSMethodSignature;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        computed?: boolean;
-        key: K.ExpressionKind;
-        loc?: K.SourceLocationKind | null;
-        optional?: boolean;
-        parameters: (K.IdentifierKind | K.RestElementKind | K.ArrayPatternKind | K.ObjectPatternKind)[];
-        typeAnnotation?: K.TSTypeAnnotationKind | null;
-        typeParameters?: K.TSTypeParameterDeclarationKind | null | undefined;
-    }): namedTypes.TSMethodSignature;
+  (
+    key: K.ExpressionKind,
+    parameters: (
+      | K.IdentifierKind
+      | K.RestElementKind
+      | K.ArrayPatternKind
+      | K.ObjectPatternKind
+    )[],
+    typeAnnotation?: K.TSTypeAnnotationKind | null,
+  ): namedTypes.TSMethodSignature
+  from(params: {
+    comments?: K.CommentKind[] | null
+    computed?: boolean
+    key: K.ExpressionKind
+    loc?: K.SourceLocationKind | null
+    optional?: boolean
+    parameters: (
+      | K.IdentifierKind
+      | K.RestElementKind
+      | K.ArrayPatternKind
+      | K.ObjectPatternKind
+    )[]
+    typeAnnotation?: K.TSTypeAnnotationKind | null
+    typeParameters?: K.TSTypeParameterDeclarationKind | null | undefined
+  }): namedTypes.TSMethodSignature
 }
 export interface TSTypePredicateBuilder {
-    (parameterName: K.IdentifierKind | K.TSThisTypeKind, typeAnnotation?: K.TSTypeAnnotationKind | null, asserts?: boolean): namedTypes.TSTypePredicate;
-    from(params: {
-        asserts?: boolean;
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-        parameterName: K.IdentifierKind | K.TSThisTypeKind;
-        typeAnnotation?: K.TSTypeAnnotationKind | null;
-    }): namedTypes.TSTypePredicate;
+  (
+    parameterName: K.IdentifierKind | K.TSThisTypeKind,
+    typeAnnotation?: K.TSTypeAnnotationKind | null,
+    asserts?: boolean,
+  ): namedTypes.TSTypePredicate
+  from(params: {
+    asserts?: boolean
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+    parameterName: K.IdentifierKind | K.TSThisTypeKind
+    typeAnnotation?: K.TSTypeAnnotationKind | null
+  }): namedTypes.TSTypePredicate
 }
 export interface TSCallSignatureDeclarationBuilder {
-    (parameters: (K.IdentifierKind | K.RestElementKind | K.ArrayPatternKind | K.ObjectPatternKind)[], typeAnnotation?: K.TSTypeAnnotationKind | null): namedTypes.TSCallSignatureDeclaration;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-        parameters: (K.IdentifierKind | K.RestElementKind | K.ArrayPatternKind | K.ObjectPatternKind)[];
-        typeAnnotation?: K.TSTypeAnnotationKind | null;
-        typeParameters?: K.TSTypeParameterDeclarationKind | null | undefined;
-    }): namedTypes.TSCallSignatureDeclaration;
+  (
+    parameters: (
+      | K.IdentifierKind
+      | K.RestElementKind
+      | K.ArrayPatternKind
+      | K.ObjectPatternKind
+    )[],
+    typeAnnotation?: K.TSTypeAnnotationKind | null,
+  ): namedTypes.TSCallSignatureDeclaration
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+    parameters: (
+      | K.IdentifierKind
+      | K.RestElementKind
+      | K.ArrayPatternKind
+      | K.ObjectPatternKind
+    )[]
+    typeAnnotation?: K.TSTypeAnnotationKind | null
+    typeParameters?: K.TSTypeParameterDeclarationKind | null | undefined
+  }): namedTypes.TSCallSignatureDeclaration
 }
 export interface TSConstructSignatureDeclarationBuilder {
-    (parameters: (K.IdentifierKind | K.RestElementKind | K.ArrayPatternKind | K.ObjectPatternKind)[], typeAnnotation?: K.TSTypeAnnotationKind | null): namedTypes.TSConstructSignatureDeclaration;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-        parameters: (K.IdentifierKind | K.RestElementKind | K.ArrayPatternKind | K.ObjectPatternKind)[];
-        typeAnnotation?: K.TSTypeAnnotationKind | null;
-        typeParameters?: K.TSTypeParameterDeclarationKind | null | undefined;
-    }): namedTypes.TSConstructSignatureDeclaration;
+  (
+    parameters: (
+      | K.IdentifierKind
+      | K.RestElementKind
+      | K.ArrayPatternKind
+      | K.ObjectPatternKind
+    )[],
+    typeAnnotation?: K.TSTypeAnnotationKind | null,
+  ): namedTypes.TSConstructSignatureDeclaration
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+    parameters: (
+      | K.IdentifierKind
+      | K.RestElementKind
+      | K.ArrayPatternKind
+      | K.ObjectPatternKind
+    )[]
+    typeAnnotation?: K.TSTypeAnnotationKind | null
+    typeParameters?: K.TSTypeParameterDeclarationKind | null | undefined
+  }): namedTypes.TSConstructSignatureDeclaration
 }
 export interface TSEnumMemberBuilder {
-    (id: K.IdentifierKind | K.StringLiteralKind, initializer?: K.ExpressionKind | null): namedTypes.TSEnumMember;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        id: K.IdentifierKind | K.StringLiteralKind;
-        initializer?: K.ExpressionKind | null;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.TSEnumMember;
+  (
+    id: K.IdentifierKind | K.StringLiteralKind,
+    initializer?: K.ExpressionKind | null,
+  ): namedTypes.TSEnumMember
+  from(params: {
+    comments?: K.CommentKind[] | null
+    id: K.IdentifierKind | K.StringLiteralKind
+    initializer?: K.ExpressionKind | null
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.TSEnumMember
 }
 export interface TSTypeQueryBuilder {
-    (exprName: K.IdentifierKind | K.TSQualifiedNameKind | K.TSImportTypeKind): namedTypes.TSTypeQuery;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        exprName: K.IdentifierKind | K.TSQualifiedNameKind | K.TSImportTypeKind;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.TSTypeQuery;
+  (
+    exprName: K.IdentifierKind | K.TSQualifiedNameKind | K.TSImportTypeKind,
+  ): namedTypes.TSTypeQuery
+  from(params: {
+    comments?: K.CommentKind[] | null
+    exprName: K.IdentifierKind | K.TSQualifiedNameKind | K.TSImportTypeKind
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.TSTypeQuery
 }
 export interface TSImportTypeBuilder {
-    (argument: K.StringLiteralKind, qualifier?: K.IdentifierKind | K.TSQualifiedNameKind | undefined, typeParameters?: K.TSTypeParameterInstantiationKind | null): namedTypes.TSImportType;
-    from(params: {
-        argument: K.StringLiteralKind;
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-        qualifier?: K.IdentifierKind | K.TSQualifiedNameKind | undefined;
-        typeParameters?: K.TSTypeParameterInstantiationKind | null;
-    }): namedTypes.TSImportType;
+  (
+    argument: K.StringLiteralKind,
+    qualifier?: K.IdentifierKind | K.TSQualifiedNameKind | undefined,
+    typeParameters?: K.TSTypeParameterInstantiationKind | null,
+  ): namedTypes.TSImportType
+  from(params: {
+    argument: K.StringLiteralKind
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+    qualifier?: K.IdentifierKind | K.TSQualifiedNameKind | undefined
+    typeParameters?: K.TSTypeParameterInstantiationKind | null
+  }): namedTypes.TSImportType
 }
 export interface TSTypeLiteralBuilder {
-    (members: (K.TSCallSignatureDeclarationKind | K.TSConstructSignatureDeclarationKind | K.TSIndexSignatureKind | K.TSMethodSignatureKind | K.TSPropertySignatureKind)[]): namedTypes.TSTypeLiteral;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-        members: (K.TSCallSignatureDeclarationKind | K.TSConstructSignatureDeclarationKind | K.TSIndexSignatureKind | K.TSMethodSignatureKind | K.TSPropertySignatureKind)[];
-    }): namedTypes.TSTypeLiteral;
+  (
+    members: (
+      | K.TSCallSignatureDeclarationKind
+      | K.TSConstructSignatureDeclarationKind
+      | K.TSIndexSignatureKind
+      | K.TSMethodSignatureKind
+      | K.TSPropertySignatureKind
+    )[],
+  ): namedTypes.TSTypeLiteral
+  from(params: {
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+    members: (
+      | K.TSCallSignatureDeclarationKind
+      | K.TSConstructSignatureDeclarationKind
+      | K.TSIndexSignatureKind
+      | K.TSMethodSignatureKind
+      | K.TSPropertySignatureKind
+    )[]
+  }): namedTypes.TSTypeLiteral
 }
 export interface TSTypeAssertionBuilder {
-    (typeAnnotation: K.TSTypeKind, expression: K.ExpressionKind): namedTypes.TSTypeAssertion;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        expression: K.ExpressionKind;
-        extra?: {
-            parenthesized: boolean;
-        } | null;
-        loc?: K.SourceLocationKind | null;
-        typeAnnotation: K.TSTypeKind;
-    }): namedTypes.TSTypeAssertion;
+  (
+    typeAnnotation: K.TSTypeKind,
+    expression: K.ExpressionKind,
+  ): namedTypes.TSTypeAssertion
+  from(params: {
+    comments?: K.CommentKind[] | null
+    expression: K.ExpressionKind
+    extra?: {
+      parenthesized: boolean
+    } | null
+    loc?: K.SourceLocationKind | null
+    typeAnnotation: K.TSTypeKind
+  }): namedTypes.TSTypeAssertion
 }
 export interface TSInstantiationExpressionBuilder {
-    (expression: K.ExpressionKind, typeParameters?: K.TSTypeParameterInstantiationKind | null): namedTypes.TSInstantiationExpression;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        expression: K.ExpressionKind;
-        loc?: K.SourceLocationKind | null;
-        typeParameters?: K.TSTypeParameterInstantiationKind | null;
-    }): namedTypes.TSInstantiationExpression;
+  (
+    expression: K.ExpressionKind,
+    typeParameters?: K.TSTypeParameterInstantiationKind | null,
+  ): namedTypes.TSInstantiationExpression
+  from(params: {
+    comments?: K.CommentKind[] | null
+    expression: K.ExpressionKind
+    loc?: K.SourceLocationKind | null
+    typeParameters?: K.TSTypeParameterInstantiationKind | null
+  }): namedTypes.TSInstantiationExpression
 }
 export interface TSEnumDeclarationBuilder {
-    (id: K.IdentifierKind, members: K.TSEnumMemberKind[]): namedTypes.TSEnumDeclaration;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        const?: boolean;
-        declare?: boolean;
-        id: K.IdentifierKind;
-        initializer?: K.ExpressionKind | null;
-        loc?: K.SourceLocationKind | null;
-        members: K.TSEnumMemberKind[];
-    }): namedTypes.TSEnumDeclaration;
+  (
+    id: K.IdentifierKind,
+    members: K.TSEnumMemberKind[],
+  ): namedTypes.TSEnumDeclaration
+  from(params: {
+    comments?: K.CommentKind[] | null
+    const?: boolean
+    declare?: boolean
+    id: K.IdentifierKind
+    initializer?: K.ExpressionKind | null
+    loc?: K.SourceLocationKind | null
+    members: K.TSEnumMemberKind[]
+  }): namedTypes.TSEnumDeclaration
 }
 export interface TSTypeAliasDeclarationBuilder {
-    (id: K.IdentifierKind, typeAnnotation: K.TSTypeKind): namedTypes.TSTypeAliasDeclaration;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        declare?: boolean;
-        id: K.IdentifierKind;
-        loc?: K.SourceLocationKind | null;
-        typeAnnotation: K.TSTypeKind;
-        typeParameters?: K.TSTypeParameterDeclarationKind | null | undefined;
-    }): namedTypes.TSTypeAliasDeclaration;
+  (
+    id: K.IdentifierKind,
+    typeAnnotation: K.TSTypeKind,
+  ): namedTypes.TSTypeAliasDeclaration
+  from(params: {
+    comments?: K.CommentKind[] | null
+    declare?: boolean
+    id: K.IdentifierKind
+    loc?: K.SourceLocationKind | null
+    typeAnnotation: K.TSTypeKind
+    typeParameters?: K.TSTypeParameterDeclarationKind | null | undefined
+  }): namedTypes.TSTypeAliasDeclaration
 }
 export interface TSModuleBlockBuilder {
-    (body: K.StatementKind[]): namedTypes.TSModuleBlock;
-    from(params: {
-        body: K.StatementKind[];
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.TSModuleBlock;
+  (body: K.StatementKind[]): namedTypes.TSModuleBlock
+  from(params: {
+    body: K.StatementKind[]
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.TSModuleBlock
 }
 export interface TSModuleDeclarationBuilder {
-    (id: K.StringLiteralKind | K.IdentifierKind | K.TSQualifiedNameKind, body?: K.TSModuleBlockKind | K.TSModuleDeclarationKind | null): namedTypes.TSModuleDeclaration;
-    from(params: {
-        body?: K.TSModuleBlockKind | K.TSModuleDeclarationKind | null;
-        comments?: K.CommentKind[] | null;
-        declare?: boolean;
-        global?: boolean;
-        id: K.StringLiteralKind | K.IdentifierKind | K.TSQualifiedNameKind;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.TSModuleDeclaration;
+  (
+    id: K.StringLiteralKind | K.IdentifierKind | K.TSQualifiedNameKind,
+    body?: K.TSModuleBlockKind | K.TSModuleDeclarationKind | null,
+  ): namedTypes.TSModuleDeclaration
+  from(params: {
+    body?: K.TSModuleBlockKind | K.TSModuleDeclarationKind | null
+    comments?: K.CommentKind[] | null
+    declare?: boolean
+    global?: boolean
+    id: K.StringLiteralKind | K.IdentifierKind | K.TSQualifiedNameKind
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.TSModuleDeclaration
 }
 export interface TSImportEqualsDeclarationBuilder {
-    (id: K.IdentifierKind, moduleReference: K.IdentifierKind | K.TSQualifiedNameKind | K.TSExternalModuleReferenceKind): namedTypes.TSImportEqualsDeclaration;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        id: K.IdentifierKind;
-        isExport?: boolean;
-        loc?: K.SourceLocationKind | null;
-        moduleReference: K.IdentifierKind | K.TSQualifiedNameKind | K.TSExternalModuleReferenceKind;
-    }): namedTypes.TSImportEqualsDeclaration;
+  (
+    id: K.IdentifierKind,
+    moduleReference:
+      | K.IdentifierKind
+      | K.TSQualifiedNameKind
+      | K.TSExternalModuleReferenceKind,
+  ): namedTypes.TSImportEqualsDeclaration
+  from(params: {
+    comments?: K.CommentKind[] | null
+    id: K.IdentifierKind
+    isExport?: boolean
+    loc?: K.SourceLocationKind | null
+    moduleReference:
+      | K.IdentifierKind
+      | K.TSQualifiedNameKind
+      | K.TSExternalModuleReferenceKind
+  }): namedTypes.TSImportEqualsDeclaration
 }
 export interface TSExternalModuleReferenceBuilder {
-    (expression: K.StringLiteralKind): namedTypes.TSExternalModuleReference;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        expression: K.StringLiteralKind;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.TSExternalModuleReference;
+  (expression: K.StringLiteralKind): namedTypes.TSExternalModuleReference
+  from(params: {
+    comments?: K.CommentKind[] | null
+    expression: K.StringLiteralKind
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.TSExternalModuleReference
 }
 export interface TSExportAssignmentBuilder {
-    (expression: K.ExpressionKind): namedTypes.TSExportAssignment;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        expression: K.ExpressionKind;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.TSExportAssignment;
+  (expression: K.ExpressionKind): namedTypes.TSExportAssignment
+  from(params: {
+    comments?: K.CommentKind[] | null
+    expression: K.ExpressionKind
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.TSExportAssignment
 }
 export interface TSNamespaceExportDeclarationBuilder {
-    (id: K.IdentifierKind): namedTypes.TSNamespaceExportDeclaration;
-    from(params: {
-        comments?: K.CommentKind[] | null;
-        id: K.IdentifierKind;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.TSNamespaceExportDeclaration;
+  (id: K.IdentifierKind): namedTypes.TSNamespaceExportDeclaration
+  from(params: {
+    comments?: K.CommentKind[] | null
+    id: K.IdentifierKind
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.TSNamespaceExportDeclaration
 }
 export interface TSInterfaceBodyBuilder {
-    (body: (K.TSCallSignatureDeclarationKind | K.TSConstructSignatureDeclarationKind | K.TSIndexSignatureKind | K.TSMethodSignatureKind | K.TSPropertySignatureKind)[]): namedTypes.TSInterfaceBody;
-    from(params: {
-        body: (K.TSCallSignatureDeclarationKind | K.TSConstructSignatureDeclarationKind | K.TSIndexSignatureKind | K.TSMethodSignatureKind | K.TSPropertySignatureKind)[];
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-    }): namedTypes.TSInterfaceBody;
+  (
+    body: (
+      | K.TSCallSignatureDeclarationKind
+      | K.TSConstructSignatureDeclarationKind
+      | K.TSIndexSignatureKind
+      | K.TSMethodSignatureKind
+      | K.TSPropertySignatureKind
+    )[],
+  ): namedTypes.TSInterfaceBody
+  from(params: {
+    body: (
+      | K.TSCallSignatureDeclarationKind
+      | K.TSConstructSignatureDeclarationKind
+      | K.TSIndexSignatureKind
+      | K.TSMethodSignatureKind
+      | K.TSPropertySignatureKind
+    )[]
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+  }): namedTypes.TSInterfaceBody
 }
 export interface TSInterfaceDeclarationBuilder {
-    (id: K.IdentifierKind | K.TSQualifiedNameKind, body: K.TSInterfaceBodyKind): namedTypes.TSInterfaceDeclaration;
-    from(params: {
-        body: K.TSInterfaceBodyKind;
-        comments?: K.CommentKind[] | null;
-        declare?: boolean;
-        extends?: K.TSExpressionWithTypeArgumentsKind[] | null;
-        id: K.IdentifierKind | K.TSQualifiedNameKind;
-        loc?: K.SourceLocationKind | null;
-        typeParameters?: K.TSTypeParameterDeclarationKind | null | undefined;
-    }): namedTypes.TSInterfaceDeclaration;
+  (
+    id: K.IdentifierKind | K.TSQualifiedNameKind,
+    body: K.TSInterfaceBodyKind,
+  ): namedTypes.TSInterfaceDeclaration
+  from(params: {
+    body: K.TSInterfaceBodyKind
+    comments?: K.CommentKind[] | null
+    declare?: boolean
+    extends?: K.TSExpressionWithTypeArgumentsKind[] | null
+    id: K.IdentifierKind | K.TSQualifiedNameKind
+    loc?: K.SourceLocationKind | null
+    typeParameters?: K.TSTypeParameterDeclarationKind | null | undefined
+  }): namedTypes.TSInterfaceDeclaration
 }
 export interface TSParameterPropertyBuilder {
-    (parameter: K.IdentifierKind | K.AssignmentPatternKind): namedTypes.TSParameterProperty;
-    from(params: {
-        accessibility?: "public" | "private" | "protected" | undefined;
-        comments?: K.CommentKind[] | null;
-        loc?: K.SourceLocationKind | null;
-        parameter: K.IdentifierKind | K.AssignmentPatternKind;
-        readonly?: boolean;
-    }): namedTypes.TSParameterProperty;
+  (
+    parameter: K.IdentifierKind | K.AssignmentPatternKind,
+  ): namedTypes.TSParameterProperty
+  from(params: {
+    accessibility?: 'public' | 'private' | 'protected' | undefined
+    comments?: K.CommentKind[] | null
+    loc?: K.SourceLocationKind | null
+    parameter: K.IdentifierKind | K.AssignmentPatternKind
+    readonly?: boolean
+  }): namedTypes.TSParameterProperty
 }
 export interface builders {
-    file: FileBuilder;
-    program: ProgramBuilder;
-    identifier: IdentifierBuilder;
-    blockStatement: BlockStatementBuilder;
-    emptyStatement: EmptyStatementBuilder;
-    expressionStatement: ExpressionStatementBuilder;
-    ifStatement: IfStatementBuilder;
-    labeledStatement: LabeledStatementBuilder;
-    breakStatement: BreakStatementBuilder;
-    continueStatement: ContinueStatementBuilder;
-    withStatement: WithStatementBuilder;
-    switchStatement: SwitchStatementBuilder;
-    switchCase: SwitchCaseBuilder;
-    returnStatement: ReturnStatementBuilder;
-    throwStatement: ThrowStatementBuilder;
-    tryStatement: TryStatementBuilder;
-    catchClause: CatchClauseBuilder;
-    whileStatement: WhileStatementBuilder;
-    doWhileStatement: DoWhileStatementBuilder;
-    forStatement: ForStatementBuilder;
-    variableDeclaration: VariableDeclarationBuilder;
-    forInStatement: ForInStatementBuilder;
-    debuggerStatement: DebuggerStatementBuilder;
-    functionDeclaration: FunctionDeclarationBuilder;
-    functionExpression: FunctionExpressionBuilder;
-    variableDeclarator: VariableDeclaratorBuilder;
-    thisExpression: ThisExpressionBuilder;
-    arrayExpression: ArrayExpressionBuilder;
-    objectExpression: ObjectExpressionBuilder;
-    property: PropertyBuilder;
-    literal: LiteralBuilder;
-    sequenceExpression: SequenceExpressionBuilder;
-    unaryExpression: UnaryExpressionBuilder;
-    binaryExpression: BinaryExpressionBuilder;
-    assignmentExpression: AssignmentExpressionBuilder;
-    memberExpression: MemberExpressionBuilder;
-    updateExpression: UpdateExpressionBuilder;
-    logicalExpression: LogicalExpressionBuilder;
-    conditionalExpression: ConditionalExpressionBuilder;
-    newExpression: NewExpressionBuilder;
-    callExpression: CallExpressionBuilder;
-    restElement: RestElementBuilder;
-    typeAnnotation: TypeAnnotationBuilder;
-    tsTypeAnnotation: TSTypeAnnotationBuilder;
-    spreadElementPattern: SpreadElementPatternBuilder;
-    arrowFunctionExpression: ArrowFunctionExpressionBuilder;
-    forOfStatement: ForOfStatementBuilder;
-    yieldExpression: YieldExpressionBuilder;
-    generatorExpression: GeneratorExpressionBuilder;
-    comprehensionBlock: ComprehensionBlockBuilder;
-    comprehensionExpression: ComprehensionExpressionBuilder;
-    objectProperty: ObjectPropertyBuilder;
-    propertyPattern: PropertyPatternBuilder;
-    objectPattern: ObjectPatternBuilder;
-    arrayPattern: ArrayPatternBuilder;
-    spreadElement: SpreadElementBuilder;
-    assignmentPattern: AssignmentPatternBuilder;
-    methodDefinition: MethodDefinitionBuilder;
-    classPropertyDefinition: ClassPropertyDefinitionBuilder;
-    classProperty: ClassPropertyBuilder;
-    staticBlock: StaticBlockBuilder;
-    classBody: ClassBodyBuilder;
-    classDeclaration: ClassDeclarationBuilder;
-    classExpression: ClassExpressionBuilder;
-    super: SuperBuilder;
-    importSpecifier: ImportSpecifierBuilder;
-    importDefaultSpecifier: ImportDefaultSpecifierBuilder;
-    importNamespaceSpecifier: ImportNamespaceSpecifierBuilder;
-    importDeclaration: ImportDeclarationBuilder;
-    exportNamedDeclaration: ExportNamedDeclarationBuilder;
-    exportSpecifier: ExportSpecifierBuilder;
-    exportDefaultDeclaration: ExportDefaultDeclarationBuilder;
-    exportAllDeclaration: ExportAllDeclarationBuilder;
-    taggedTemplateExpression: TaggedTemplateExpressionBuilder;
-    templateLiteral: TemplateLiteralBuilder;
-    templateElement: TemplateElementBuilder;
-    metaProperty: MetaPropertyBuilder;
-    awaitExpression: AwaitExpressionBuilder;
-    spreadProperty: SpreadPropertyBuilder;
-    spreadPropertyPattern: SpreadPropertyPatternBuilder;
-    importExpression: ImportExpressionBuilder;
-    chainExpression: ChainExpressionBuilder;
-    optionalCallExpression: OptionalCallExpressionBuilder;
-    optionalMemberExpression: OptionalMemberExpressionBuilder;
-    decorator: DecoratorBuilder;
-    privateName: PrivateNameBuilder;
-    classPrivateProperty: ClassPrivatePropertyBuilder;
-    importAttribute: ImportAttributeBuilder;
-    recordExpression: RecordExpressionBuilder;
-    objectMethod: ObjectMethodBuilder;
-    tupleExpression: TupleExpressionBuilder;
-    moduleExpression: ModuleExpressionBuilder;
-    jsxAttribute: JSXAttributeBuilder;
-    jsxIdentifier: JSXIdentifierBuilder;
-    jsxNamespacedName: JSXNamespacedNameBuilder;
-    jsxExpressionContainer: JSXExpressionContainerBuilder;
-    jsxElement: JSXElementBuilder;
-    jsxFragment: JSXFragmentBuilder;
-    jsxMemberExpression: JSXMemberExpressionBuilder;
-    jsxSpreadAttribute: JSXSpreadAttributeBuilder;
-    jsxEmptyExpression: JSXEmptyExpressionBuilder;
-    jsxText: JSXTextBuilder;
-    jsxSpreadChild: JSXSpreadChildBuilder;
-    jsxOpeningElement: JSXOpeningElementBuilder;
-    jsxClosingElement: JSXClosingElementBuilder;
-    jsxOpeningFragment: JSXOpeningFragmentBuilder;
-    jsxClosingFragment: JSXClosingFragmentBuilder;
-    typeParameterDeclaration: TypeParameterDeclarationBuilder;
-    tsTypeParameterDeclaration: TSTypeParameterDeclarationBuilder;
-    typeParameterInstantiation: TypeParameterInstantiationBuilder;
-    tsTypeParameterInstantiation: TSTypeParameterInstantiationBuilder;
-    classImplements: ClassImplementsBuilder;
-    tsExpressionWithTypeArguments: TSExpressionWithTypeArgumentsBuilder;
-    anyTypeAnnotation: AnyTypeAnnotationBuilder;
-    emptyTypeAnnotation: EmptyTypeAnnotationBuilder;
-    mixedTypeAnnotation: MixedTypeAnnotationBuilder;
-    voidTypeAnnotation: VoidTypeAnnotationBuilder;
-    symbolTypeAnnotation: SymbolTypeAnnotationBuilder;
-    numberTypeAnnotation: NumberTypeAnnotationBuilder;
-    bigIntTypeAnnotation: BigIntTypeAnnotationBuilder;
-    numberLiteralTypeAnnotation: NumberLiteralTypeAnnotationBuilder;
-    numericLiteralTypeAnnotation: NumericLiteralTypeAnnotationBuilder;
-    bigIntLiteralTypeAnnotation: BigIntLiteralTypeAnnotationBuilder;
-    stringTypeAnnotation: StringTypeAnnotationBuilder;
-    stringLiteralTypeAnnotation: StringLiteralTypeAnnotationBuilder;
-    booleanTypeAnnotation: BooleanTypeAnnotationBuilder;
-    booleanLiteralTypeAnnotation: BooleanLiteralTypeAnnotationBuilder;
-    nullableTypeAnnotation: NullableTypeAnnotationBuilder;
-    nullLiteralTypeAnnotation: NullLiteralTypeAnnotationBuilder;
-    nullTypeAnnotation: NullTypeAnnotationBuilder;
-    thisTypeAnnotation: ThisTypeAnnotationBuilder;
-    existsTypeAnnotation: ExistsTypeAnnotationBuilder;
-    existentialTypeParam: ExistentialTypeParamBuilder;
-    functionTypeAnnotation: FunctionTypeAnnotationBuilder;
-    functionTypeParam: FunctionTypeParamBuilder;
-    arrayTypeAnnotation: ArrayTypeAnnotationBuilder;
-    objectTypeAnnotation: ObjectTypeAnnotationBuilder;
-    objectTypeProperty: ObjectTypePropertyBuilder;
-    objectTypeSpreadProperty: ObjectTypeSpreadPropertyBuilder;
-    objectTypeIndexer: ObjectTypeIndexerBuilder;
-    objectTypeCallProperty: ObjectTypeCallPropertyBuilder;
-    objectTypeInternalSlot: ObjectTypeInternalSlotBuilder;
-    variance: VarianceBuilder;
-    qualifiedTypeIdentifier: QualifiedTypeIdentifierBuilder;
-    genericTypeAnnotation: GenericTypeAnnotationBuilder;
-    memberTypeAnnotation: MemberTypeAnnotationBuilder;
-    indexedAccessType: IndexedAccessTypeBuilder;
-    optionalIndexedAccessType: OptionalIndexedAccessTypeBuilder;
-    unionTypeAnnotation: UnionTypeAnnotationBuilder;
-    intersectionTypeAnnotation: IntersectionTypeAnnotationBuilder;
-    typeofTypeAnnotation: TypeofTypeAnnotationBuilder;
-    typeParameter: TypeParameterBuilder;
-    interfaceTypeAnnotation: InterfaceTypeAnnotationBuilder;
-    interfaceExtends: InterfaceExtendsBuilder;
-    interfaceDeclaration: InterfaceDeclarationBuilder;
-    declareInterface: DeclareInterfaceBuilder;
-    typeAlias: TypeAliasBuilder;
-    declareTypeAlias: DeclareTypeAliasBuilder;
-    opaqueType: OpaqueTypeBuilder;
-    declareOpaqueType: DeclareOpaqueTypeBuilder;
-    typeCastExpression: TypeCastExpressionBuilder;
-    tupleTypeAnnotation: TupleTypeAnnotationBuilder;
-    declareVariable: DeclareVariableBuilder;
-    declareFunction: DeclareFunctionBuilder;
-    declareClass: DeclareClassBuilder;
-    declareModule: DeclareModuleBuilder;
-    declareModuleExports: DeclareModuleExportsBuilder;
-    declareExportDeclaration: DeclareExportDeclarationBuilder;
-    exportBatchSpecifier: ExportBatchSpecifierBuilder;
-    declareExportAllDeclaration: DeclareExportAllDeclarationBuilder;
-    inferredPredicate: InferredPredicateBuilder;
-    declaredPredicate: DeclaredPredicateBuilder;
-    enumDeclaration: EnumDeclarationBuilder;
-    enumBooleanBody: EnumBooleanBodyBuilder;
-    enumNumberBody: EnumNumberBodyBuilder;
-    enumStringBody: EnumStringBodyBuilder;
-    enumSymbolBody: EnumSymbolBodyBuilder;
-    enumBooleanMember: EnumBooleanMemberBuilder;
-    enumNumberMember: EnumNumberMemberBuilder;
-    enumStringMember: EnumStringMemberBuilder;
-    enumDefaultedMember: EnumDefaultedMemberBuilder;
-    exportDeclaration: ExportDeclarationBuilder;
-    block: BlockBuilder;
-    line: LineBuilder;
-    noop: NoopBuilder;
-    doExpression: DoExpressionBuilder;
-    bindExpression: BindExpressionBuilder;
-    parenthesizedExpression: ParenthesizedExpressionBuilder;
-    exportNamespaceSpecifier: ExportNamespaceSpecifierBuilder;
-    exportDefaultSpecifier: ExportDefaultSpecifierBuilder;
-    commentBlock: CommentBlockBuilder;
-    commentLine: CommentLineBuilder;
-    directive: DirectiveBuilder;
-    directiveLiteral: DirectiveLiteralBuilder;
-    interpreterDirective: InterpreterDirectiveBuilder;
-    stringLiteral: StringLiteralBuilder;
-    numericLiteral: NumericLiteralBuilder;
-    bigIntLiteral: BigIntLiteralBuilder;
-    decimalLiteral: DecimalLiteralBuilder;
-    nullLiteral: NullLiteralBuilder;
-    booleanLiteral: BooleanLiteralBuilder;
-    regExpLiteral: RegExpLiteralBuilder;
-    classMethod: ClassMethodBuilder;
-    classPrivateMethod: ClassPrivateMethodBuilder;
-    classAccessorProperty: ClassAccessorPropertyBuilder;
-    restProperty: RestPropertyBuilder;
-    forAwaitStatement: ForAwaitStatementBuilder;
-    import: ImportBuilder;
-    v8IntrinsicIdentifier: V8IntrinsicIdentifierBuilder;
-    topicReference: TopicReferenceBuilder;
-    tsQualifiedName: TSQualifiedNameBuilder;
-    tsTypeReference: TSTypeReferenceBuilder;
-    tsAsExpression: TSAsExpressionBuilder;
-    tsTypeCastExpression: TSTypeCastExpressionBuilder;
-    tsSatisfiesExpression: TSSatisfiesExpressionBuilder;
-    tsNonNullExpression: TSNonNullExpressionBuilder;
-    tsAnyKeyword: TSAnyKeywordBuilder;
-    tsBigIntKeyword: TSBigIntKeywordBuilder;
-    tsBooleanKeyword: TSBooleanKeywordBuilder;
-    tsNeverKeyword: TSNeverKeywordBuilder;
-    tsNullKeyword: TSNullKeywordBuilder;
-    tsNumberKeyword: TSNumberKeywordBuilder;
-    tsObjectKeyword: TSObjectKeywordBuilder;
-    tsStringKeyword: TSStringKeywordBuilder;
-    tsSymbolKeyword: TSSymbolKeywordBuilder;
-    tsUndefinedKeyword: TSUndefinedKeywordBuilder;
-    tsUnknownKeyword: TSUnknownKeywordBuilder;
-    tsVoidKeyword: TSVoidKeywordBuilder;
-    tsIntrinsicKeyword: TSIntrinsicKeywordBuilder;
-    tsThisType: TSThisTypeBuilder;
-    tsArrayType: TSArrayTypeBuilder;
-    tsLiteralType: TSLiteralTypeBuilder;
-    tsUnionType: TSUnionTypeBuilder;
-    tsIntersectionType: TSIntersectionTypeBuilder;
-    tsConditionalType: TSConditionalTypeBuilder;
-    tsInferType: TSInferTypeBuilder;
-    tsTypeParameter: TSTypeParameterBuilder;
-    tsParenthesizedType: TSParenthesizedTypeBuilder;
-    tsFunctionType: TSFunctionTypeBuilder;
-    tsConstructorType: TSConstructorTypeBuilder;
-    tsDeclareFunction: TSDeclareFunctionBuilder;
-    tsDeclareMethod: TSDeclareMethodBuilder;
-    tsMappedType: TSMappedTypeBuilder;
-    tsTupleType: TSTupleTypeBuilder;
-    tsNamedTupleMember: TSNamedTupleMemberBuilder;
-    tsRestType: TSRestTypeBuilder;
-    tsOptionalType: TSOptionalTypeBuilder;
-    tsIndexedAccessType: TSIndexedAccessTypeBuilder;
-    tsTypeOperator: TSTypeOperatorBuilder;
-    tsIndexSignature: TSIndexSignatureBuilder;
-    tsPropertySignature: TSPropertySignatureBuilder;
-    tsMethodSignature: TSMethodSignatureBuilder;
-    tsTypePredicate: TSTypePredicateBuilder;
-    tsCallSignatureDeclaration: TSCallSignatureDeclarationBuilder;
-    tsConstructSignatureDeclaration: TSConstructSignatureDeclarationBuilder;
-    tsEnumMember: TSEnumMemberBuilder;
-    tsTypeQuery: TSTypeQueryBuilder;
-    tsImportType: TSImportTypeBuilder;
-    tsTypeLiteral: TSTypeLiteralBuilder;
-    tsTypeAssertion: TSTypeAssertionBuilder;
-    tsInstantiationExpression: TSInstantiationExpressionBuilder;
-    tsEnumDeclaration: TSEnumDeclarationBuilder;
-    tsTypeAliasDeclaration: TSTypeAliasDeclarationBuilder;
-    tsModuleBlock: TSModuleBlockBuilder;
-    tsModuleDeclaration: TSModuleDeclarationBuilder;
-    tsImportEqualsDeclaration: TSImportEqualsDeclarationBuilder;
-    tsExternalModuleReference: TSExternalModuleReferenceBuilder;
-    tsExportAssignment: TSExportAssignmentBuilder;
-    tsNamespaceExportDeclaration: TSNamespaceExportDeclarationBuilder;
-    tsInterfaceBody: TSInterfaceBodyBuilder;
-    tsInterfaceDeclaration: TSInterfaceDeclarationBuilder;
-    tsParameterProperty: TSParameterPropertyBuilder;
-    [builderName: string]: any;
+  file: FileBuilder
+  program: ProgramBuilder
+  identifier: IdentifierBuilder
+  blockStatement: BlockStatementBuilder
+  emptyStatement: EmptyStatementBuilder
+  expressionStatement: ExpressionStatementBuilder
+  ifStatement: IfStatementBuilder
+  labeledStatement: LabeledStatementBuilder
+  breakStatement: BreakStatementBuilder
+  continueStatement: ContinueStatementBuilder
+  withStatement: WithStatementBuilder
+  switchStatement: SwitchStatementBuilder
+  switchCase: SwitchCaseBuilder
+  returnStatement: ReturnStatementBuilder
+  throwStatement: ThrowStatementBuilder
+  tryStatement: TryStatementBuilder
+  catchClause: CatchClauseBuilder
+  whileStatement: WhileStatementBuilder
+  doWhileStatement: DoWhileStatementBuilder
+  forStatement: ForStatementBuilder
+  variableDeclaration: VariableDeclarationBuilder
+  forInStatement: ForInStatementBuilder
+  debuggerStatement: DebuggerStatementBuilder
+  functionDeclaration: FunctionDeclarationBuilder
+  functionExpression: FunctionExpressionBuilder
+  variableDeclarator: VariableDeclaratorBuilder
+  thisExpression: ThisExpressionBuilder
+  arrayExpression: ArrayExpressionBuilder
+  objectExpression: ObjectExpressionBuilder
+  property: PropertyBuilder
+  literal: LiteralBuilder
+  sequenceExpression: SequenceExpressionBuilder
+  unaryExpression: UnaryExpressionBuilder
+  binaryExpression: BinaryExpressionBuilder
+  assignmentExpression: AssignmentExpressionBuilder
+  memberExpression: MemberExpressionBuilder
+  updateExpression: UpdateExpressionBuilder
+  logicalExpression: LogicalExpressionBuilder
+  conditionalExpression: ConditionalExpressionBuilder
+  newExpression: NewExpressionBuilder
+  callExpression: CallExpressionBuilder
+  restElement: RestElementBuilder
+  typeAnnotation: TypeAnnotationBuilder
+  tsTypeAnnotation: TSTypeAnnotationBuilder
+  spreadElementPattern: SpreadElementPatternBuilder
+  arrowFunctionExpression: ArrowFunctionExpressionBuilder
+  forOfStatement: ForOfStatementBuilder
+  yieldExpression: YieldExpressionBuilder
+  generatorExpression: GeneratorExpressionBuilder
+  comprehensionBlock: ComprehensionBlockBuilder
+  comprehensionExpression: ComprehensionExpressionBuilder
+  objectProperty: ObjectPropertyBuilder
+  propertyPattern: PropertyPatternBuilder
+  objectPattern: ObjectPatternBuilder
+  arrayPattern: ArrayPatternBuilder
+  spreadElement: SpreadElementBuilder
+  assignmentPattern: AssignmentPatternBuilder
+  methodDefinition: MethodDefinitionBuilder
+  classPropertyDefinition: ClassPropertyDefinitionBuilder
+  classProperty: ClassPropertyBuilder
+  staticBlock: StaticBlockBuilder
+  classBody: ClassBodyBuilder
+  classDeclaration: ClassDeclarationBuilder
+  classExpression: ClassExpressionBuilder
+  super: SuperBuilder
+  importSpecifier: ImportSpecifierBuilder
+  importDefaultSpecifier: ImportDefaultSpecifierBuilder
+  importNamespaceSpecifier: ImportNamespaceSpecifierBuilder
+  importDeclaration: ImportDeclarationBuilder
+  exportNamedDeclaration: ExportNamedDeclarationBuilder
+  exportSpecifier: ExportSpecifierBuilder
+  exportDefaultDeclaration: ExportDefaultDeclarationBuilder
+  exportAllDeclaration: ExportAllDeclarationBuilder
+  taggedTemplateExpression: TaggedTemplateExpressionBuilder
+  templateLiteral: TemplateLiteralBuilder
+  templateElement: TemplateElementBuilder
+  metaProperty: MetaPropertyBuilder
+  awaitExpression: AwaitExpressionBuilder
+  spreadProperty: SpreadPropertyBuilder
+  spreadPropertyPattern: SpreadPropertyPatternBuilder
+  importExpression: ImportExpressionBuilder
+  chainExpression: ChainExpressionBuilder
+  optionalCallExpression: OptionalCallExpressionBuilder
+  optionalMemberExpression: OptionalMemberExpressionBuilder
+  decorator: DecoratorBuilder
+  privateName: PrivateNameBuilder
+  classPrivateProperty: ClassPrivatePropertyBuilder
+  importAttribute: ImportAttributeBuilder
+  recordExpression: RecordExpressionBuilder
+  objectMethod: ObjectMethodBuilder
+  tupleExpression: TupleExpressionBuilder
+  moduleExpression: ModuleExpressionBuilder
+  jsxAttribute: JSXAttributeBuilder
+  jsxIdentifier: JSXIdentifierBuilder
+  jsxNamespacedName: JSXNamespacedNameBuilder
+  jsxExpressionContainer: JSXExpressionContainerBuilder
+  jsxElement: JSXElementBuilder
+  jsxFragment: JSXFragmentBuilder
+  jsxMemberExpression: JSXMemberExpressionBuilder
+  jsxSpreadAttribute: JSXSpreadAttributeBuilder
+  jsxEmptyExpression: JSXEmptyExpressionBuilder
+  jsxText: JSXTextBuilder
+  jsxSpreadChild: JSXSpreadChildBuilder
+  jsxOpeningElement: JSXOpeningElementBuilder
+  jsxClosingElement: JSXClosingElementBuilder
+  jsxOpeningFragment: JSXOpeningFragmentBuilder
+  jsxClosingFragment: JSXClosingFragmentBuilder
+  typeParameterDeclaration: TypeParameterDeclarationBuilder
+  tsTypeParameterDeclaration: TSTypeParameterDeclarationBuilder
+  typeParameterInstantiation: TypeParameterInstantiationBuilder
+  tsTypeParameterInstantiation: TSTypeParameterInstantiationBuilder
+  classImplements: ClassImplementsBuilder
+  tsExpressionWithTypeArguments: TSExpressionWithTypeArgumentsBuilder
+  anyTypeAnnotation: AnyTypeAnnotationBuilder
+  emptyTypeAnnotation: EmptyTypeAnnotationBuilder
+  mixedTypeAnnotation: MixedTypeAnnotationBuilder
+  voidTypeAnnotation: VoidTypeAnnotationBuilder
+  symbolTypeAnnotation: SymbolTypeAnnotationBuilder
+  numberTypeAnnotation: NumberTypeAnnotationBuilder
+  bigIntTypeAnnotation: BigIntTypeAnnotationBuilder
+  numberLiteralTypeAnnotation: NumberLiteralTypeAnnotationBuilder
+  numericLiteralTypeAnnotation: NumericLiteralTypeAnnotationBuilder
+  bigIntLiteralTypeAnnotation: BigIntLiteralTypeAnnotationBuilder
+  stringTypeAnnotation: StringTypeAnnotationBuilder
+  stringLiteralTypeAnnotation: StringLiteralTypeAnnotationBuilder
+  booleanTypeAnnotation: BooleanTypeAnnotationBuilder
+  booleanLiteralTypeAnnotation: BooleanLiteralTypeAnnotationBuilder
+  nullableTypeAnnotation: NullableTypeAnnotationBuilder
+  nullLiteralTypeAnnotation: NullLiteralTypeAnnotationBuilder
+  nullTypeAnnotation: NullTypeAnnotationBuilder
+  thisTypeAnnotation: ThisTypeAnnotationBuilder
+  existsTypeAnnotation: ExistsTypeAnnotationBuilder
+  existentialTypeParam: ExistentialTypeParamBuilder
+  functionTypeAnnotation: FunctionTypeAnnotationBuilder
+  functionTypeParam: FunctionTypeParamBuilder
+  arrayTypeAnnotation: ArrayTypeAnnotationBuilder
+  objectTypeAnnotation: ObjectTypeAnnotationBuilder
+  objectTypeProperty: ObjectTypePropertyBuilder
+  objectTypeSpreadProperty: ObjectTypeSpreadPropertyBuilder
+  objectTypeIndexer: ObjectTypeIndexerBuilder
+  objectTypeCallProperty: ObjectTypeCallPropertyBuilder
+  objectTypeInternalSlot: ObjectTypeInternalSlotBuilder
+  variance: VarianceBuilder
+  qualifiedTypeIdentifier: QualifiedTypeIdentifierBuilder
+  genericTypeAnnotation: GenericTypeAnnotationBuilder
+  memberTypeAnnotation: MemberTypeAnnotationBuilder
+  indexedAccessType: IndexedAccessTypeBuilder
+  optionalIndexedAccessType: OptionalIndexedAccessTypeBuilder
+  unionTypeAnnotation: UnionTypeAnnotationBuilder
+  intersectionTypeAnnotation: IntersectionTypeAnnotationBuilder
+  typeofTypeAnnotation: TypeofTypeAnnotationBuilder
+  typeParameter: TypeParameterBuilder
+  interfaceTypeAnnotation: InterfaceTypeAnnotationBuilder
+  interfaceExtends: InterfaceExtendsBuilder
+  interfaceDeclaration: InterfaceDeclarationBuilder
+  declareInterface: DeclareInterfaceBuilder
+  typeAlias: TypeAliasBuilder
+  declareTypeAlias: DeclareTypeAliasBuilder
+  opaqueType: OpaqueTypeBuilder
+  declareOpaqueType: DeclareOpaqueTypeBuilder
+  typeCastExpression: TypeCastExpressionBuilder
+  tupleTypeAnnotation: TupleTypeAnnotationBuilder
+  declareVariable: DeclareVariableBuilder
+  declareFunction: DeclareFunctionBuilder
+  declareClass: DeclareClassBuilder
+  declareModule: DeclareModuleBuilder
+  declareModuleExports: DeclareModuleExportsBuilder
+  declareExportDeclaration: DeclareExportDeclarationBuilder
+  exportBatchSpecifier: ExportBatchSpecifierBuilder
+  declareExportAllDeclaration: DeclareExportAllDeclarationBuilder
+  inferredPredicate: InferredPredicateBuilder
+  declaredPredicate: DeclaredPredicateBuilder
+  enumDeclaration: EnumDeclarationBuilder
+  enumBooleanBody: EnumBooleanBodyBuilder
+  enumNumberBody: EnumNumberBodyBuilder
+  enumStringBody: EnumStringBodyBuilder
+  enumSymbolBody: EnumSymbolBodyBuilder
+  enumBooleanMember: EnumBooleanMemberBuilder
+  enumNumberMember: EnumNumberMemberBuilder
+  enumStringMember: EnumStringMemberBuilder
+  enumDefaultedMember: EnumDefaultedMemberBuilder
+  exportDeclaration: ExportDeclarationBuilder
+  block: BlockBuilder
+  line: LineBuilder
+  noop: NoopBuilder
+  doExpression: DoExpressionBuilder
+  bindExpression: BindExpressionBuilder
+  parenthesizedExpression: ParenthesizedExpressionBuilder
+  exportNamespaceSpecifier: ExportNamespaceSpecifierBuilder
+  exportDefaultSpecifier: ExportDefaultSpecifierBuilder
+  commentBlock: CommentBlockBuilder
+  commentLine: CommentLineBuilder
+  directive: DirectiveBuilder
+  directiveLiteral: DirectiveLiteralBuilder
+  interpreterDirective: InterpreterDirectiveBuilder
+  stringLiteral: StringLiteralBuilder
+  numericLiteral: NumericLiteralBuilder
+  bigIntLiteral: BigIntLiteralBuilder
+  decimalLiteral: DecimalLiteralBuilder
+  nullLiteral: NullLiteralBuilder
+  booleanLiteral: BooleanLiteralBuilder
+  regExpLiteral: RegExpLiteralBuilder
+  classMethod: ClassMethodBuilder
+  classPrivateMethod: ClassPrivateMethodBuilder
+  classAccessorProperty: ClassAccessorPropertyBuilder
+  restProperty: RestPropertyBuilder
+  forAwaitStatement: ForAwaitStatementBuilder
+  import: ImportBuilder
+  v8IntrinsicIdentifier: V8IntrinsicIdentifierBuilder
+  topicReference: TopicReferenceBuilder
+  tsQualifiedName: TSQualifiedNameBuilder
+  tsTypeReference: TSTypeReferenceBuilder
+  tsAsExpression: TSAsExpressionBuilder
+  tsTypeCastExpression: TSTypeCastExpressionBuilder
+  tsSatisfiesExpression: TSSatisfiesExpressionBuilder
+  tsNonNullExpression: TSNonNullExpressionBuilder
+  tsAnyKeyword: TSAnyKeywordBuilder
+  tsBigIntKeyword: TSBigIntKeywordBuilder
+  tsBooleanKeyword: TSBooleanKeywordBuilder
+  tsNeverKeyword: TSNeverKeywordBuilder
+  tsNullKeyword: TSNullKeywordBuilder
+  tsNumberKeyword: TSNumberKeywordBuilder
+  tsObjectKeyword: TSObjectKeywordBuilder
+  tsStringKeyword: TSStringKeywordBuilder
+  tsSymbolKeyword: TSSymbolKeywordBuilder
+  tsUndefinedKeyword: TSUndefinedKeywordBuilder
+  tsUnknownKeyword: TSUnknownKeywordBuilder
+  tsVoidKeyword: TSVoidKeywordBuilder
+  tsIntrinsicKeyword: TSIntrinsicKeywordBuilder
+  tsThisType: TSThisTypeBuilder
+  tsArrayType: TSArrayTypeBuilder
+  tsLiteralType: TSLiteralTypeBuilder
+  tsUnionType: TSUnionTypeBuilder
+  tsIntersectionType: TSIntersectionTypeBuilder
+  tsConditionalType: TSConditionalTypeBuilder
+  tsInferType: TSInferTypeBuilder
+  tsTypeParameter: TSTypeParameterBuilder
+  tsParenthesizedType: TSParenthesizedTypeBuilder
+  tsFunctionType: TSFunctionTypeBuilder
+  tsConstructorType: TSConstructorTypeBuilder
+  tsDeclareFunction: TSDeclareFunctionBuilder
+  tsDeclareMethod: TSDeclareMethodBuilder
+  tsMappedType: TSMappedTypeBuilder
+  tsTupleType: TSTupleTypeBuilder
+  tsNamedTupleMember: TSNamedTupleMemberBuilder
+  tsRestType: TSRestTypeBuilder
+  tsOptionalType: TSOptionalTypeBuilder
+  tsIndexedAccessType: TSIndexedAccessTypeBuilder
+  tsTypeOperator: TSTypeOperatorBuilder
+  tsIndexSignature: TSIndexSignatureBuilder
+  tsPropertySignature: TSPropertySignatureBuilder
+  tsMethodSignature: TSMethodSignatureBuilder
+  tsTypePredicate: TSTypePredicateBuilder
+  tsCallSignatureDeclaration: TSCallSignatureDeclarationBuilder
+  tsConstructSignatureDeclaration: TSConstructSignatureDeclarationBuilder
+  tsEnumMember: TSEnumMemberBuilder
+  tsTypeQuery: TSTypeQueryBuilder
+  tsImportType: TSImportTypeBuilder
+  tsTypeLiteral: TSTypeLiteralBuilder
+  tsTypeAssertion: TSTypeAssertionBuilder
+  tsInstantiationExpression: TSInstantiationExpressionBuilder
+  tsEnumDeclaration: TSEnumDeclarationBuilder
+  tsTypeAliasDeclaration: TSTypeAliasDeclarationBuilder
+  tsModuleBlock: TSModuleBlockBuilder
+  tsModuleDeclaration: TSModuleDeclarationBuilder
+  tsImportEqualsDeclaration: TSImportEqualsDeclarationBuilder
+  tsExternalModuleReference: TSExternalModuleReferenceBuilder
+  tsExportAssignment: TSExportAssignmentBuilder
+  tsNamespaceExportDeclaration: TSNamespaceExportDeclarationBuilder
+  tsInterfaceBody: TSInterfaceBodyBuilder
+  tsInterfaceDeclaration: TSInterfaceDeclarationBuilder
+  tsParameterProperty: TSParameterPropertyBuilder
+  [builderName: string]: any
 }
diff --git a/lib/gen/namedTypes.d.ts b/lib/gen/namedTypes.d.ts
index 4cac31f492dce394984f80f6f308dd6953002966..41f495b5025ffc0410413e9822d0cad64dcb631b 100644
--- a/lib/gen/namedTypes.d.ts
+++ b/lib/gen/namedTypes.d.ts
@@ -1,2029 +1,2558 @@
-import { Type, Omit } from "../types";
-import * as K from "./kinds";
+import { Type, Omit } from '../types'
+import * as K from './kinds'
 export declare namespace namedTypes {
-    interface Printable {
-        loc?: K.SourceLocationKind | null;
-    }
-    interface SourceLocation {
-        start: K.PositionKind;
-        end: K.PositionKind;
-        source?: string | null;
-    }
-    interface Node extends Printable {
-        type: string;
-        comments?: K.CommentKind[] | null;
-    }
-    interface Comment extends Printable {
-        value: string;
-        leading?: boolean;
-        trailing?: boolean;
-    }
-    interface Position {
-        line: number;
-        column: number;
-    }
-    interface File extends Omit<Node, "type"> {
-        type: "File";
-        program: K.ProgramKind;
-        name?: string | null;
-    }
-    interface Program extends Omit<Node, "type"> {
-        type: "Program";
-        body: K.StatementKind[];
-        directives?: K.DirectiveKind[];
-        interpreter?: K.InterpreterDirectiveKind | null;
-    }
-    interface Statement extends Node {
-    }
-    interface Function extends Node {
-        id?: K.IdentifierKind | null;
-        params: K.PatternKind[];
-        body: K.BlockStatementKind;
-        generator?: boolean;
-        async?: boolean;
-        expression?: boolean;
-        defaults?: (K.ExpressionKind | null)[];
-        rest?: K.IdentifierKind | null;
-        returnType?: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null;
-        typeParameters?: K.TypeParameterDeclarationKind | K.TSTypeParameterDeclarationKind | null;
-        predicate?: K.FlowPredicateKind | null;
-    }
-    interface Expression extends Node {
-    }
-    interface Pattern extends Node {
-    }
-    interface Identifier extends Omit<Expression, "type">, Omit<Pattern, "type"> {
-        type: "Identifier";
-        name: string;
-        optional?: boolean;
-        typeAnnotation?: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null;
-    }
-    interface BlockStatement extends Omit<Statement, "type"> {
-        type: "BlockStatement";
-        body: K.StatementKind[];
-        directives?: K.DirectiveKind[];
-    }
-    interface EmptyStatement extends Omit<Statement, "type"> {
-        type: "EmptyStatement";
-    }
-    interface ExpressionStatement extends Omit<Statement, "type"> {
-        type: "ExpressionStatement";
-        expression: K.ExpressionKind;
-    }
-    interface IfStatement extends Omit<Statement, "type"> {
-        type: "IfStatement";
-        test: K.ExpressionKind;
-        consequent: K.StatementKind;
-        alternate?: K.StatementKind | null;
-    }
-    interface LabeledStatement extends Omit<Statement, "type"> {
-        type: "LabeledStatement";
-        label: K.IdentifierKind;
-        body: K.StatementKind;
-    }
-    interface BreakStatement extends Omit<Statement, "type"> {
-        type: "BreakStatement";
-        label?: K.IdentifierKind | null;
-    }
-    interface ContinueStatement extends Omit<Statement, "type"> {
-        type: "ContinueStatement";
-        label?: K.IdentifierKind | null;
-    }
-    interface WithStatement extends Omit<Statement, "type"> {
-        type: "WithStatement";
-        object: K.ExpressionKind;
-        body: K.StatementKind;
-    }
-    interface SwitchStatement extends Omit<Statement, "type"> {
-        type: "SwitchStatement";
-        discriminant: K.ExpressionKind;
-        cases: K.SwitchCaseKind[];
-        lexical?: boolean;
-    }
-    interface SwitchCase extends Omit<Node, "type"> {
-        type: "SwitchCase";
-        test: K.ExpressionKind | null;
-        consequent: K.StatementKind[];
-    }
-    interface ReturnStatement extends Omit<Statement, "type"> {
-        type: "ReturnStatement";
-        argument: K.ExpressionKind | null;
-    }
-    interface ThrowStatement extends Omit<Statement, "type"> {
-        type: "ThrowStatement";
-        argument: K.ExpressionKind;
-    }
-    interface TryStatement extends Omit<Statement, "type"> {
-        type: "TryStatement";
-        block: K.BlockStatementKind;
-        handler?: K.CatchClauseKind | null;
-        handlers?: K.CatchClauseKind[];
-        guardedHandlers?: K.CatchClauseKind[];
-        finalizer?: K.BlockStatementKind | null;
-    }
-    interface CatchClause extends Omit<Node, "type"> {
-        type: "CatchClause";
-        param?: K.PatternKind | null;
-        guard?: K.ExpressionKind | null;
-        body: K.BlockStatementKind;
-    }
-    interface WhileStatement extends Omit<Statement, "type"> {
-        type: "WhileStatement";
-        test: K.ExpressionKind;
-        body: K.StatementKind;
-    }
-    interface DoWhileStatement extends Omit<Statement, "type"> {
-        type: "DoWhileStatement";
-        body: K.StatementKind;
-        test: K.ExpressionKind;
-    }
-    interface ForStatement extends Omit<Statement, "type"> {
-        type: "ForStatement";
-        init: K.VariableDeclarationKind | K.ExpressionKind | null;
-        test: K.ExpressionKind | null;
-        update: K.ExpressionKind | null;
-        body: K.StatementKind;
-    }
-    interface Declaration extends Statement {
-    }
-    interface VariableDeclaration extends Omit<Declaration, "type"> {
-        type: "VariableDeclaration";
-        kind: "var" | "let" | "const";
-        declarations: (K.VariableDeclaratorKind | K.IdentifierKind)[];
-    }
-    interface ForInStatement extends Omit<Statement, "type"> {
-        type: "ForInStatement";
-        left: K.VariableDeclarationKind | K.ExpressionKind;
-        right: K.ExpressionKind;
-        body: K.StatementKind;
-    }
-    interface DebuggerStatement extends Omit<Statement, "type"> {
-        type: "DebuggerStatement";
-    }
-    interface FunctionDeclaration extends Omit<Function, "type" | "id">, Omit<Declaration, "type"> {
-        type: "FunctionDeclaration";
-        id: K.IdentifierKind | null;
-    }
-    interface FunctionExpression extends Omit<Function, "type">, Omit<Expression, "type"> {
-        type: "FunctionExpression";
-    }
-    interface VariableDeclarator extends Omit<Node, "type"> {
-        type: "VariableDeclarator";
-        id: K.PatternKind;
-        init?: K.ExpressionKind | null;
-    }
-    interface ThisExpression extends Omit<Expression, "type"> {
-        type: "ThisExpression";
-    }
-    interface ArrayExpression extends Omit<Expression, "type"> {
-        type: "ArrayExpression";
-        elements: (K.ExpressionKind | K.SpreadElementKind | K.RestElementKind | null)[];
-    }
-    interface ObjectExpression extends Omit<Expression, "type"> {
-        type: "ObjectExpression";
-        properties: (K.PropertyKind | K.ObjectMethodKind | K.ObjectPropertyKind | K.SpreadPropertyKind | K.SpreadElementKind)[];
-    }
-    interface Property extends Omit<Node, "type"> {
-        type: "Property";
-        kind: "init" | "get" | "set";
-        key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind;
-        value: K.ExpressionKind | K.PatternKind;
-        method?: boolean;
-        shorthand?: boolean;
-        computed?: boolean;
-        decorators?: K.DecoratorKind[] | null;
-    }
-    interface Literal extends Omit<Expression, "type"> {
-        type: "Literal";
-        value: string | boolean | null | number | RegExp | BigInt;
-    }
-    interface SequenceExpression extends Omit<Expression, "type"> {
-        type: "SequenceExpression";
-        expressions: K.ExpressionKind[];
-    }
-    interface UnaryExpression extends Omit<Expression, "type"> {
-        type: "UnaryExpression";
-        operator: "-" | "+" | "!" | "~" | "typeof" | "void" | "delete";
-        argument: K.ExpressionKind;
-        prefix?: boolean;
-    }
-    interface BinaryExpression extends Omit<Expression, "type"> {
-        type: "BinaryExpression";
-        operator: "==" | "!=" | "===" | "!==" | "<" | "<=" | ">" | ">=" | "<<" | ">>" | ">>>" | "+" | "-" | "*" | "/" | "%" | "&" | "|" | "^" | "in" | "instanceof" | "**";
-        left: K.ExpressionKind;
-        right: K.ExpressionKind;
-    }
-    interface AssignmentExpression extends Omit<Expression, "type"> {
-        type: "AssignmentExpression";
-        operator: "=" | "+=" | "-=" | "*=" | "/=" | "%=" | "<<=" | ">>=" | ">>>=" | "|=" | "^=" | "&=" | "**=" | "||=" | "&&=" | "??=";
-        left: K.PatternKind | K.MemberExpressionKind;
-        right: K.ExpressionKind;
-    }
-    interface ChainElement extends Node {
-        optional?: boolean;
-    }
-    interface MemberExpression extends Omit<Expression, "type">, Omit<ChainElement, "type"> {
-        type: "MemberExpression";
-        object: K.ExpressionKind;
-        property: K.IdentifierKind | K.ExpressionKind;
-        computed?: boolean;
-    }
-    interface UpdateExpression extends Omit<Expression, "type"> {
-        type: "UpdateExpression";
-        operator: "++" | "--";
-        argument: K.ExpressionKind;
-        prefix: boolean;
-    }
-    interface LogicalExpression extends Omit<Expression, "type"> {
-        type: "LogicalExpression";
-        operator: "||" | "&&" | "??";
-        left: K.ExpressionKind;
-        right: K.ExpressionKind;
-    }
-    interface ConditionalExpression extends Omit<Expression, "type"> {
-        type: "ConditionalExpression";
-        test: K.ExpressionKind;
-        consequent: K.ExpressionKind;
-        alternate: K.ExpressionKind;
-    }
-    interface NewExpression extends Omit<Expression, "type"> {
-        type: "NewExpression";
-        callee: K.ExpressionKind;
-        arguments: (K.ExpressionKind | K.SpreadElementKind)[];
-        typeArguments?: null | K.TypeParameterInstantiationKind;
-    }
-    interface CallExpression extends Omit<Expression, "type">, Omit<ChainElement, "type"> {
-        type: "CallExpression";
-        callee: K.ExpressionKind;
-        arguments: (K.ExpressionKind | K.SpreadElementKind)[];
-        typeArguments?: null | K.TypeParameterInstantiationKind;
-    }
-    interface RestElement extends Omit<Pattern, "type"> {
-        type: "RestElement";
-        argument: K.PatternKind;
-        typeAnnotation?: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null;
-    }
-    interface TypeAnnotation extends Omit<Node, "type"> {
-        type: "TypeAnnotation";
-        typeAnnotation: K.FlowTypeKind;
-    }
-    interface TSTypeAnnotation extends Omit<Node, "type"> {
-        type: "TSTypeAnnotation";
-        typeAnnotation: K.TSTypeKind | K.TSTypeAnnotationKind;
-    }
-    interface SpreadElementPattern extends Omit<Pattern, "type"> {
-        type: "SpreadElementPattern";
-        argument: K.PatternKind;
-    }
-    interface ArrowFunctionExpression extends Omit<Function, "type" | "id" | "body" | "generator">, Omit<Expression, "type"> {
-        type: "ArrowFunctionExpression";
-        id?: null;
-        body: K.BlockStatementKind | K.ExpressionKind;
-        generator?: false;
-    }
-    interface ForOfStatement extends Omit<Statement, "type"> {
-        type: "ForOfStatement";
-        left: K.VariableDeclarationKind | K.PatternKind;
-        right: K.ExpressionKind;
-        body: K.StatementKind;
-        await?: boolean;
-    }
-    interface YieldExpression extends Omit<Expression, "type"> {
-        type: "YieldExpression";
-        argument: K.ExpressionKind | null;
-        delegate?: boolean;
-    }
-    interface GeneratorExpression extends Omit<Expression, "type"> {
-        type: "GeneratorExpression";
-        body: K.ExpressionKind;
-        blocks: K.ComprehensionBlockKind[];
-        filter: K.ExpressionKind | null;
-    }
-    interface ComprehensionBlock extends Omit<Node, "type"> {
-        type: "ComprehensionBlock";
-        left: K.PatternKind;
-        right: K.ExpressionKind;
-        each: boolean;
-    }
-    interface ComprehensionExpression extends Omit<Expression, "type"> {
-        type: "ComprehensionExpression";
-        body: K.ExpressionKind;
-        blocks: K.ComprehensionBlockKind[];
-        filter: K.ExpressionKind | null;
-    }
-    interface ObjectProperty extends Omit<Node, "type"> {
-        shorthand?: boolean;
-        type: "ObjectProperty";
-        key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind;
-        value: K.ExpressionKind | K.PatternKind;
-        accessibility?: K.LiteralKind | null;
-        computed?: boolean;
-    }
-    interface PropertyPattern extends Omit<Pattern, "type"> {
-        type: "PropertyPattern";
-        key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind;
-        pattern: K.PatternKind;
-        computed?: boolean;
-    }
-    interface ObjectPattern extends Omit<Pattern, "type"> {
-        type: "ObjectPattern";
-        properties: (K.PropertyKind | K.PropertyPatternKind | K.SpreadPropertyPatternKind | K.SpreadPropertyKind | K.ObjectPropertyKind | K.RestPropertyKind | K.RestElementKind)[];
-        typeAnnotation?: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null;
-        decorators?: K.DecoratorKind[] | null;
-    }
-    interface ArrayPattern extends Omit<Pattern, "type"> {
-        type: "ArrayPattern";
-        elements: (K.PatternKind | K.SpreadElementKind | null)[];
-    }
-    interface SpreadElement extends Omit<Node, "type"> {
-        type: "SpreadElement";
-        argument: K.ExpressionKind;
-    }
-    interface AssignmentPattern extends Omit<Pattern, "type"> {
-        type: "AssignmentPattern";
-        left: K.PatternKind;
-        right: K.ExpressionKind;
-    }
-    interface MethodDefinition extends Omit<Declaration, "type"> {
-        type: "MethodDefinition";
-        kind: "constructor" | "method" | "get" | "set";
-        key: K.ExpressionKind;
-        value: K.FunctionKind;
-        computed?: boolean;
-        static?: boolean;
-        decorators?: K.DecoratorKind[] | null;
-    }
-    interface ClassPropertyDefinition extends Omit<Declaration, "type"> {
-        type: "ClassPropertyDefinition";
-        definition: K.MethodDefinitionKind | K.VariableDeclaratorKind | K.ClassPropertyDefinitionKind | K.ClassPropertyKind | K.StaticBlockKind;
-    }
-    interface ClassProperty extends Omit<Declaration, "type"> {
-        type: "ClassProperty";
-        key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind;
-        computed?: boolean;
-        value: K.ExpressionKind | null;
-        static?: boolean;
-        typeAnnotation?: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null;
-        variance?: K.VarianceKind | "plus" | "minus" | null;
-        access?: "public" | "private" | "protected" | undefined;
-    }
-    interface StaticBlock extends Omit<Declaration, "type"> {
-        type: "StaticBlock";
-        body: K.StatementKind[];
-    }
-    interface ClassBody extends Omit<Declaration, "type"> {
-        type: "ClassBody";
-        body: (K.MethodDefinitionKind | K.VariableDeclaratorKind | K.ClassPropertyDefinitionKind | K.ClassPropertyKind | K.ClassPrivatePropertyKind | K.ClassAccessorPropertyKind | K.ClassMethodKind | K.ClassPrivateMethodKind | K.StaticBlockKind | K.TSDeclareMethodKind | K.TSCallSignatureDeclarationKind | K.TSConstructSignatureDeclarationKind | K.TSIndexSignatureKind | K.TSMethodSignatureKind | K.TSPropertySignatureKind)[];
-    }
-    interface ClassDeclaration extends Omit<Declaration, "type"> {
-        type: "ClassDeclaration";
-        id: K.IdentifierKind | null;
-        body: K.ClassBodyKind;
-        superClass?: K.ExpressionKind | null;
-        typeParameters?: K.TypeParameterDeclarationKind | K.TSTypeParameterDeclarationKind | null;
-        superTypeParameters?: K.TypeParameterInstantiationKind | K.TSTypeParameterInstantiationKind | null;
-        implements?: K.ClassImplementsKind[] | K.TSExpressionWithTypeArgumentsKind[];
-    }
-    interface ClassExpression extends Omit<Expression, "type"> {
-        type: "ClassExpression";
-        id?: K.IdentifierKind | null;
-        body: K.ClassBodyKind;
-        superClass?: K.ExpressionKind | null;
-        typeParameters?: K.TypeParameterDeclarationKind | K.TSTypeParameterDeclarationKind | null;
-        superTypeParameters?: K.TypeParameterInstantiationKind | K.TSTypeParameterInstantiationKind | null;
-        implements?: K.ClassImplementsKind[] | K.TSExpressionWithTypeArgumentsKind[];
-    }
-    interface Super extends Omit<Expression, "type"> {
-        type: "Super";
-    }
-    interface Specifier extends Node {
-    }
-    interface ModuleSpecifier extends Specifier {
-        local?: K.IdentifierKind | null;
-        id?: K.IdentifierKind | null;
-        name?: K.IdentifierKind | null;
-    }
-    interface ImportSpecifier extends Omit<ModuleSpecifier, "type"> {
-        type: "ImportSpecifier";
-        imported: K.IdentifierKind;
-    }
-    interface ImportDefaultSpecifier extends Omit<ModuleSpecifier, "type"> {
-        type: "ImportDefaultSpecifier";
-    }
-    interface ImportNamespaceSpecifier extends Omit<ModuleSpecifier, "type"> {
-        type: "ImportNamespaceSpecifier";
-    }
-    interface ImportDeclaration extends Omit<Declaration, "type"> {
-        type: "ImportDeclaration";
-        specifiers?: (K.ImportSpecifierKind | K.ImportNamespaceSpecifierKind | K.ImportDefaultSpecifierKind)[];
-        source: K.LiteralKind;
-        importKind?: "value" | "type" | "typeof";
-        assertions?: K.ImportAttributeKind[];
-    }
-    interface ExportNamedDeclaration extends Omit<Declaration, "type"> {
-        type: "ExportNamedDeclaration";
-        declaration: K.DeclarationKind | null;
-        specifiers?: K.ExportSpecifierKind[];
-        source?: K.LiteralKind | null;
-        assertions?: K.ImportAttributeKind[];
-    }
-    interface ExportSpecifier extends Omit<ModuleSpecifier, "type"> {
-        type: "ExportSpecifier";
-        exported: K.IdentifierKind;
-    }
-    interface ExportDefaultDeclaration extends Omit<Declaration, "type"> {
-        type: "ExportDefaultDeclaration";
-        declaration: K.DeclarationKind | K.ExpressionKind;
-    }
-    interface ExportAllDeclaration extends Omit<Declaration, "type"> {
-        type: "ExportAllDeclaration";
-        source: K.LiteralKind;
-        exported?: K.IdentifierKind | null | undefined;
-        assertions?: K.ImportAttributeKind[];
-    }
-    interface TaggedTemplateExpression extends Omit<Expression, "type"> {
-        type: "TaggedTemplateExpression";
-        tag: K.ExpressionKind;
-        quasi: K.TemplateLiteralKind;
-    }
-    interface TemplateLiteral extends Omit<Expression, "type"> {
-        type: "TemplateLiteral";
-        quasis: K.TemplateElementKind[];
-        expressions: K.ExpressionKind[] | K.TSTypeKind[];
-    }
-    interface TemplateElement extends Omit<Node, "type"> {
-        type: "TemplateElement";
-        value: {
-            cooked: string | null;
-            raw: string;
-        };
-        tail: boolean;
-    }
-    interface MetaProperty extends Omit<Expression, "type"> {
-        type: "MetaProperty";
-        meta: K.IdentifierKind;
-        property: K.IdentifierKind;
-    }
-    interface AwaitExpression extends Omit<Expression, "type"> {
-        type: "AwaitExpression";
-        argument: K.ExpressionKind | null;
-        all?: boolean;
-    }
-    interface SpreadProperty extends Omit<Node, "type"> {
-        type: "SpreadProperty";
-        argument: K.ExpressionKind;
-    }
-    interface SpreadPropertyPattern extends Omit<Pattern, "type"> {
-        type: "SpreadPropertyPattern";
-        argument: K.PatternKind;
-    }
-    interface ImportExpression extends Omit<Expression, "type"> {
-        type: "ImportExpression";
-        source: K.ExpressionKind;
-    }
-    interface ChainExpression extends Omit<Expression, "type"> {
-        type: "ChainExpression";
-        expression: K.ChainElementKind;
-    }
-    interface OptionalCallExpression extends Omit<CallExpression, "type" | "optional"> {
-        type: "OptionalCallExpression";
-        optional?: boolean;
-    }
-    interface OptionalMemberExpression extends Omit<MemberExpression, "type" | "optional"> {
-        type: "OptionalMemberExpression";
-        optional?: boolean;
-    }
-    interface Decorator extends Omit<Node, "type"> {
-        type: "Decorator";
-        expression: K.ExpressionKind;
-    }
-    interface PrivateName extends Omit<Expression, "type">, Omit<Pattern, "type"> {
-        type: "PrivateName";
-        id: K.IdentifierKind;
-    }
-    interface ClassPrivateProperty extends Omit<ClassProperty, "type" | "key" | "value"> {
-        type: "ClassPrivateProperty";
-        key: K.PrivateNameKind;
-        value?: K.ExpressionKind | null;
-    }
-    interface ImportAttribute extends Omit<Node, "type"> {
-        type: "ImportAttribute";
-        key: K.IdentifierKind | K.LiteralKind;
-        value: K.ExpressionKind;
-    }
-    interface RecordExpression extends Omit<Expression, "type"> {
-        type: "RecordExpression";
-        properties: (K.ObjectPropertyKind | K.ObjectMethodKind | K.SpreadElementKind)[];
-    }
-    interface ObjectMethod extends Omit<Node, "type">, Omit<Function, "type" | "params" | "body" | "generator" | "async"> {
-        type: "ObjectMethod";
-        kind: "method" | "get" | "set";
-        key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind;
-        params: K.PatternKind[];
-        body: K.BlockStatementKind;
-        computed?: boolean;
-        generator?: boolean;
-        async?: boolean;
-        accessibility?: K.LiteralKind | null;
-        decorators?: K.DecoratorKind[] | null;
-    }
-    interface TupleExpression extends Omit<Expression, "type"> {
-        type: "TupleExpression";
-        elements: (K.ExpressionKind | K.SpreadElementKind | null)[];
-    }
-    interface ModuleExpression extends Omit<Node, "type"> {
-        type: "ModuleExpression";
-        body: K.ProgramKind;
-    }
-    interface JSXAttribute extends Omit<Node, "type"> {
-        type: "JSXAttribute";
-        name: K.JSXIdentifierKind | K.JSXNamespacedNameKind;
-        value?: K.LiteralKind | K.JSXExpressionContainerKind | K.JSXElementKind | K.JSXFragmentKind | null;
-    }
-    interface JSXIdentifier extends Omit<Identifier, "type" | "name"> {
-        type: "JSXIdentifier";
-        name: string;
-    }
-    interface JSXNamespacedName extends Omit<Node, "type"> {
-        type: "JSXNamespacedName";
-        namespace: K.JSXIdentifierKind;
-        name: K.JSXIdentifierKind;
-    }
-    interface JSXExpressionContainer extends Omit<Expression, "type"> {
-        type: "JSXExpressionContainer";
-        expression: K.ExpressionKind | K.JSXEmptyExpressionKind;
-    }
-    interface JSXElement extends Omit<Expression, "type"> {
-        type: "JSXElement";
-        openingElement: K.JSXOpeningElementKind;
-        closingElement?: K.JSXClosingElementKind | null;
-        children?: (K.JSXTextKind | K.JSXExpressionContainerKind | K.JSXSpreadChildKind | K.JSXElementKind | K.JSXFragmentKind | K.LiteralKind)[];
-        name?: K.JSXIdentifierKind | K.JSXNamespacedNameKind | K.JSXMemberExpressionKind;
-        selfClosing?: boolean;
-        attributes?: (K.JSXAttributeKind | K.JSXSpreadAttributeKind)[];
-    }
-    interface JSXFragment extends Omit<Expression, "type"> {
-        type: "JSXFragment";
-        openingFragment: K.JSXOpeningFragmentKind;
-        closingFragment: K.JSXClosingFragmentKind;
-        children?: (K.JSXTextKind | K.JSXExpressionContainerKind | K.JSXSpreadChildKind | K.JSXElementKind | K.JSXFragmentKind | K.LiteralKind)[];
-    }
-    interface JSXMemberExpression extends Omit<MemberExpression, "type" | "object" | "property" | "computed"> {
-        type: "JSXMemberExpression";
-        object: K.JSXIdentifierKind | K.JSXMemberExpressionKind;
-        property: K.JSXIdentifierKind;
-        computed?: boolean;
-    }
-    interface JSXSpreadAttribute extends Omit<Node, "type"> {
-        type: "JSXSpreadAttribute";
-        argument: K.ExpressionKind;
-    }
-    interface JSXEmptyExpression extends Omit<Node, "type"> {
-        type: "JSXEmptyExpression";
-    }
-    interface JSXText extends Omit<Literal, "type" | "value"> {
-        type: "JSXText";
-        value: string;
-        raw?: string;
-    }
-    interface JSXSpreadChild extends Omit<Node, "type"> {
-        type: "JSXSpreadChild";
-        expression: K.ExpressionKind;
-    }
-    interface JSXOpeningElement extends Omit<Node, "type"> {
-        type: "JSXOpeningElement";
-        name: K.JSXIdentifierKind | K.JSXNamespacedNameKind | K.JSXMemberExpressionKind;
-        attributes?: (K.JSXAttributeKind | K.JSXSpreadAttributeKind)[];
-        selfClosing?: boolean;
-    }
-    interface JSXClosingElement extends Omit<Node, "type"> {
-        type: "JSXClosingElement";
-        name: K.JSXIdentifierKind | K.JSXNamespacedNameKind | K.JSXMemberExpressionKind;
-    }
-    interface JSXOpeningFragment extends Omit<Node, "type"> {
-        type: "JSXOpeningFragment";
-    }
-    interface JSXClosingFragment extends Omit<Node, "type"> {
-        type: "JSXClosingFragment";
-    }
-    interface TypeParameterDeclaration extends Omit<Node, "type"> {
-        type: "TypeParameterDeclaration";
-        params: K.TypeParameterKind[];
-    }
-    interface TSTypeParameterDeclaration extends Omit<Declaration, "type"> {
-        type: "TSTypeParameterDeclaration";
-        params: K.TSTypeParameterKind[];
-    }
-    interface TypeParameterInstantiation extends Omit<Node, "type"> {
-        type: "TypeParameterInstantiation";
-        params: K.FlowTypeKind[];
-    }
-    interface TSTypeParameterInstantiation extends Omit<Node, "type"> {
-        type: "TSTypeParameterInstantiation";
-        params: K.TSTypeKind[];
-    }
-    interface ClassImplements extends Omit<Node, "type"> {
-        type: "ClassImplements";
-        id: K.IdentifierKind;
-        superClass?: K.ExpressionKind | null;
-        typeParameters?: K.TypeParameterInstantiationKind | null;
-    }
-    interface TSType extends Node {
-    }
-    interface TSHasOptionalTypeParameterInstantiation {
-        typeParameters?: K.TSTypeParameterInstantiationKind | null;
-    }
-    interface TSExpressionWithTypeArguments extends Omit<TSType, "type">, TSHasOptionalTypeParameterInstantiation {
-        type: "TSExpressionWithTypeArguments";
-        expression: K.IdentifierKind | K.TSQualifiedNameKind;
-    }
-    interface Flow extends Node {
-    }
-    interface FlowType extends Flow {
-    }
-    interface AnyTypeAnnotation extends Omit<FlowType, "type"> {
-        type: "AnyTypeAnnotation";
-    }
-    interface EmptyTypeAnnotation extends Omit<FlowType, "type"> {
-        type: "EmptyTypeAnnotation";
-    }
-    interface MixedTypeAnnotation extends Omit<FlowType, "type"> {
-        type: "MixedTypeAnnotation";
-    }
-    interface VoidTypeAnnotation extends Omit<FlowType, "type"> {
-        type: "VoidTypeAnnotation";
-    }
-    interface SymbolTypeAnnotation extends Omit<FlowType, "type"> {
-        type: "SymbolTypeAnnotation";
-    }
-    interface NumberTypeAnnotation extends Omit<FlowType, "type"> {
-        type: "NumberTypeAnnotation";
-    }
-    interface BigIntTypeAnnotation extends Omit<FlowType, "type"> {
-        type: "BigIntTypeAnnotation";
-    }
-    interface NumberLiteralTypeAnnotation extends Omit<FlowType, "type"> {
-        type: "NumberLiteralTypeAnnotation";
-        value: number;
-        raw: string;
-    }
-    interface NumericLiteralTypeAnnotation extends Omit<FlowType, "type"> {
-        type: "NumericLiteralTypeAnnotation";
-        value: number;
-        raw: string;
-    }
-    interface BigIntLiteralTypeAnnotation extends Omit<FlowType, "type"> {
-        type: "BigIntLiteralTypeAnnotation";
-        value: null;
-        raw: string;
-    }
-    interface StringTypeAnnotation extends Omit<FlowType, "type"> {
-        type: "StringTypeAnnotation";
-    }
-    interface StringLiteralTypeAnnotation extends Omit<FlowType, "type"> {
-        type: "StringLiteralTypeAnnotation";
-        value: string;
-        raw: string;
-    }
-    interface BooleanTypeAnnotation extends Omit<FlowType, "type"> {
-        type: "BooleanTypeAnnotation";
-    }
-    interface BooleanLiteralTypeAnnotation extends Omit<FlowType, "type"> {
-        type: "BooleanLiteralTypeAnnotation";
-        value: boolean;
-        raw: string;
-    }
-    interface NullableTypeAnnotation extends Omit<FlowType, "type"> {
-        type: "NullableTypeAnnotation";
-        typeAnnotation: K.FlowTypeKind;
-    }
-    interface NullLiteralTypeAnnotation extends Omit<FlowType, "type"> {
-        type: "NullLiteralTypeAnnotation";
-    }
-    interface NullTypeAnnotation extends Omit<FlowType, "type"> {
-        type: "NullTypeAnnotation";
-    }
-    interface ThisTypeAnnotation extends Omit<FlowType, "type"> {
-        type: "ThisTypeAnnotation";
-    }
-    interface ExistsTypeAnnotation extends Omit<FlowType, "type"> {
-        type: "ExistsTypeAnnotation";
-    }
-    interface ExistentialTypeParam extends Omit<FlowType, "type"> {
-        type: "ExistentialTypeParam";
-    }
-    interface FunctionTypeAnnotation extends Omit<FlowType, "type"> {
-        type: "FunctionTypeAnnotation";
-        params: K.FunctionTypeParamKind[];
-        returnType: K.FlowTypeKind;
-        rest: K.FunctionTypeParamKind | null;
-        typeParameters: K.TypeParameterDeclarationKind | null;
-    }
-    interface FunctionTypeParam extends Omit<Node, "type"> {
-        type: "FunctionTypeParam";
-        name: K.IdentifierKind | null;
-        typeAnnotation: K.FlowTypeKind;
-        optional: boolean;
-    }
-    interface ArrayTypeAnnotation extends Omit<FlowType, "type"> {
-        type: "ArrayTypeAnnotation";
-        elementType: K.FlowTypeKind;
-    }
-    interface ObjectTypeAnnotation extends Omit<FlowType, "type"> {
-        type: "ObjectTypeAnnotation";
-        properties: (K.ObjectTypePropertyKind | K.ObjectTypeSpreadPropertyKind)[];
-        indexers?: K.ObjectTypeIndexerKind[];
-        callProperties?: K.ObjectTypeCallPropertyKind[];
-        inexact?: boolean | undefined;
-        exact?: boolean;
-        internalSlots?: K.ObjectTypeInternalSlotKind[];
-    }
-    interface ObjectTypeProperty extends Omit<Node, "type"> {
-        type: "ObjectTypeProperty";
-        key: K.LiteralKind | K.IdentifierKind;
-        value: K.FlowTypeKind;
-        optional: boolean;
-        variance?: K.VarianceKind | "plus" | "minus" | null;
-    }
-    interface ObjectTypeSpreadProperty extends Omit<Node, "type"> {
-        type: "ObjectTypeSpreadProperty";
-        argument: K.FlowTypeKind;
-    }
-    interface ObjectTypeIndexer extends Omit<Node, "type"> {
-        type: "ObjectTypeIndexer";
-        id: K.IdentifierKind;
-        key: K.FlowTypeKind;
-        value: K.FlowTypeKind;
-        variance?: K.VarianceKind | "plus" | "minus" | null;
-        static?: boolean;
-    }
-    interface ObjectTypeCallProperty extends Omit<Node, "type"> {
-        type: "ObjectTypeCallProperty";
-        value: K.FunctionTypeAnnotationKind;
-        static?: boolean;
-    }
-    interface ObjectTypeInternalSlot extends Omit<Node, "type"> {
-        type: "ObjectTypeInternalSlot";
-        id: K.IdentifierKind;
-        value: K.FlowTypeKind;
-        optional: boolean;
-        static: boolean;
-        method: boolean;
-    }
-    interface Variance extends Omit<Node, "type"> {
-        type: "Variance";
-        kind: "plus" | "minus";
-    }
-    interface QualifiedTypeIdentifier extends Omit<Node, "type"> {
-        type: "QualifiedTypeIdentifier";
-        qualification: K.IdentifierKind | K.QualifiedTypeIdentifierKind;
-        id: K.IdentifierKind;
-    }
-    interface GenericTypeAnnotation extends Omit<FlowType, "type"> {
-        type: "GenericTypeAnnotation";
-        id: K.IdentifierKind | K.QualifiedTypeIdentifierKind;
-        typeParameters: K.TypeParameterInstantiationKind | null;
-    }
-    interface MemberTypeAnnotation extends Omit<FlowType, "type"> {
-        type: "MemberTypeAnnotation";
-        object: K.IdentifierKind;
-        property: K.MemberTypeAnnotationKind | K.GenericTypeAnnotationKind;
-    }
-    interface IndexedAccessType extends Omit<FlowType, "type"> {
-        type: "IndexedAccessType";
-        objectType: K.FlowTypeKind;
-        indexType: K.FlowTypeKind;
-    }
-    interface OptionalIndexedAccessType extends Omit<FlowType, "type"> {
-        type: "OptionalIndexedAccessType";
-        objectType: K.FlowTypeKind;
-        indexType: K.FlowTypeKind;
-        optional: boolean;
-    }
-    interface UnionTypeAnnotation extends Omit<FlowType, "type"> {
-        type: "UnionTypeAnnotation";
-        types: K.FlowTypeKind[];
-    }
-    interface IntersectionTypeAnnotation extends Omit<FlowType, "type"> {
-        type: "IntersectionTypeAnnotation";
-        types: K.FlowTypeKind[];
-    }
-    interface TypeofTypeAnnotation extends Omit<FlowType, "type"> {
-        type: "TypeofTypeAnnotation";
-        argument: K.FlowTypeKind;
-    }
-    interface TypeParameter extends Omit<FlowType, "type"> {
-        type: "TypeParameter";
-        name: string;
-        variance?: K.VarianceKind | "plus" | "minus" | null;
-        bound?: K.TypeAnnotationKind | null;
-        default?: K.FlowTypeKind | null;
-    }
-    interface InterfaceTypeAnnotation extends Omit<FlowType, "type"> {
-        type: "InterfaceTypeAnnotation";
-        body: K.ObjectTypeAnnotationKind;
-        extends?: K.InterfaceExtendsKind[] | null;
-    }
-    interface InterfaceExtends extends Omit<Node, "type"> {
-        type: "InterfaceExtends";
-        id: K.IdentifierKind;
-        typeParameters?: K.TypeParameterInstantiationKind | null;
-    }
-    interface InterfaceDeclaration extends Omit<Declaration, "type"> {
-        type: "InterfaceDeclaration";
-        id: K.IdentifierKind;
-        typeParameters?: K.TypeParameterDeclarationKind | null;
-        body: K.ObjectTypeAnnotationKind;
-        extends: K.InterfaceExtendsKind[];
-    }
-    interface DeclareInterface extends Omit<InterfaceDeclaration, "type"> {
-        type: "DeclareInterface";
-    }
-    interface TypeAlias extends Omit<Declaration, "type"> {
-        type: "TypeAlias";
-        id: K.IdentifierKind;
-        typeParameters: K.TypeParameterDeclarationKind | null;
-        right: K.FlowTypeKind;
-    }
-    interface DeclareTypeAlias extends Omit<TypeAlias, "type"> {
-        type: "DeclareTypeAlias";
-    }
-    interface OpaqueType extends Omit<Declaration, "type"> {
-        type: "OpaqueType";
-        id: K.IdentifierKind;
-        typeParameters: K.TypeParameterDeclarationKind | null;
-        impltype: K.FlowTypeKind;
-        supertype: K.FlowTypeKind | null;
-    }
-    interface DeclareOpaqueType extends Omit<OpaqueType, "type" | "impltype"> {
-        type: "DeclareOpaqueType";
-        impltype: K.FlowTypeKind | null;
-    }
-    interface TypeCastExpression extends Omit<Expression, "type"> {
-        type: "TypeCastExpression";
-        expression: K.ExpressionKind;
-        typeAnnotation: K.TypeAnnotationKind;
-    }
-    interface TupleTypeAnnotation extends Omit<FlowType, "type"> {
-        type: "TupleTypeAnnotation";
-        types: K.FlowTypeKind[];
-    }
-    interface DeclareVariable extends Omit<Statement, "type"> {
-        type: "DeclareVariable";
-        id: K.IdentifierKind;
-    }
-    interface DeclareFunction extends Omit<Statement, "type"> {
-        type: "DeclareFunction";
-        id: K.IdentifierKind;
-        predicate?: K.FlowPredicateKind | null;
-    }
-    interface FlowPredicate extends Flow {
-    }
-    interface DeclareClass extends Omit<InterfaceDeclaration, "type"> {
-        type: "DeclareClass";
-    }
-    interface DeclareModule extends Omit<Statement, "type"> {
-        type: "DeclareModule";
-        id: K.IdentifierKind | K.LiteralKind;
-        body: K.BlockStatementKind;
-    }
-    interface DeclareModuleExports extends Omit<Statement, "type"> {
-        type: "DeclareModuleExports";
-        typeAnnotation: K.TypeAnnotationKind;
-    }
-    interface DeclareExportDeclaration extends Omit<Declaration, "type"> {
-        type: "DeclareExportDeclaration";
-        default: boolean;
-        declaration: K.DeclareVariableKind | K.DeclareFunctionKind | K.DeclareClassKind | K.FlowTypeKind | K.TypeAliasKind | K.DeclareOpaqueTypeKind | K.InterfaceDeclarationKind | null;
-        specifiers?: (K.ExportSpecifierKind | K.ExportBatchSpecifierKind)[];
-        source?: K.LiteralKind | null;
-    }
-    interface ExportBatchSpecifier extends Omit<Specifier, "type"> {
-        type: "ExportBatchSpecifier";
-    }
-    interface DeclareExportAllDeclaration extends Omit<Declaration, "type"> {
-        type: "DeclareExportAllDeclaration";
-        source?: K.LiteralKind | null;
-    }
-    interface InferredPredicate extends Omit<FlowPredicate, "type"> {
-        type: "InferredPredicate";
-    }
-    interface DeclaredPredicate extends Omit<FlowPredicate, "type"> {
-        type: "DeclaredPredicate";
-        value: K.ExpressionKind;
-    }
-    interface EnumDeclaration extends Omit<Declaration, "type"> {
-        type: "EnumDeclaration";
-        id: K.IdentifierKind;
-        body: K.EnumBooleanBodyKind | K.EnumNumberBodyKind | K.EnumStringBodyKind | K.EnumSymbolBodyKind;
-    }
-    interface EnumBooleanBody {
-        type: "EnumBooleanBody";
-        members: K.EnumBooleanMemberKind[];
-        explicitType: boolean;
-    }
-    interface EnumNumberBody {
-        type: "EnumNumberBody";
-        members: K.EnumNumberMemberKind[];
-        explicitType: boolean;
-    }
-    interface EnumStringBody {
-        type: "EnumStringBody";
-        members: K.EnumStringMemberKind[] | K.EnumDefaultedMemberKind[];
-        explicitType: boolean;
-    }
-    interface EnumSymbolBody {
-        type: "EnumSymbolBody";
-        members: K.EnumDefaultedMemberKind[];
-    }
-    interface EnumBooleanMember {
-        type: "EnumBooleanMember";
-        id: K.IdentifierKind;
-        init: K.LiteralKind | boolean;
-    }
-    interface EnumNumberMember {
-        type: "EnumNumberMember";
-        id: K.IdentifierKind;
-        init: K.LiteralKind;
-    }
-    interface EnumStringMember {
-        type: "EnumStringMember";
-        id: K.IdentifierKind;
-        init: K.LiteralKind;
-    }
-    interface EnumDefaultedMember {
-        type: "EnumDefaultedMember";
-        id: K.IdentifierKind;
-    }
-    interface ExportDeclaration extends Omit<Declaration, "type"> {
-        type: "ExportDeclaration";
-        default: boolean;
-        declaration: K.DeclarationKind | K.ExpressionKind | null;
-        specifiers?: (K.ExportSpecifierKind | K.ExportBatchSpecifierKind)[];
-        source?: K.LiteralKind | null;
-    }
-    interface Block extends Comment {
-        type: "Block";
-    }
-    interface Line extends Comment {
-        type: "Line";
-    }
-    interface Noop extends Omit<Statement, "type"> {
-        type: "Noop";
-    }
-    interface DoExpression extends Omit<Expression, "type"> {
-        type: "DoExpression";
-        body: K.StatementKind[];
-    }
-    interface BindExpression extends Omit<Expression, "type"> {
-        type: "BindExpression";
-        object: K.ExpressionKind | null;
-        callee: K.ExpressionKind;
-    }
-    interface ParenthesizedExpression extends Omit<Expression, "type"> {
-        type: "ParenthesizedExpression";
-        expression: K.ExpressionKind;
-    }
-    interface ExportNamespaceSpecifier extends Omit<Specifier, "type"> {
-        type: "ExportNamespaceSpecifier";
-        exported: K.IdentifierKind;
-    }
-    interface ExportDefaultSpecifier extends Omit<Specifier, "type"> {
-        type: "ExportDefaultSpecifier";
-        exported: K.IdentifierKind;
-    }
-    interface CommentBlock extends Comment {
-        type: "CommentBlock";
-    }
-    interface CommentLine extends Comment {
-        type: "CommentLine";
-    }
-    interface Directive extends Omit<Node, "type"> {
-        type: "Directive";
-        value: K.DirectiveLiteralKind;
-    }
-    interface DirectiveLiteral extends Omit<Node, "type">, Omit<Expression, "type"> {
-        type: "DirectiveLiteral";
-        value?: string;
-    }
-    interface InterpreterDirective extends Omit<Node, "type"> {
-        type: "InterpreterDirective";
-        value: string;
-    }
-    interface StringLiteral extends Omit<Literal, "type" | "value"> {
-        type: "StringLiteral";
-        value: string;
-        extra?: {
-            rawValue: string;
-            raw: string;
-        };
-    }
-    interface NumericLiteral extends Omit<Literal, "type" | "value"> {
-        type: "NumericLiteral";
-        value: number;
-        raw?: string | null;
-        extra?: {
-            rawValue: number;
-            raw: string;
-        };
-    }
-    interface BigIntLiteral extends Omit<Literal, "type" | "value"> {
-        type: "BigIntLiteral";
-        value: string | number;
-        extra?: {
-            rawValue: string;
-            raw: string;
-        };
-    }
-    interface DecimalLiteral extends Omit<Literal, "type" | "value"> {
-        type: "DecimalLiteral";
-        value: string;
-        extra?: {
-            rawValue: string;
-            raw: string;
-        };
-    }
-    interface NullLiteral extends Omit<Literal, "type" | "value"> {
-        type: "NullLiteral";
-        value?: null;
-    }
-    interface BooleanLiteral extends Omit<Literal, "type" | "value"> {
-        type: "BooleanLiteral";
-        value: boolean;
-    }
-    interface RegExpLiteral extends Omit<Literal, "type" | "value"> {
-        type: "RegExpLiteral";
-        pattern: string;
-        flags: string;
-        value?: RegExp;
-        extra?: {
-            rawValue: RegExp | undefined;
-            raw: string;
-        };
-        regex?: {
-            pattern: string;
-            flags: string;
-        };
-    }
-    interface ClassMethod extends Omit<Declaration, "type">, Omit<Function, "type" | "body"> {
-        type: "ClassMethod";
-        key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind;
-        kind?: "get" | "set" | "method" | "constructor";
-        body: K.BlockStatementKind;
-        access?: "public" | "private" | "protected" | null;
-        computed?: boolean;
-        static?: boolean;
-        abstract?: boolean;
-        accessibility?: "public" | "private" | "protected" | null;
-        decorators?: K.DecoratorKind[] | null;
-        definite?: boolean;
-        optional?: boolean;
-        override?: boolean;
-        readonly?: boolean;
-    }
-    interface ClassPrivateMethod extends Omit<Declaration, "type">, Omit<Function, "type" | "body"> {
-        type: "ClassPrivateMethod";
-        key: K.PrivateNameKind;
-        kind?: "get" | "set" | "method" | "constructor";
-        body: K.BlockStatementKind;
-        access?: "public" | "private" | "protected" | null;
-        computed?: boolean;
-        static?: boolean;
-        abstract?: boolean;
-        accessibility?: "public" | "private" | "protected" | null;
-        decorators?: K.DecoratorKind[] | null;
-        definite?: boolean;
-        optional?: boolean;
-        override?: boolean;
-        readonly?: boolean;
-    }
-    interface TSHasOptionalTypeAnnotation {
-        typeAnnotation?: K.TSTypeAnnotationKind | null;
-    }
-    interface ClassAccessorProperty extends Omit<Declaration, "type">, TSHasOptionalTypeAnnotation {
-        type: "ClassAccessorProperty";
-        key: K.LiteralKind | K.IdentifierKind | K.PrivateNameKind | K.ExpressionKind;
-        value?: K.ExpressionKind | null;
-        computed?: boolean;
-        static?: boolean;
-        abstract?: boolean;
-        accessibility?: "public" | "private" | "protected" | null;
-        decorators?: K.DecoratorKind[] | null;
-        definite?: boolean;
-        optional?: boolean;
-        override?: boolean;
-        readonly?: boolean;
-    }
-    interface RestProperty extends Omit<Node, "type"> {
-        type: "RestProperty";
-        argument: K.ExpressionKind;
-    }
-    interface ForAwaitStatement extends Omit<Statement, "type"> {
-        type: "ForAwaitStatement";
-        left: K.VariableDeclarationKind | K.ExpressionKind;
-        right: K.ExpressionKind;
-        body: K.StatementKind;
-    }
-    interface Import extends Omit<Expression, "type"> {
-        type: "Import";
-    }
-    interface V8IntrinsicIdentifier extends Omit<Expression, "type"> {
-        type: "V8IntrinsicIdentifier";
-        name: string;
-    }
-    interface TopicReference extends Omit<Expression, "type"> {
-        type: "TopicReference";
-    }
-    interface TSQualifiedName extends Omit<Node, "type"> {
-        type: "TSQualifiedName";
-        left: K.IdentifierKind | K.TSQualifiedNameKind;
-        right: K.IdentifierKind | K.TSQualifiedNameKind;
-    }
-    interface TSTypeReference extends Omit<TSType, "type">, TSHasOptionalTypeParameterInstantiation {
-        type: "TSTypeReference";
-        typeName: K.IdentifierKind | K.TSQualifiedNameKind;
-    }
-    interface TSHasOptionalTypeParameters {
-        typeParameters?: K.TSTypeParameterDeclarationKind | null | undefined;
-    }
-    interface TSAsExpression extends Omit<Expression, "type">, Omit<Pattern, "type"> {
-        type: "TSAsExpression";
-        expression: K.ExpressionKind;
-        typeAnnotation: K.TSTypeKind;
-        extra?: {
-            parenthesized: boolean;
-        } | null;
-    }
-    interface TSTypeCastExpression extends Omit<Expression, "type"> {
-        type: "TSTypeCastExpression";
-        expression: K.ExpressionKind;
-        typeAnnotation: K.TSTypeKind;
-    }
-    interface TSSatisfiesExpression extends Omit<Expression, "type">, Omit<Pattern, "type"> {
-        type: "TSSatisfiesExpression";
-        expression: K.ExpressionKind;
-        typeAnnotation: K.TSTypeKind;
-    }
-    interface TSNonNullExpression extends Omit<Expression, "type">, Omit<Pattern, "type"> {
-        type: "TSNonNullExpression";
-        expression: K.ExpressionKind;
-    }
-    interface TSAnyKeyword extends Omit<TSType, "type"> {
-        type: "TSAnyKeyword";
-    }
-    interface TSBigIntKeyword extends Omit<TSType, "type"> {
-        type: "TSBigIntKeyword";
-    }
-    interface TSBooleanKeyword extends Omit<TSType, "type"> {
-        type: "TSBooleanKeyword";
-    }
-    interface TSNeverKeyword extends Omit<TSType, "type"> {
-        type: "TSNeverKeyword";
-    }
-    interface TSNullKeyword extends Omit<TSType, "type"> {
-        type: "TSNullKeyword";
-    }
-    interface TSNumberKeyword extends Omit<TSType, "type"> {
-        type: "TSNumberKeyword";
-    }
-    interface TSObjectKeyword extends Omit<TSType, "type"> {
-        type: "TSObjectKeyword";
-    }
-    interface TSStringKeyword extends Omit<TSType, "type"> {
-        type: "TSStringKeyword";
-    }
-    interface TSSymbolKeyword extends Omit<TSType, "type"> {
-        type: "TSSymbolKeyword";
-    }
-    interface TSUndefinedKeyword extends Omit<TSType, "type"> {
-        type: "TSUndefinedKeyword";
-    }
-    interface TSUnknownKeyword extends Omit<TSType, "type"> {
-        type: "TSUnknownKeyword";
-    }
-    interface TSVoidKeyword extends Omit<TSType, "type"> {
-        type: "TSVoidKeyword";
-    }
-    interface TSIntrinsicKeyword extends Omit<TSType, "type"> {
-        type: "TSIntrinsicKeyword";
-    }
-    interface TSThisType extends Omit<TSType, "type"> {
-        type: "TSThisType";
-    }
-    interface TSArrayType extends Omit<TSType, "type"> {
-        type: "TSArrayType";
-        elementType: K.TSTypeKind;
-    }
-    interface TSLiteralType extends Omit<TSType, "type"> {
-        type: "TSLiteralType";
-        literal: K.NumericLiteralKind | K.StringLiteralKind | K.BooleanLiteralKind | K.TemplateLiteralKind | K.UnaryExpressionKind | K.BigIntLiteralKind;
-    }
-    interface TSUnionType extends Omit<TSType, "type"> {
-        type: "TSUnionType";
-        types: K.TSTypeKind[];
-    }
-    interface TSIntersectionType extends Omit<TSType, "type"> {
-        type: "TSIntersectionType";
-        types: K.TSTypeKind[];
-    }
-    interface TSConditionalType extends Omit<TSType, "type"> {
-        type: "TSConditionalType";
-        checkType: K.TSTypeKind;
-        extendsType: K.TSTypeKind;
-        trueType: K.TSTypeKind;
-        falseType: K.TSTypeKind;
-    }
-    interface TSInferType extends Omit<TSType, "type"> {
-        type: "TSInferType";
-        typeParameter: K.TSTypeParameterKind;
-    }
-    interface TSTypeParameter extends Omit<Identifier, "type" | "name"> {
-        type: "TSTypeParameter";
-        name: K.IdentifierKind | string;
-        constraint?: K.TSTypeKind | undefined;
-        default?: K.TSTypeKind | undefined;
-    }
-    interface TSParenthesizedType extends Omit<TSType, "type"> {
-        type: "TSParenthesizedType";
-        typeAnnotation: K.TSTypeKind;
-    }
-    interface TSFunctionType extends Omit<TSType, "type">, TSHasOptionalTypeParameters, TSHasOptionalTypeAnnotation {
-        type: "TSFunctionType";
-        parameters: (K.IdentifierKind | K.RestElementKind | K.ArrayPatternKind | K.ObjectPatternKind)[];
-    }
-    interface TSConstructorType extends Omit<TSType, "type">, TSHasOptionalTypeParameters, TSHasOptionalTypeAnnotation {
-        type: "TSConstructorType";
-        parameters: (K.IdentifierKind | K.RestElementKind | K.ArrayPatternKind | K.ObjectPatternKind)[];
-    }
-    interface TSDeclareFunction extends Omit<Declaration, "type">, TSHasOptionalTypeParameters {
-        type: "TSDeclareFunction";
-        declare?: boolean;
-        async?: boolean;
-        generator?: boolean;
-        id?: K.IdentifierKind | null;
-        params: K.PatternKind[];
-        returnType?: K.TSTypeAnnotationKind | K.NoopKind | null;
-    }
-    interface TSDeclareMethod extends Omit<Declaration, "type">, TSHasOptionalTypeParameters {
-        type: "TSDeclareMethod";
-        async?: boolean;
-        generator?: boolean;
-        params: K.PatternKind[];
-        abstract?: boolean;
-        accessibility?: "public" | "private" | "protected" | undefined;
-        static?: boolean;
-        computed?: boolean;
-        optional?: boolean;
-        key: K.IdentifierKind | K.StringLiteralKind | K.NumericLiteralKind | K.ExpressionKind;
-        kind?: "get" | "set" | "method" | "constructor";
-        access?: "public" | "private" | "protected" | undefined;
-        decorators?: K.DecoratorKind[] | null;
-        returnType?: K.TSTypeAnnotationKind | K.NoopKind | null;
-    }
-    interface TSMappedType extends Omit<TSType, "type"> {
-        type: "TSMappedType";
-        readonly?: boolean | "+" | "-";
-        typeParameter: K.TSTypeParameterKind;
-        optional?: boolean | "+" | "-";
-        typeAnnotation?: K.TSTypeKind | null;
-    }
-    interface TSTupleType extends Omit<TSType, "type"> {
-        type: "TSTupleType";
-        elementTypes: (K.TSTypeKind | K.TSNamedTupleMemberKind)[];
-    }
-    interface TSNamedTupleMember extends Omit<TSType, "type"> {
-        type: "TSNamedTupleMember";
-        label: K.IdentifierKind;
-        optional?: boolean;
-        elementType: K.TSTypeKind;
-    }
-    interface TSRestType extends Omit<TSType, "type"> {
-        type: "TSRestType";
-        typeAnnotation: K.TSTypeKind;
-    }
-    interface TSOptionalType extends Omit<TSType, "type"> {
-        type: "TSOptionalType";
-        typeAnnotation: K.TSTypeKind;
-    }
-    interface TSIndexedAccessType extends Omit<TSType, "type"> {
-        type: "TSIndexedAccessType";
-        objectType: K.TSTypeKind;
-        indexType: K.TSTypeKind;
-    }
-    interface TSTypeOperator extends Omit<TSType, "type"> {
-        type: "TSTypeOperator";
-        operator: string;
-        typeAnnotation: K.TSTypeKind;
-    }
-    interface TSIndexSignature extends Omit<Declaration, "type">, TSHasOptionalTypeAnnotation {
-        type: "TSIndexSignature";
-        parameters: K.IdentifierKind[];
-        readonly?: boolean;
-    }
-    interface TSPropertySignature extends Omit<Declaration, "type">, TSHasOptionalTypeAnnotation {
-        type: "TSPropertySignature";
-        key: K.ExpressionKind;
-        computed?: boolean;
-        readonly?: boolean;
-        optional?: boolean;
-        initializer?: K.ExpressionKind | null;
-    }
-    interface TSMethodSignature extends Omit<Declaration, "type">, TSHasOptionalTypeParameters, TSHasOptionalTypeAnnotation {
-        type: "TSMethodSignature";
-        key: K.ExpressionKind;
-        computed?: boolean;
-        optional?: boolean;
-        parameters: (K.IdentifierKind | K.RestElementKind | K.ArrayPatternKind | K.ObjectPatternKind)[];
-    }
-    interface TSTypePredicate extends Omit<TSTypeAnnotation, "type" | "typeAnnotation">, Omit<TSType, "type"> {
-        type: "TSTypePredicate";
-        parameterName: K.IdentifierKind | K.TSThisTypeKind;
-        typeAnnotation?: K.TSTypeAnnotationKind | null;
-        asserts?: boolean;
-    }
-    interface TSCallSignatureDeclaration extends Omit<Declaration, "type">, TSHasOptionalTypeParameters, TSHasOptionalTypeAnnotation {
-        type: "TSCallSignatureDeclaration";
-        parameters: (K.IdentifierKind | K.RestElementKind | K.ArrayPatternKind | K.ObjectPatternKind)[];
-    }
-    interface TSConstructSignatureDeclaration extends Omit<Declaration, "type">, TSHasOptionalTypeParameters, TSHasOptionalTypeAnnotation {
-        type: "TSConstructSignatureDeclaration";
-        parameters: (K.IdentifierKind | K.RestElementKind | K.ArrayPatternKind | K.ObjectPatternKind)[];
-    }
-    interface TSEnumMember extends Omit<Node, "type"> {
-        type: "TSEnumMember";
-        id: K.IdentifierKind | K.StringLiteralKind;
-        initializer?: K.ExpressionKind | null;
-    }
-    interface TSTypeQuery extends Omit<TSType, "type"> {
-        type: "TSTypeQuery";
-        exprName: K.IdentifierKind | K.TSQualifiedNameKind | K.TSImportTypeKind;
-    }
-    interface TSImportType extends Omit<TSType, "type">, TSHasOptionalTypeParameterInstantiation {
-        type: "TSImportType";
-        argument: K.StringLiteralKind;
-        qualifier?: K.IdentifierKind | K.TSQualifiedNameKind | undefined;
-    }
-    interface TSTypeLiteral extends Omit<TSType, "type"> {
-        type: "TSTypeLiteral";
-        members: (K.TSCallSignatureDeclarationKind | K.TSConstructSignatureDeclarationKind | K.TSIndexSignatureKind | K.TSMethodSignatureKind | K.TSPropertySignatureKind)[];
-    }
-    interface TSTypeAssertion extends Omit<Expression, "type">, Omit<Pattern, "type"> {
-        type: "TSTypeAssertion";
-        typeAnnotation: K.TSTypeKind;
-        expression: K.ExpressionKind;
-        extra?: {
-            parenthesized: boolean;
-        } | null;
-    }
-    interface TSInstantiationExpression extends Omit<Expression, "type">, TSHasOptionalTypeParameterInstantiation {
-        type: "TSInstantiationExpression";
-        expression: K.ExpressionKind;
-    }
-    interface TSEnumDeclaration extends Omit<Declaration, "type"> {
-        type: "TSEnumDeclaration";
-        id: K.IdentifierKind;
-        const?: boolean;
-        declare?: boolean;
-        members: K.TSEnumMemberKind[];
-        initializer?: K.ExpressionKind | null;
-    }
-    interface TSTypeAliasDeclaration extends Omit<Declaration, "type">, TSHasOptionalTypeParameters {
-        type: "TSTypeAliasDeclaration";
-        id: K.IdentifierKind;
-        declare?: boolean;
-        typeAnnotation: K.TSTypeKind;
-    }
-    interface TSModuleBlock extends Omit<Node, "type"> {
-        type: "TSModuleBlock";
-        body: K.StatementKind[];
-    }
-    interface TSModuleDeclaration extends Omit<Declaration, "type"> {
-        type: "TSModuleDeclaration";
-        id: K.StringLiteralKind | K.IdentifierKind | K.TSQualifiedNameKind;
-        declare?: boolean;
-        global?: boolean;
-        body?: K.TSModuleBlockKind | K.TSModuleDeclarationKind | null;
-    }
-    interface TSImportEqualsDeclaration extends Omit<Declaration, "type"> {
-        type: "TSImportEqualsDeclaration";
-        id: K.IdentifierKind;
-        isExport?: boolean;
-        moduleReference: K.IdentifierKind | K.TSQualifiedNameKind | K.TSExternalModuleReferenceKind;
-    }
-    interface TSExternalModuleReference extends Omit<Declaration, "type"> {
-        type: "TSExternalModuleReference";
-        expression: K.StringLiteralKind;
-    }
-    interface TSExportAssignment extends Omit<Statement, "type"> {
-        type: "TSExportAssignment";
-        expression: K.ExpressionKind;
-    }
-    interface TSNamespaceExportDeclaration extends Omit<Declaration, "type"> {
-        type: "TSNamespaceExportDeclaration";
-        id: K.IdentifierKind;
-    }
-    interface TSInterfaceBody extends Omit<Node, "type"> {
-        type: "TSInterfaceBody";
-        body: (K.TSCallSignatureDeclarationKind | K.TSConstructSignatureDeclarationKind | K.TSIndexSignatureKind | K.TSMethodSignatureKind | K.TSPropertySignatureKind)[];
-    }
-    interface TSInterfaceDeclaration extends Omit<Declaration, "type">, TSHasOptionalTypeParameters {
-        type: "TSInterfaceDeclaration";
-        id: K.IdentifierKind | K.TSQualifiedNameKind;
-        declare?: boolean;
-        extends?: K.TSExpressionWithTypeArgumentsKind[] | null;
-        body: K.TSInterfaceBodyKind;
-    }
-    interface TSParameterProperty extends Omit<Pattern, "type"> {
-        type: "TSParameterProperty";
-        accessibility?: "public" | "private" | "protected" | undefined;
-        readonly?: boolean;
-        parameter: K.IdentifierKind | K.AssignmentPatternKind;
-    }
-    type ASTNode = File | Program | Identifier | BlockStatement | EmptyStatement | ExpressionStatement | IfStatement | LabeledStatement | BreakStatement | ContinueStatement | WithStatement | SwitchStatement | SwitchCase | ReturnStatement | ThrowStatement | TryStatement | CatchClause | WhileStatement | DoWhileStatement | ForStatement | VariableDeclaration | ForInStatement | DebuggerStatement | FunctionDeclaration | FunctionExpression | VariableDeclarator | ThisExpression | ArrayExpression | ObjectExpression | Property | Literal | SequenceExpression | UnaryExpression | BinaryExpression | AssignmentExpression | MemberExpression | UpdateExpression | LogicalExpression | ConditionalExpression | NewExpression | CallExpression | RestElement | TypeAnnotation | TSTypeAnnotation | SpreadElementPattern | ArrowFunctionExpression | ForOfStatement | YieldExpression | GeneratorExpression | ComprehensionBlock | ComprehensionExpression | ObjectProperty | PropertyPattern | ObjectPattern | ArrayPattern | SpreadElement | AssignmentPattern | MethodDefinition | ClassPropertyDefinition | ClassProperty | StaticBlock | ClassBody | ClassDeclaration | ClassExpression | Super | ImportSpecifier | ImportDefaultSpecifier | ImportNamespaceSpecifier | ImportDeclaration | ExportNamedDeclaration | ExportSpecifier | ExportDefaultDeclaration | ExportAllDeclaration | TaggedTemplateExpression | TemplateLiteral | TemplateElement | MetaProperty | AwaitExpression | SpreadProperty | SpreadPropertyPattern | ImportExpression | ChainExpression | OptionalCallExpression | OptionalMemberExpression | Decorator | PrivateName | ClassPrivateProperty | ImportAttribute | RecordExpression | ObjectMethod | TupleExpression | ModuleExpression | JSXAttribute | JSXIdentifier | JSXNamespacedName | JSXExpressionContainer | JSXElement | JSXFragment | JSXMemberExpression | JSXSpreadAttribute | JSXEmptyExpression | JSXText | JSXSpreadChild | JSXOpeningElement | JSXClosingElement | JSXOpeningFragment | JSXClosingFragment | TypeParameterDeclaration | TSTypeParameterDeclaration | TypeParameterInstantiation | TSTypeParameterInstantiation | ClassImplements | TSExpressionWithTypeArguments | AnyTypeAnnotation | EmptyTypeAnnotation | MixedTypeAnnotation | VoidTypeAnnotation | SymbolTypeAnnotation | NumberTypeAnnotation | BigIntTypeAnnotation | NumberLiteralTypeAnnotation | NumericLiteralTypeAnnotation | BigIntLiteralTypeAnnotation | StringTypeAnnotation | StringLiteralTypeAnnotation | BooleanTypeAnnotation | BooleanLiteralTypeAnnotation | NullableTypeAnnotation | NullLiteralTypeAnnotation | NullTypeAnnotation | ThisTypeAnnotation | ExistsTypeAnnotation | ExistentialTypeParam | FunctionTypeAnnotation | FunctionTypeParam | ArrayTypeAnnotation | ObjectTypeAnnotation | ObjectTypeProperty | ObjectTypeSpreadProperty | ObjectTypeIndexer | ObjectTypeCallProperty | ObjectTypeInternalSlot | Variance | QualifiedTypeIdentifier | GenericTypeAnnotation | MemberTypeAnnotation | IndexedAccessType | OptionalIndexedAccessType | UnionTypeAnnotation | IntersectionTypeAnnotation | TypeofTypeAnnotation | TypeParameter | InterfaceTypeAnnotation | InterfaceExtends | InterfaceDeclaration | DeclareInterface | TypeAlias | DeclareTypeAlias | OpaqueType | DeclareOpaqueType | TypeCastExpression | TupleTypeAnnotation | DeclareVariable | DeclareFunction | DeclareClass | DeclareModule | DeclareModuleExports | DeclareExportDeclaration | ExportBatchSpecifier | DeclareExportAllDeclaration | InferredPredicate | DeclaredPredicate | EnumDeclaration | EnumBooleanBody | EnumNumberBody | EnumStringBody | EnumSymbolBody | EnumBooleanMember | EnumNumberMember | EnumStringMember | EnumDefaultedMember | ExportDeclaration | Block | Line | Noop | DoExpression | BindExpression | ParenthesizedExpression | ExportNamespaceSpecifier | ExportDefaultSpecifier | CommentBlock | CommentLine | Directive | DirectiveLiteral | InterpreterDirective | StringLiteral | NumericLiteral | BigIntLiteral | DecimalLiteral | NullLiteral | BooleanLiteral | RegExpLiteral | ClassMethod | ClassPrivateMethod | ClassAccessorProperty | RestProperty | ForAwaitStatement | Import | V8IntrinsicIdentifier | TopicReference | TSQualifiedName | TSTypeReference | TSAsExpression | TSTypeCastExpression | TSSatisfiesExpression | TSNonNullExpression | TSAnyKeyword | TSBigIntKeyword | TSBooleanKeyword | TSNeverKeyword | TSNullKeyword | TSNumberKeyword | TSObjectKeyword | TSStringKeyword | TSSymbolKeyword | TSUndefinedKeyword | TSUnknownKeyword | TSVoidKeyword | TSIntrinsicKeyword | TSThisType | TSArrayType | TSLiteralType | TSUnionType | TSIntersectionType | TSConditionalType | TSInferType | TSTypeParameter | TSParenthesizedType | TSFunctionType | TSConstructorType | TSDeclareFunction | TSDeclareMethod | TSMappedType | TSTupleType | TSNamedTupleMember | TSRestType | TSOptionalType | TSIndexedAccessType | TSTypeOperator | TSIndexSignature | TSPropertySignature | TSMethodSignature | TSTypePredicate | TSCallSignatureDeclaration | TSConstructSignatureDeclaration | TSEnumMember | TSTypeQuery | TSImportType | TSTypeLiteral | TSTypeAssertion | TSInstantiationExpression | TSEnumDeclaration | TSTypeAliasDeclaration | TSModuleBlock | TSModuleDeclaration | TSImportEqualsDeclaration | TSExternalModuleReference | TSExportAssignment | TSNamespaceExportDeclaration | TSInterfaceBody | TSInterfaceDeclaration | TSParameterProperty;
-    let Printable: Type<Printable>;
-    let SourceLocation: Type<SourceLocation>;
-    let Node: Type<Node>;
-    let Comment: Type<Comment>;
-    let Position: Type<Position>;
-    let File: Type<File>;
-    let Program: Type<Program>;
-    let Statement: Type<Statement>;
-    let Function: Type<Function>;
-    let Expression: Type<Expression>;
-    let Pattern: Type<Pattern>;
-    let Identifier: Type<Identifier>;
-    let BlockStatement: Type<BlockStatement>;
-    let EmptyStatement: Type<EmptyStatement>;
-    let ExpressionStatement: Type<ExpressionStatement>;
-    let IfStatement: Type<IfStatement>;
-    let LabeledStatement: Type<LabeledStatement>;
-    let BreakStatement: Type<BreakStatement>;
-    let ContinueStatement: Type<ContinueStatement>;
-    let WithStatement: Type<WithStatement>;
-    let SwitchStatement: Type<SwitchStatement>;
-    let SwitchCase: Type<SwitchCase>;
-    let ReturnStatement: Type<ReturnStatement>;
-    let ThrowStatement: Type<ThrowStatement>;
-    let TryStatement: Type<TryStatement>;
-    let CatchClause: Type<CatchClause>;
-    let WhileStatement: Type<WhileStatement>;
-    let DoWhileStatement: Type<DoWhileStatement>;
-    let ForStatement: Type<ForStatement>;
-    let Declaration: Type<Declaration>;
-    let VariableDeclaration: Type<VariableDeclaration>;
-    let ForInStatement: Type<ForInStatement>;
-    let DebuggerStatement: Type<DebuggerStatement>;
-    let FunctionDeclaration: Type<FunctionDeclaration>;
-    let FunctionExpression: Type<FunctionExpression>;
-    let VariableDeclarator: Type<VariableDeclarator>;
-    let ThisExpression: Type<ThisExpression>;
-    let ArrayExpression: Type<ArrayExpression>;
-    let ObjectExpression: Type<ObjectExpression>;
-    let Property: Type<Property>;
-    let Literal: Type<Literal>;
-    let SequenceExpression: Type<SequenceExpression>;
-    let UnaryExpression: Type<UnaryExpression>;
-    let BinaryExpression: Type<BinaryExpression>;
-    let AssignmentExpression: Type<AssignmentExpression>;
-    let ChainElement: Type<ChainElement>;
-    let MemberExpression: Type<MemberExpression>;
-    let UpdateExpression: Type<UpdateExpression>;
-    let LogicalExpression: Type<LogicalExpression>;
-    let ConditionalExpression: Type<ConditionalExpression>;
-    let NewExpression: Type<NewExpression>;
-    let CallExpression: Type<CallExpression>;
-    let RestElement: Type<RestElement>;
-    let TypeAnnotation: Type<TypeAnnotation>;
-    let TSTypeAnnotation: Type<TSTypeAnnotation>;
-    let SpreadElementPattern: Type<SpreadElementPattern>;
-    let ArrowFunctionExpression: Type<ArrowFunctionExpression>;
-    let ForOfStatement: Type<ForOfStatement>;
-    let YieldExpression: Type<YieldExpression>;
-    let GeneratorExpression: Type<GeneratorExpression>;
-    let ComprehensionBlock: Type<ComprehensionBlock>;
-    let ComprehensionExpression: Type<ComprehensionExpression>;
-    let ObjectProperty: Type<ObjectProperty>;
-    let PropertyPattern: Type<PropertyPattern>;
-    let ObjectPattern: Type<ObjectPattern>;
-    let ArrayPattern: Type<ArrayPattern>;
-    let SpreadElement: Type<SpreadElement>;
-    let AssignmentPattern: Type<AssignmentPattern>;
-    let MethodDefinition: Type<MethodDefinition>;
-    let ClassPropertyDefinition: Type<ClassPropertyDefinition>;
-    let ClassProperty: Type<ClassProperty>;
-    let StaticBlock: Type<StaticBlock>;
-    let ClassBody: Type<ClassBody>;
-    let ClassDeclaration: Type<ClassDeclaration>;
-    let ClassExpression: Type<ClassExpression>;
-    let Super: Type<Super>;
-    let Specifier: Type<Specifier>;
-    let ModuleSpecifier: Type<ModuleSpecifier>;
-    let ImportSpecifier: Type<ImportSpecifier>;
-    let ImportDefaultSpecifier: Type<ImportDefaultSpecifier>;
-    let ImportNamespaceSpecifier: Type<ImportNamespaceSpecifier>;
-    let ImportDeclaration: Type<ImportDeclaration>;
-    let ExportNamedDeclaration: Type<ExportNamedDeclaration>;
-    let ExportSpecifier: Type<ExportSpecifier>;
-    let ExportDefaultDeclaration: Type<ExportDefaultDeclaration>;
-    let ExportAllDeclaration: Type<ExportAllDeclaration>;
-    let TaggedTemplateExpression: Type<TaggedTemplateExpression>;
-    let TemplateLiteral: Type<TemplateLiteral>;
-    let TemplateElement: Type<TemplateElement>;
-    let MetaProperty: Type<MetaProperty>;
-    let AwaitExpression: Type<AwaitExpression>;
-    let SpreadProperty: Type<SpreadProperty>;
-    let SpreadPropertyPattern: Type<SpreadPropertyPattern>;
-    let ImportExpression: Type<ImportExpression>;
-    let ChainExpression: Type<ChainExpression>;
-    let OptionalCallExpression: Type<OptionalCallExpression>;
-    let OptionalMemberExpression: Type<OptionalMemberExpression>;
-    let Decorator: Type<Decorator>;
-    let PrivateName: Type<PrivateName>;
-    let ClassPrivateProperty: Type<ClassPrivateProperty>;
-    let ImportAttribute: Type<ImportAttribute>;
-    let RecordExpression: Type<RecordExpression>;
-    let ObjectMethod: Type<ObjectMethod>;
-    let TupleExpression: Type<TupleExpression>;
-    let ModuleExpression: Type<ModuleExpression>;
-    let JSXAttribute: Type<JSXAttribute>;
-    let JSXIdentifier: Type<JSXIdentifier>;
-    let JSXNamespacedName: Type<JSXNamespacedName>;
-    let JSXExpressionContainer: Type<JSXExpressionContainer>;
-    let JSXElement: Type<JSXElement>;
-    let JSXFragment: Type<JSXFragment>;
-    let JSXMemberExpression: Type<JSXMemberExpression>;
-    let JSXSpreadAttribute: Type<JSXSpreadAttribute>;
-    let JSXEmptyExpression: Type<JSXEmptyExpression>;
-    let JSXText: Type<JSXText>;
-    let JSXSpreadChild: Type<JSXSpreadChild>;
-    let JSXOpeningElement: Type<JSXOpeningElement>;
-    let JSXClosingElement: Type<JSXClosingElement>;
-    let JSXOpeningFragment: Type<JSXOpeningFragment>;
-    let JSXClosingFragment: Type<JSXClosingFragment>;
-    let TypeParameterDeclaration: Type<TypeParameterDeclaration>;
-    let TSTypeParameterDeclaration: Type<TSTypeParameterDeclaration>;
-    let TypeParameterInstantiation: Type<TypeParameterInstantiation>;
-    let TSTypeParameterInstantiation: Type<TSTypeParameterInstantiation>;
-    let ClassImplements: Type<ClassImplements>;
-    let TSType: Type<TSType>;
-    let TSHasOptionalTypeParameterInstantiation: Type<TSHasOptionalTypeParameterInstantiation>;
-    let TSExpressionWithTypeArguments: Type<TSExpressionWithTypeArguments>;
-    let Flow: Type<Flow>;
-    let FlowType: Type<FlowType>;
-    let AnyTypeAnnotation: Type<AnyTypeAnnotation>;
-    let EmptyTypeAnnotation: Type<EmptyTypeAnnotation>;
-    let MixedTypeAnnotation: Type<MixedTypeAnnotation>;
-    let VoidTypeAnnotation: Type<VoidTypeAnnotation>;
-    let SymbolTypeAnnotation: Type<SymbolTypeAnnotation>;
-    let NumberTypeAnnotation: Type<NumberTypeAnnotation>;
-    let BigIntTypeAnnotation: Type<BigIntTypeAnnotation>;
-    let NumberLiteralTypeAnnotation: Type<NumberLiteralTypeAnnotation>;
-    let NumericLiteralTypeAnnotation: Type<NumericLiteralTypeAnnotation>;
-    let BigIntLiteralTypeAnnotation: Type<BigIntLiteralTypeAnnotation>;
-    let StringTypeAnnotation: Type<StringTypeAnnotation>;
-    let StringLiteralTypeAnnotation: Type<StringLiteralTypeAnnotation>;
-    let BooleanTypeAnnotation: Type<BooleanTypeAnnotation>;
-    let BooleanLiteralTypeAnnotation: Type<BooleanLiteralTypeAnnotation>;
-    let NullableTypeAnnotation: Type<NullableTypeAnnotation>;
-    let NullLiteralTypeAnnotation: Type<NullLiteralTypeAnnotation>;
-    let NullTypeAnnotation: Type<NullTypeAnnotation>;
-    let ThisTypeAnnotation: Type<ThisTypeAnnotation>;
-    let ExistsTypeAnnotation: Type<ExistsTypeAnnotation>;
-    let ExistentialTypeParam: Type<ExistentialTypeParam>;
-    let FunctionTypeAnnotation: Type<FunctionTypeAnnotation>;
-    let FunctionTypeParam: Type<FunctionTypeParam>;
-    let ArrayTypeAnnotation: Type<ArrayTypeAnnotation>;
-    let ObjectTypeAnnotation: Type<ObjectTypeAnnotation>;
-    let ObjectTypeProperty: Type<ObjectTypeProperty>;
-    let ObjectTypeSpreadProperty: Type<ObjectTypeSpreadProperty>;
-    let ObjectTypeIndexer: Type<ObjectTypeIndexer>;
-    let ObjectTypeCallProperty: Type<ObjectTypeCallProperty>;
-    let ObjectTypeInternalSlot: Type<ObjectTypeInternalSlot>;
-    let Variance: Type<Variance>;
-    let QualifiedTypeIdentifier: Type<QualifiedTypeIdentifier>;
-    let GenericTypeAnnotation: Type<GenericTypeAnnotation>;
-    let MemberTypeAnnotation: Type<MemberTypeAnnotation>;
-    let IndexedAccessType: Type<IndexedAccessType>;
-    let OptionalIndexedAccessType: Type<OptionalIndexedAccessType>;
-    let UnionTypeAnnotation: Type<UnionTypeAnnotation>;
-    let IntersectionTypeAnnotation: Type<IntersectionTypeAnnotation>;
-    let TypeofTypeAnnotation: Type<TypeofTypeAnnotation>;
-    let TypeParameter: Type<TypeParameter>;
-    let InterfaceTypeAnnotation: Type<InterfaceTypeAnnotation>;
-    let InterfaceExtends: Type<InterfaceExtends>;
-    let InterfaceDeclaration: Type<InterfaceDeclaration>;
-    let DeclareInterface: Type<DeclareInterface>;
-    let TypeAlias: Type<TypeAlias>;
-    let DeclareTypeAlias: Type<DeclareTypeAlias>;
-    let OpaqueType: Type<OpaqueType>;
-    let DeclareOpaqueType: Type<DeclareOpaqueType>;
-    let TypeCastExpression: Type<TypeCastExpression>;
-    let TupleTypeAnnotation: Type<TupleTypeAnnotation>;
-    let DeclareVariable: Type<DeclareVariable>;
-    let DeclareFunction: Type<DeclareFunction>;
-    let FlowPredicate: Type<FlowPredicate>;
-    let DeclareClass: Type<DeclareClass>;
-    let DeclareModule: Type<DeclareModule>;
-    let DeclareModuleExports: Type<DeclareModuleExports>;
-    let DeclareExportDeclaration: Type<DeclareExportDeclaration>;
-    let ExportBatchSpecifier: Type<ExportBatchSpecifier>;
-    let DeclareExportAllDeclaration: Type<DeclareExportAllDeclaration>;
-    let InferredPredicate: Type<InferredPredicate>;
-    let DeclaredPredicate: Type<DeclaredPredicate>;
-    let EnumDeclaration: Type<EnumDeclaration>;
-    let EnumBooleanBody: Type<EnumBooleanBody>;
-    let EnumNumberBody: Type<EnumNumberBody>;
-    let EnumStringBody: Type<EnumStringBody>;
-    let EnumSymbolBody: Type<EnumSymbolBody>;
-    let EnumBooleanMember: Type<EnumBooleanMember>;
-    let EnumNumberMember: Type<EnumNumberMember>;
-    let EnumStringMember: Type<EnumStringMember>;
-    let EnumDefaultedMember: Type<EnumDefaultedMember>;
-    let ExportDeclaration: Type<ExportDeclaration>;
-    let Block: Type<Block>;
-    let Line: Type<Line>;
-    let Noop: Type<Noop>;
-    let DoExpression: Type<DoExpression>;
-    let BindExpression: Type<BindExpression>;
-    let ParenthesizedExpression: Type<ParenthesizedExpression>;
-    let ExportNamespaceSpecifier: Type<ExportNamespaceSpecifier>;
-    let ExportDefaultSpecifier: Type<ExportDefaultSpecifier>;
-    let CommentBlock: Type<CommentBlock>;
-    let CommentLine: Type<CommentLine>;
-    let Directive: Type<Directive>;
-    let DirectiveLiteral: Type<DirectiveLiteral>;
-    let InterpreterDirective: Type<InterpreterDirective>;
-    let StringLiteral: Type<StringLiteral>;
-    let NumericLiteral: Type<NumericLiteral>;
-    let BigIntLiteral: Type<BigIntLiteral>;
-    let DecimalLiteral: Type<DecimalLiteral>;
-    let NullLiteral: Type<NullLiteral>;
-    let BooleanLiteral: Type<BooleanLiteral>;
-    let RegExpLiteral: Type<RegExpLiteral>;
-    let ClassMethod: Type<ClassMethod>;
-    let ClassPrivateMethod: Type<ClassPrivateMethod>;
-    let TSHasOptionalTypeAnnotation: Type<TSHasOptionalTypeAnnotation>;
-    let ClassAccessorProperty: Type<ClassAccessorProperty>;
-    let RestProperty: Type<RestProperty>;
-    let ForAwaitStatement: Type<ForAwaitStatement>;
-    let Import: Type<Import>;
-    let V8IntrinsicIdentifier: Type<V8IntrinsicIdentifier>;
-    let TopicReference: Type<TopicReference>;
-    let TSQualifiedName: Type<TSQualifiedName>;
-    let TSTypeReference: Type<TSTypeReference>;
-    let TSHasOptionalTypeParameters: Type<TSHasOptionalTypeParameters>;
-    let TSAsExpression: Type<TSAsExpression>;
-    let TSTypeCastExpression: Type<TSTypeCastExpression>;
-    let TSSatisfiesExpression: Type<TSSatisfiesExpression>;
-    let TSNonNullExpression: Type<TSNonNullExpression>;
-    let TSAnyKeyword: Type<TSAnyKeyword>;
-    let TSBigIntKeyword: Type<TSBigIntKeyword>;
-    let TSBooleanKeyword: Type<TSBooleanKeyword>;
-    let TSNeverKeyword: Type<TSNeverKeyword>;
-    let TSNullKeyword: Type<TSNullKeyword>;
-    let TSNumberKeyword: Type<TSNumberKeyword>;
-    let TSObjectKeyword: Type<TSObjectKeyword>;
-    let TSStringKeyword: Type<TSStringKeyword>;
-    let TSSymbolKeyword: Type<TSSymbolKeyword>;
-    let TSUndefinedKeyword: Type<TSUndefinedKeyword>;
-    let TSUnknownKeyword: Type<TSUnknownKeyword>;
-    let TSVoidKeyword: Type<TSVoidKeyword>;
-    let TSIntrinsicKeyword: Type<TSIntrinsicKeyword>;
-    let TSThisType: Type<TSThisType>;
-    let TSArrayType: Type<TSArrayType>;
-    let TSLiteralType: Type<TSLiteralType>;
-    let TSUnionType: Type<TSUnionType>;
-    let TSIntersectionType: Type<TSIntersectionType>;
-    let TSConditionalType: Type<TSConditionalType>;
-    let TSInferType: Type<TSInferType>;
-    let TSTypeParameter: Type<TSTypeParameter>;
-    let TSParenthesizedType: Type<TSParenthesizedType>;
-    let TSFunctionType: Type<TSFunctionType>;
-    let TSConstructorType: Type<TSConstructorType>;
-    let TSDeclareFunction: Type<TSDeclareFunction>;
-    let TSDeclareMethod: Type<TSDeclareMethod>;
-    let TSMappedType: Type<TSMappedType>;
-    let TSTupleType: Type<TSTupleType>;
-    let TSNamedTupleMember: Type<TSNamedTupleMember>;
-    let TSRestType: Type<TSRestType>;
-    let TSOptionalType: Type<TSOptionalType>;
-    let TSIndexedAccessType: Type<TSIndexedAccessType>;
-    let TSTypeOperator: Type<TSTypeOperator>;
-    let TSIndexSignature: Type<TSIndexSignature>;
-    let TSPropertySignature: Type<TSPropertySignature>;
-    let TSMethodSignature: Type<TSMethodSignature>;
-    let TSTypePredicate: Type<TSTypePredicate>;
-    let TSCallSignatureDeclaration: Type<TSCallSignatureDeclaration>;
-    let TSConstructSignatureDeclaration: Type<TSConstructSignatureDeclaration>;
-    let TSEnumMember: Type<TSEnumMember>;
-    let TSTypeQuery: Type<TSTypeQuery>;
-    let TSImportType: Type<TSImportType>;
-    let TSTypeLiteral: Type<TSTypeLiteral>;
-    let TSTypeAssertion: Type<TSTypeAssertion>;
-    let TSInstantiationExpression: Type<TSInstantiationExpression>;
-    let TSEnumDeclaration: Type<TSEnumDeclaration>;
-    let TSTypeAliasDeclaration: Type<TSTypeAliasDeclaration>;
-    let TSModuleBlock: Type<TSModuleBlock>;
-    let TSModuleDeclaration: Type<TSModuleDeclaration>;
-    let TSImportEqualsDeclaration: Type<TSImportEqualsDeclaration>;
-    let TSExternalModuleReference: Type<TSExternalModuleReference>;
-    let TSExportAssignment: Type<TSExportAssignment>;
-    let TSNamespaceExportDeclaration: Type<TSNamespaceExportDeclaration>;
-    let TSInterfaceBody: Type<TSInterfaceBody>;
-    let TSInterfaceDeclaration: Type<TSInterfaceDeclaration>;
-    let TSParameterProperty: Type<TSParameterProperty>;
+  interface Printable {
+    loc?: K.SourceLocationKind | null
+  }
+  interface SourceLocation {
+    start: K.PositionKind
+    end: K.PositionKind
+    source?: string | null
+  }
+  interface Node extends Printable {
+    type: string
+    comments?: K.CommentKind[] | null
+  }
+  interface Comment extends Printable {
+    value: string
+    leading?: boolean
+    trailing?: boolean
+  }
+  interface Position {
+    line: number
+    column: number
+  }
+  interface File extends Omit<Node, 'type'> {
+    type: 'File'
+    program: K.ProgramKind
+    name?: string | null
+  }
+  interface Program extends Omit<Node, 'type'> {
+    type: 'Program'
+    body: K.StatementKind[]
+    directives?: K.DirectiveKind[]
+    interpreter?: K.InterpreterDirectiveKind | null
+  }
+  interface Statement extends Node {}
+  interface Function extends Node {
+    id?: K.IdentifierKind | null
+    params: K.PatternKind[]
+    body: K.BlockStatementKind
+    generator?: boolean
+    async?: boolean
+    expression?: boolean
+    defaults?: (K.ExpressionKind | null)[]
+    rest?: K.IdentifierKind | null
+    returnType?: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null
+    typeParameters?:
+      | K.TypeParameterDeclarationKind
+      | K.TSTypeParameterDeclarationKind
+      | null
+    predicate?: K.FlowPredicateKind | null
+  }
+  interface Expression extends Node {}
+  interface Pattern extends Node {}
+  interface Identifier extends Omit<Expression, 'type'>, Omit<Pattern, 'type'> {
+    type: 'Identifier'
+    name: string
+    optional?: boolean
+    typeAnnotation?: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null
+  }
+  interface BlockStatement extends Omit<Statement, 'type'> {
+    type: 'BlockStatement'
+    body: K.StatementKind[]
+    directives?: K.DirectiveKind[]
+  }
+  interface EmptyStatement extends Omit<Statement, 'type'> {
+    type: 'EmptyStatement'
+  }
+  interface ExpressionStatement extends Omit<Statement, 'type'> {
+    type: 'ExpressionStatement'
+    expression: K.ExpressionKind
+  }
+  interface IfStatement extends Omit<Statement, 'type'> {
+    type: 'IfStatement'
+    test: K.ExpressionKind
+    consequent: K.StatementKind
+    alternate?: K.StatementKind | null
+  }
+  interface LabeledStatement extends Omit<Statement, 'type'> {
+    type: 'LabeledStatement'
+    label: K.IdentifierKind
+    body: K.StatementKind
+  }
+  interface BreakStatement extends Omit<Statement, 'type'> {
+    type: 'BreakStatement'
+    label?: K.IdentifierKind | null
+  }
+  interface ContinueStatement extends Omit<Statement, 'type'> {
+    type: 'ContinueStatement'
+    label?: K.IdentifierKind | null
+  }
+  interface WithStatement extends Omit<Statement, 'type'> {
+    type: 'WithStatement'
+    object: K.ExpressionKind
+    body: K.StatementKind
+  }
+  interface SwitchStatement extends Omit<Statement, 'type'> {
+    type: 'SwitchStatement'
+    discriminant: K.ExpressionKind
+    cases: K.SwitchCaseKind[]
+    lexical?: boolean
+  }
+  interface SwitchCase extends Omit<Node, 'type'> {
+    type: 'SwitchCase'
+    test: K.ExpressionKind | null
+    consequent: K.StatementKind[]
+  }
+  interface ReturnStatement extends Omit<Statement, 'type'> {
+    type: 'ReturnStatement'
+    argument: K.ExpressionKind | null
+  }
+  interface ThrowStatement extends Omit<Statement, 'type'> {
+    type: 'ThrowStatement'
+    argument: K.ExpressionKind
+  }
+  interface TryStatement extends Omit<Statement, 'type'> {
+    type: 'TryStatement'
+    block: K.BlockStatementKind
+    handler?: K.CatchClauseKind | null
+    handlers?: K.CatchClauseKind[]
+    guardedHandlers?: K.CatchClauseKind[]
+    finalizer?: K.BlockStatementKind | null
+  }
+  interface CatchClause extends Omit<Node, 'type'> {
+    type: 'CatchClause'
+    param?: K.PatternKind | null
+    guard?: K.ExpressionKind | null
+    body: K.BlockStatementKind
+  }
+  interface WhileStatement extends Omit<Statement, 'type'> {
+    type: 'WhileStatement'
+    test: K.ExpressionKind
+    body: K.StatementKind
+  }
+  interface DoWhileStatement extends Omit<Statement, 'type'> {
+    type: 'DoWhileStatement'
+    body: K.StatementKind
+    test: K.ExpressionKind
+  }
+  interface ForStatement extends Omit<Statement, 'type'> {
+    type: 'ForStatement'
+    init: K.VariableDeclarationKind | K.ExpressionKind | null
+    test: K.ExpressionKind | null
+    update: K.ExpressionKind | null
+    body: K.StatementKind
+  }
+  interface Declaration extends Statement {}
+  interface VariableDeclaration extends Omit<Declaration, 'type'> {
+    type: 'VariableDeclaration'
+    kind: 'var' | 'let' | 'const'
+    declarations: (K.VariableDeclaratorKind | K.IdentifierKind)[]
+  }
+  interface ForInStatement extends Omit<Statement, 'type'> {
+    type: 'ForInStatement'
+    left: K.VariableDeclarationKind | K.ExpressionKind
+    right: K.ExpressionKind
+    body: K.StatementKind
+  }
+  interface DebuggerStatement extends Omit<Statement, 'type'> {
+    type: 'DebuggerStatement'
+  }
+  interface FunctionDeclaration
+    extends Omit<Function, 'type' | 'id'>,
+      Omit<Declaration, 'type'> {
+    type: 'FunctionDeclaration'
+    id: K.IdentifierKind | null
+  }
+  interface FunctionExpression
+    extends Omit<Function, 'type'>,
+      Omit<Expression, 'type'> {
+    type: 'FunctionExpression'
+  }
+  interface VariableDeclarator extends Omit<Node, 'type'> {
+    type: 'VariableDeclarator'
+    id: K.PatternKind
+    init?: K.ExpressionKind | null
+  }
+  interface ThisExpression extends Omit<Expression, 'type'> {
+    type: 'ThisExpression'
+  }
+  interface ArrayExpression extends Omit<Expression, 'type'> {
+    type: 'ArrayExpression'
+    elements: (
+      | K.ExpressionKind
+      | K.SpreadElementKind
+      | K.RestElementKind
+      | null
+    )[]
+  }
+  interface ObjectExpression extends Omit<Expression, 'type'> {
+    type: 'ObjectExpression'
+    properties: (
+      | K.PropertyKind
+      | K.ObjectMethodKind
+      | K.ObjectPropertyKind
+      | K.SpreadPropertyKind
+      | K.SpreadElementKind
+    )[]
+  }
+  interface Property extends Omit<Node, 'type'> {
+    type: 'Property'
+    kind: 'init' | 'get' | 'set'
+    key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind
+    value: K.ExpressionKind | K.PatternKind
+    method?: boolean
+    shorthand?: boolean
+    computed?: boolean
+    decorators?: K.DecoratorKind[] | null
+  }
+  interface Literal extends Omit<Expression, 'type'> {
+    type: 'Literal'
+    value: string | boolean | null | number | RegExp | BigInt
+  }
+  interface SequenceExpression extends Omit<Expression, 'type'> {
+    type: 'SequenceExpression'
+    expressions: K.ExpressionKind[]
+  }
+  interface UnaryExpression extends Omit<Expression, 'type'> {
+    type: 'UnaryExpression'
+    operator: '-' | '+' | '!' | '~' | 'typeof' | 'void' | 'delete'
+    argument: K.ExpressionKind
+    prefix?: boolean
+  }
+  interface BinaryExpression extends Omit<Expression, 'type'> {
+    type: 'BinaryExpression'
+    operator:
+      | '=='
+      | '!='
+      | '==='
+      | '!=='
+      | '<'
+      | '<='
+      | '>'
+      | '>='
+      | '<<'
+      | '>>'
+      | '>>>'
+      | '+'
+      | '-'
+      | '*'
+      | '/'
+      | '%'
+      | '&'
+      | '|'
+      | '^'
+      | 'in'
+      | 'instanceof'
+      | '**'
+    left: K.ExpressionKind
+    right: K.ExpressionKind
+  }
+  interface AssignmentExpression extends Omit<Expression, 'type'> {
+    type: 'AssignmentExpression'
+    operator:
+      | '='
+      | '+='
+      | '-='
+      | '*='
+      | '/='
+      | '%='
+      | '<<='
+      | '>>='
+      | '>>>='
+      | '|='
+      | '^='
+      | '&='
+      | '**='
+      | '||='
+      | '&&='
+      | '??='
+    left: K.PatternKind | K.MemberExpressionKind
+    right: K.ExpressionKind
+  }
+  interface ChainElement extends Node {
+    optional?: boolean
+  }
+  interface MemberExpression
+    extends Omit<Expression, 'type'>,
+      Omit<ChainElement, 'type'> {
+    type: 'MemberExpression'
+    object: K.ExpressionKind
+    property: K.IdentifierKind | K.ExpressionKind
+    computed?: boolean
+  }
+  interface UpdateExpression extends Omit<Expression, 'type'> {
+    type: 'UpdateExpression'
+    operator: '++' | '--'
+    argument: K.ExpressionKind
+    prefix: boolean
+  }
+  interface LogicalExpression extends Omit<Expression, 'type'> {
+    type: 'LogicalExpression'
+    operator: '||' | '&&' | '??'
+    left: K.ExpressionKind
+    right: K.ExpressionKind
+  }
+  interface ConditionalExpression extends Omit<Expression, 'type'> {
+    type: 'ConditionalExpression'
+    test: K.ExpressionKind
+    consequent: K.ExpressionKind
+    alternate: K.ExpressionKind
+  }
+  interface NewExpression extends Omit<Expression, 'type'> {
+    type: 'NewExpression'
+    callee: K.ExpressionKind
+    arguments: (K.ExpressionKind | K.SpreadElementKind)[]
+    typeArguments?: null | K.TypeParameterInstantiationKind
+  }
+  interface CallExpression
+    extends Omit<Expression, 'type'>,
+      Omit<ChainElement, 'type'> {
+    type: 'CallExpression'
+    callee: K.ExpressionKind
+    arguments: (K.ExpressionKind | K.SpreadElementKind)[]
+    typeArguments?: null | K.TypeParameterInstantiationKind
+    typeParameters?: null | K.TSTypeParameterInstantiationKind
+  }
+  interface RestElement extends Omit<Pattern, 'type'> {
+    type: 'RestElement'
+    argument: K.PatternKind
+    typeAnnotation?: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null
+  }
+  interface TypeAnnotation extends Omit<Node, 'type'> {
+    type: 'TypeAnnotation'
+    typeAnnotation: K.FlowTypeKind
+  }
+  interface TSTypeAnnotation extends Omit<Node, 'type'> {
+    type: 'TSTypeAnnotation'
+    typeAnnotation: K.TSTypeKind | K.TSTypeAnnotationKind
+  }
+  interface SpreadElementPattern extends Omit<Pattern, 'type'> {
+    type: 'SpreadElementPattern'
+    argument: K.PatternKind
+  }
+  interface ArrowFunctionExpression
+    extends Omit<Function, 'type' | 'id' | 'body' | 'generator'>,
+      Omit<Expression, 'type'> {
+    type: 'ArrowFunctionExpression'
+    id?: null
+    body: K.BlockStatementKind | K.ExpressionKind
+    generator?: false
+  }
+  interface ForOfStatement extends Omit<Statement, 'type'> {
+    type: 'ForOfStatement'
+    left: K.VariableDeclarationKind | K.PatternKind
+    right: K.ExpressionKind
+    body: K.StatementKind
+    await?: boolean
+  }
+  interface YieldExpression extends Omit<Expression, 'type'> {
+    type: 'YieldExpression'
+    argument: K.ExpressionKind | null
+    delegate?: boolean
+  }
+  interface GeneratorExpression extends Omit<Expression, 'type'> {
+    type: 'GeneratorExpression'
+    body: K.ExpressionKind
+    blocks: K.ComprehensionBlockKind[]
+    filter: K.ExpressionKind | null
+  }
+  interface ComprehensionBlock extends Omit<Node, 'type'> {
+    type: 'ComprehensionBlock'
+    left: K.PatternKind
+    right: K.ExpressionKind
+    each: boolean
+  }
+  interface ComprehensionExpression extends Omit<Expression, 'type'> {
+    type: 'ComprehensionExpression'
+    body: K.ExpressionKind
+    blocks: K.ComprehensionBlockKind[]
+    filter: K.ExpressionKind | null
+  }
+  interface ObjectProperty extends Omit<Node, 'type'> {
+    shorthand?: boolean
+    type: 'ObjectProperty'
+    key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind
+    value: K.ExpressionKind | K.PatternKind
+    accessibility?: K.LiteralKind | null
+    computed?: boolean
+  }
+  interface PropertyPattern extends Omit<Pattern, 'type'> {
+    type: 'PropertyPattern'
+    key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind
+    pattern: K.PatternKind
+    computed?: boolean
+  }
+  interface ObjectPattern extends Omit<Pattern, 'type'> {
+    type: 'ObjectPattern'
+    properties: (
+      | K.PropertyKind
+      | K.PropertyPatternKind
+      | K.SpreadPropertyPatternKind
+      | K.SpreadPropertyKind
+      | K.ObjectPropertyKind
+      | K.RestPropertyKind
+      | K.RestElementKind
+    )[]
+    typeAnnotation?: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null
+    decorators?: K.DecoratorKind[] | null
+  }
+  interface ArrayPattern extends Omit<Pattern, 'type'> {
+    type: 'ArrayPattern'
+    elements: (K.PatternKind | K.SpreadElementKind | null)[]
+  }
+  interface SpreadElement extends Omit<Node, 'type'> {
+    type: 'SpreadElement'
+    argument: K.ExpressionKind
+  }
+  interface AssignmentPattern extends Omit<Pattern, 'type'> {
+    type: 'AssignmentPattern'
+    left: K.PatternKind
+    right: K.ExpressionKind
+  }
+  interface MethodDefinition extends Omit<Declaration, 'type'> {
+    type: 'MethodDefinition'
+    kind: 'constructor' | 'method' | 'get' | 'set'
+    key: K.ExpressionKind
+    value: K.FunctionKind
+    computed?: boolean
+    static?: boolean
+    decorators?: K.DecoratorKind[] | null
+  }
+  interface ClassPropertyDefinition extends Omit<Declaration, 'type'> {
+    type: 'ClassPropertyDefinition'
+    definition:
+      | K.MethodDefinitionKind
+      | K.VariableDeclaratorKind
+      | K.ClassPropertyDefinitionKind
+      | K.ClassPropertyKind
+      | K.StaticBlockKind
+  }
+  interface ClassProperty extends Omit<Declaration, 'type'> {
+    type: 'ClassProperty'
+    key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind
+    computed?: boolean
+    value: K.ExpressionKind | null
+    static?: boolean
+    typeAnnotation?: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null
+    variance?: K.VarianceKind | 'plus' | 'minus' | null
+    access?: 'public' | 'private' | 'protected' | undefined
+  }
+  interface StaticBlock extends Omit<Declaration, 'type'> {
+    type: 'StaticBlock'
+    body: K.StatementKind[]
+  }
+  interface ClassBody extends Omit<Declaration, 'type'> {
+    type: 'ClassBody'
+    body: (
+      | K.MethodDefinitionKind
+      | K.VariableDeclaratorKind
+      | K.ClassPropertyDefinitionKind
+      | K.ClassPropertyKind
+      | K.ClassPrivatePropertyKind
+      | K.ClassAccessorPropertyKind
+      | K.ClassMethodKind
+      | K.ClassPrivateMethodKind
+      | K.StaticBlockKind
+      | K.TSDeclareMethodKind
+      | K.TSCallSignatureDeclarationKind
+      | K.TSConstructSignatureDeclarationKind
+      | K.TSIndexSignatureKind
+      | K.TSMethodSignatureKind
+      | K.TSPropertySignatureKind
+    )[]
+  }
+  interface ClassDeclaration extends Omit<Declaration, 'type'> {
+    type: 'ClassDeclaration'
+    id: K.IdentifierKind | null
+    body: K.ClassBodyKind
+    superClass?: K.ExpressionKind | null
+    typeParameters?:
+      | K.TypeParameterDeclarationKind
+      | K.TSTypeParameterDeclarationKind
+      | null
+    superTypeParameters?:
+      | K.TypeParameterInstantiationKind
+      | K.TSTypeParameterInstantiationKind
+      | null
+    implements?: K.ClassImplementsKind[] | K.TSExpressionWithTypeArgumentsKind[]
+  }
+  interface ClassExpression extends Omit<Expression, 'type'> {
+    type: 'ClassExpression'
+    id?: K.IdentifierKind | null
+    body: K.ClassBodyKind
+    superClass?: K.ExpressionKind | null
+    typeParameters?:
+      | K.TypeParameterDeclarationKind
+      | K.TSTypeParameterDeclarationKind
+      | null
+    superTypeParameters?:
+      | K.TypeParameterInstantiationKind
+      | K.TSTypeParameterInstantiationKind
+      | null
+    implements?: K.ClassImplementsKind[] | K.TSExpressionWithTypeArgumentsKind[]
+  }
+  interface Super extends Omit<Expression, 'type'> {
+    type: 'Super'
+  }
+  interface Specifier extends Node {}
+  interface ModuleSpecifier extends Specifier {
+    local?: K.IdentifierKind | null
+    id?: K.IdentifierKind | null
+    name?: K.IdentifierKind | null
+  }
+  interface ImportSpecifier extends Omit<ModuleSpecifier, 'type'> {
+    type: 'ImportSpecifier'
+    imported: K.IdentifierKind
+  }
+  interface ImportDefaultSpecifier extends Omit<ModuleSpecifier, 'type'> {
+    type: 'ImportDefaultSpecifier'
+  }
+  interface ImportNamespaceSpecifier extends Omit<ModuleSpecifier, 'type'> {
+    type: 'ImportNamespaceSpecifier'
+  }
+  interface ImportDeclaration extends Omit<Declaration, 'type'> {
+    type: 'ImportDeclaration'
+    specifiers?: (
+      | K.ImportSpecifierKind
+      | K.ImportNamespaceSpecifierKind
+      | K.ImportDefaultSpecifierKind
+    )[]
+    source: K.LiteralKind
+    importKind?: 'value' | 'type' | 'typeof'
+    assertions?: K.ImportAttributeKind[]
+  }
+  interface ExportNamedDeclaration extends Omit<Declaration, 'type'> {
+    type: 'ExportNamedDeclaration'
+    declaration: K.DeclarationKind | null
+    specifiers?: K.ExportSpecifierKind[]
+    source?: K.LiteralKind | null
+    assertions?: K.ImportAttributeKind[]
+  }
+  interface ExportSpecifier extends Omit<ModuleSpecifier, 'type'> {
+    type: 'ExportSpecifier'
+    exported: K.IdentifierKind
+  }
+  interface ExportDefaultDeclaration extends Omit<Declaration, 'type'> {
+    type: 'ExportDefaultDeclaration'
+    declaration: K.DeclarationKind | K.ExpressionKind
+  }
+  interface ExportAllDeclaration extends Omit<Declaration, 'type'> {
+    type: 'ExportAllDeclaration'
+    source: K.LiteralKind
+    exported?: K.IdentifierKind | null | undefined
+    assertions?: K.ImportAttributeKind[]
+  }
+  interface TaggedTemplateExpression extends Omit<Expression, 'type'> {
+    type: 'TaggedTemplateExpression'
+    tag: K.ExpressionKind
+    quasi: K.TemplateLiteralKind
+  }
+  interface TemplateLiteral extends Omit<Expression, 'type'> {
+    type: 'TemplateLiteral'
+    quasis: K.TemplateElementKind[]
+    expressions: K.ExpressionKind[] | K.TSTypeKind[]
+  }
+  interface TemplateElement extends Omit<Node, 'type'> {
+    type: 'TemplateElement'
+    value: {
+      cooked: string | null
+      raw: string
+    }
+    tail: boolean
+  }
+  interface MetaProperty extends Omit<Expression, 'type'> {
+    type: 'MetaProperty'
+    meta: K.IdentifierKind
+    property: K.IdentifierKind
+  }
+  interface AwaitExpression extends Omit<Expression, 'type'> {
+    type: 'AwaitExpression'
+    argument: K.ExpressionKind | null
+    all?: boolean
+  }
+  interface SpreadProperty extends Omit<Node, 'type'> {
+    type: 'SpreadProperty'
+    argument: K.ExpressionKind
+  }
+  interface SpreadPropertyPattern extends Omit<Pattern, 'type'> {
+    type: 'SpreadPropertyPattern'
+    argument: K.PatternKind
+  }
+  interface ImportExpression extends Omit<Expression, 'type'> {
+    type: 'ImportExpression'
+    source: K.ExpressionKind
+  }
+  interface ChainExpression extends Omit<Expression, 'type'> {
+    type: 'ChainExpression'
+    expression: K.ChainElementKind
+  }
+  interface OptionalCallExpression
+    extends Omit<CallExpression, 'type' | 'optional'> {
+    type: 'OptionalCallExpression'
+    optional?: boolean
+  }
+  interface OptionalMemberExpression
+    extends Omit<MemberExpression, 'type' | 'optional'> {
+    type: 'OptionalMemberExpression'
+    optional?: boolean
+  }
+  interface Decorator extends Omit<Node, 'type'> {
+    type: 'Decorator'
+    expression: K.ExpressionKind
+  }
+  interface PrivateName
+    extends Omit<Expression, 'type'>,
+      Omit<Pattern, 'type'> {
+    type: 'PrivateName'
+    id: K.IdentifierKind
+  }
+  interface ClassPrivateProperty
+    extends Omit<ClassProperty, 'type' | 'key' | 'value'> {
+    type: 'ClassPrivateProperty'
+    key: K.PrivateNameKind
+    value?: K.ExpressionKind | null
+  }
+  interface ImportAttribute extends Omit<Node, 'type'> {
+    type: 'ImportAttribute'
+    key: K.IdentifierKind | K.LiteralKind
+    value: K.ExpressionKind
+  }
+  interface RecordExpression extends Omit<Expression, 'type'> {
+    type: 'RecordExpression'
+    properties: (
+      | K.ObjectPropertyKind
+      | K.ObjectMethodKind
+      | K.SpreadElementKind
+    )[]
+  }
+  interface ObjectMethod
+    extends Omit<Node, 'type'>,
+      Omit<Function, 'type' | 'params' | 'body' | 'generator' | 'async'> {
+    type: 'ObjectMethod'
+    kind: 'method' | 'get' | 'set'
+    key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind
+    params: K.PatternKind[]
+    body: K.BlockStatementKind
+    computed?: boolean
+    generator?: boolean
+    async?: boolean
+    accessibility?: K.LiteralKind | null
+    decorators?: K.DecoratorKind[] | null
+  }
+  interface TupleExpression extends Omit<Expression, 'type'> {
+    type: 'TupleExpression'
+    elements: (K.ExpressionKind | K.SpreadElementKind | null)[]
+  }
+  interface ModuleExpression extends Omit<Node, 'type'> {
+    type: 'ModuleExpression'
+    body: K.ProgramKind
+  }
+  interface JSXAttribute extends Omit<Node, 'type'> {
+    type: 'JSXAttribute'
+    name: K.JSXIdentifierKind | K.JSXNamespacedNameKind
+    value?:
+      | K.LiteralKind
+      | K.JSXExpressionContainerKind
+      | K.JSXElementKind
+      | K.JSXFragmentKind
+      | null
+  }
+  interface JSXIdentifier extends Omit<Identifier, 'type' | 'name'> {
+    type: 'JSXIdentifier'
+    name: string
+  }
+  interface JSXNamespacedName extends Omit<Node, 'type'> {
+    type: 'JSXNamespacedName'
+    namespace: K.JSXIdentifierKind
+    name: K.JSXIdentifierKind
+  }
+  interface JSXExpressionContainer extends Omit<Expression, 'type'> {
+    type: 'JSXExpressionContainer'
+    expression: K.ExpressionKind | K.JSXEmptyExpressionKind
+  }
+  interface JSXElement extends Omit<Expression, 'type'> {
+    type: 'JSXElement'
+    openingElement: K.JSXOpeningElementKind
+    closingElement?: K.JSXClosingElementKind | null
+    children?: (
+      | K.JSXTextKind
+      | K.JSXExpressionContainerKind
+      | K.JSXSpreadChildKind
+      | K.JSXElementKind
+      | K.JSXFragmentKind
+      | K.LiteralKind
+    )[]
+    name?:
+      | K.JSXIdentifierKind
+      | K.JSXNamespacedNameKind
+      | K.JSXMemberExpressionKind
+    selfClosing?: boolean
+    attributes?: (K.JSXAttributeKind | K.JSXSpreadAttributeKind)[]
+  }
+  interface JSXFragment extends Omit<Expression, 'type'> {
+    type: 'JSXFragment'
+    openingFragment: K.JSXOpeningFragmentKind
+    closingFragment: K.JSXClosingFragmentKind
+    children?: (
+      | K.JSXTextKind
+      | K.JSXExpressionContainerKind
+      | K.JSXSpreadChildKind
+      | K.JSXElementKind
+      | K.JSXFragmentKind
+      | K.LiteralKind
+    )[]
+  }
+  interface JSXMemberExpression
+    extends Omit<
+      MemberExpression,
+      'type' | 'object' | 'property' | 'computed'
+    > {
+    type: 'JSXMemberExpression'
+    object: K.JSXIdentifierKind | K.JSXMemberExpressionKind
+    property: K.JSXIdentifierKind
+    computed?: boolean
+  }
+  interface JSXSpreadAttribute extends Omit<Node, 'type'> {
+    type: 'JSXSpreadAttribute'
+    argument: K.ExpressionKind
+  }
+  interface JSXEmptyExpression extends Omit<Node, 'type'> {
+    type: 'JSXEmptyExpression'
+  }
+  interface JSXText extends Omit<Literal, 'type' | 'value'> {
+    type: 'JSXText'
+    value: string
+    raw?: string
+  }
+  interface JSXSpreadChild extends Omit<Node, 'type'> {
+    type: 'JSXSpreadChild'
+    expression: K.ExpressionKind
+  }
+  interface JSXOpeningElement extends Omit<Node, 'type'> {
+    type: 'JSXOpeningElement'
+    name:
+      | K.JSXIdentifierKind
+      | K.JSXNamespacedNameKind
+      | K.JSXMemberExpressionKind
+    attributes?: (K.JSXAttributeKind | K.JSXSpreadAttributeKind)[]
+    selfClosing?: boolean
+  }
+  interface JSXClosingElement extends Omit<Node, 'type'> {
+    type: 'JSXClosingElement'
+    name:
+      | K.JSXIdentifierKind
+      | K.JSXNamespacedNameKind
+      | K.JSXMemberExpressionKind
+  }
+  interface JSXOpeningFragment extends Omit<Node, 'type'> {
+    type: 'JSXOpeningFragment'
+  }
+  interface JSXClosingFragment extends Omit<Node, 'type'> {
+    type: 'JSXClosingFragment'
+  }
+  interface TypeParameterDeclaration extends Omit<Node, 'type'> {
+    type: 'TypeParameterDeclaration'
+    params: K.TypeParameterKind[]
+  }
+  interface TSTypeParameterDeclaration extends Omit<Declaration, 'type'> {
+    type: 'TSTypeParameterDeclaration'
+    params: K.TSTypeParameterKind[]
+  }
+  interface TypeParameterInstantiation extends Omit<Node, 'type'> {
+    type: 'TypeParameterInstantiation'
+    params: K.FlowTypeKind[]
+  }
+  interface TSTypeParameterInstantiation extends Omit<Node, 'type'> {
+    type: 'TSTypeParameterInstantiation'
+    params: K.TSTypeKind[]
+  }
+  interface ClassImplements extends Omit<Node, 'type'> {
+    type: 'ClassImplements'
+    id: K.IdentifierKind
+    superClass?: K.ExpressionKind | null
+    typeParameters?: K.TypeParameterInstantiationKind | null
+  }
+  interface TSType extends Node {}
+  interface TSHasOptionalTypeParameterInstantiation {
+    typeParameters?: K.TSTypeParameterInstantiationKind | null
+  }
+  interface TSExpressionWithTypeArguments
+    extends Omit<TSType, 'type'>,
+      TSHasOptionalTypeParameterInstantiation {
+    type: 'TSExpressionWithTypeArguments'
+    expression: K.IdentifierKind | K.TSQualifiedNameKind
+  }
+  interface Flow extends Node {}
+  interface FlowType extends Flow {}
+  interface AnyTypeAnnotation extends Omit<FlowType, 'type'> {
+    type: 'AnyTypeAnnotation'
+  }
+  interface EmptyTypeAnnotation extends Omit<FlowType, 'type'> {
+    type: 'EmptyTypeAnnotation'
+  }
+  interface MixedTypeAnnotation extends Omit<FlowType, 'type'> {
+    type: 'MixedTypeAnnotation'
+  }
+  interface VoidTypeAnnotation extends Omit<FlowType, 'type'> {
+    type: 'VoidTypeAnnotation'
+  }
+  interface SymbolTypeAnnotation extends Omit<FlowType, 'type'> {
+    type: 'SymbolTypeAnnotation'
+  }
+  interface NumberTypeAnnotation extends Omit<FlowType, 'type'> {
+    type: 'NumberTypeAnnotation'
+  }
+  interface BigIntTypeAnnotation extends Omit<FlowType, 'type'> {
+    type: 'BigIntTypeAnnotation'
+  }
+  interface NumberLiteralTypeAnnotation extends Omit<FlowType, 'type'> {
+    type: 'NumberLiteralTypeAnnotation'
+    value: number
+    raw: string
+  }
+  interface NumericLiteralTypeAnnotation extends Omit<FlowType, 'type'> {
+    type: 'NumericLiteralTypeAnnotation'
+    value: number
+    raw: string
+  }
+  interface BigIntLiteralTypeAnnotation extends Omit<FlowType, 'type'> {
+    type: 'BigIntLiteralTypeAnnotation'
+    value: null
+    raw: string
+  }
+  interface StringTypeAnnotation extends Omit<FlowType, 'type'> {
+    type: 'StringTypeAnnotation'
+  }
+  interface StringLiteralTypeAnnotation extends Omit<FlowType, 'type'> {
+    type: 'StringLiteralTypeAnnotation'
+    value: string
+    raw: string
+  }
+  interface BooleanTypeAnnotation extends Omit<FlowType, 'type'> {
+    type: 'BooleanTypeAnnotation'
+  }
+  interface BooleanLiteralTypeAnnotation extends Omit<FlowType, 'type'> {
+    type: 'BooleanLiteralTypeAnnotation'
+    value: boolean
+    raw: string
+  }
+  interface NullableTypeAnnotation extends Omit<FlowType, 'type'> {
+    type: 'NullableTypeAnnotation'
+    typeAnnotation: K.FlowTypeKind
+  }
+  interface NullLiteralTypeAnnotation extends Omit<FlowType, 'type'> {
+    type: 'NullLiteralTypeAnnotation'
+  }
+  interface NullTypeAnnotation extends Omit<FlowType, 'type'> {
+    type: 'NullTypeAnnotation'
+  }
+  interface ThisTypeAnnotation extends Omit<FlowType, 'type'> {
+    type: 'ThisTypeAnnotation'
+  }
+  interface ExistsTypeAnnotation extends Omit<FlowType, 'type'> {
+    type: 'ExistsTypeAnnotation'
+  }
+  interface ExistentialTypeParam extends Omit<FlowType, 'type'> {
+    type: 'ExistentialTypeParam'
+  }
+  interface FunctionTypeAnnotation extends Omit<FlowType, 'type'> {
+    type: 'FunctionTypeAnnotation'
+    params: K.FunctionTypeParamKind[]
+    returnType: K.FlowTypeKind
+    rest: K.FunctionTypeParamKind | null
+    typeParameters: K.TypeParameterDeclarationKind | null
+  }
+  interface FunctionTypeParam extends Omit<Node, 'type'> {
+    type: 'FunctionTypeParam'
+    name: K.IdentifierKind | null
+    typeAnnotation: K.FlowTypeKind
+    optional: boolean
+  }
+  interface ArrayTypeAnnotation extends Omit<FlowType, 'type'> {
+    type: 'ArrayTypeAnnotation'
+    elementType: K.FlowTypeKind
+  }
+  interface ObjectTypeAnnotation extends Omit<FlowType, 'type'> {
+    type: 'ObjectTypeAnnotation'
+    properties: (K.ObjectTypePropertyKind | K.ObjectTypeSpreadPropertyKind)[]
+    indexers?: K.ObjectTypeIndexerKind[]
+    callProperties?: K.ObjectTypeCallPropertyKind[]
+    inexact?: boolean | undefined
+    exact?: boolean
+    internalSlots?: K.ObjectTypeInternalSlotKind[]
+  }
+  interface ObjectTypeProperty extends Omit<Node, 'type'> {
+    type: 'ObjectTypeProperty'
+    key: K.LiteralKind | K.IdentifierKind
+    value: K.FlowTypeKind
+    optional: boolean
+    variance?: K.VarianceKind | 'plus' | 'minus' | null
+  }
+  interface ObjectTypeSpreadProperty extends Omit<Node, 'type'> {
+    type: 'ObjectTypeSpreadProperty'
+    argument: K.FlowTypeKind
+  }
+  interface ObjectTypeIndexer extends Omit<Node, 'type'> {
+    type: 'ObjectTypeIndexer'
+    id: K.IdentifierKind
+    key: K.FlowTypeKind
+    value: K.FlowTypeKind
+    variance?: K.VarianceKind | 'plus' | 'minus' | null
+    static?: boolean
+  }
+  interface ObjectTypeCallProperty extends Omit<Node, 'type'> {
+    type: 'ObjectTypeCallProperty'
+    value: K.FunctionTypeAnnotationKind
+    static?: boolean
+  }
+  interface ObjectTypeInternalSlot extends Omit<Node, 'type'> {
+    type: 'ObjectTypeInternalSlot'
+    id: K.IdentifierKind
+    value: K.FlowTypeKind
+    optional: boolean
+    static: boolean
+    method: boolean
+  }
+  interface Variance extends Omit<Node, 'type'> {
+    type: 'Variance'
+    kind: 'plus' | 'minus'
+  }
+  interface QualifiedTypeIdentifier extends Omit<Node, 'type'> {
+    type: 'QualifiedTypeIdentifier'
+    qualification: K.IdentifierKind | K.QualifiedTypeIdentifierKind
+    id: K.IdentifierKind
+  }
+  interface GenericTypeAnnotation extends Omit<FlowType, 'type'> {
+    type: 'GenericTypeAnnotation'
+    id: K.IdentifierKind | K.QualifiedTypeIdentifierKind
+    typeParameters: K.TypeParameterInstantiationKind | null
+  }
+  interface MemberTypeAnnotation extends Omit<FlowType, 'type'> {
+    type: 'MemberTypeAnnotation'
+    object: K.IdentifierKind
+    property: K.MemberTypeAnnotationKind | K.GenericTypeAnnotationKind
+  }
+  interface IndexedAccessType extends Omit<FlowType, 'type'> {
+    type: 'IndexedAccessType'
+    objectType: K.FlowTypeKind
+    indexType: K.FlowTypeKind
+  }
+  interface OptionalIndexedAccessType extends Omit<FlowType, 'type'> {
+    type: 'OptionalIndexedAccessType'
+    objectType: K.FlowTypeKind
+    indexType: K.FlowTypeKind
+    optional: boolean
+  }
+  interface UnionTypeAnnotation extends Omit<FlowType, 'type'> {
+    type: 'UnionTypeAnnotation'
+    types: K.FlowTypeKind[]
+  }
+  interface IntersectionTypeAnnotation extends Omit<FlowType, 'type'> {
+    type: 'IntersectionTypeAnnotation'
+    types: K.FlowTypeKind[]
+  }
+  interface TypeofTypeAnnotation extends Omit<FlowType, 'type'> {
+    type: 'TypeofTypeAnnotation'
+    argument: K.FlowTypeKind
+  }
+  interface TypeParameter extends Omit<FlowType, 'type'> {
+    type: 'TypeParameter'
+    name: string
+    variance?: K.VarianceKind | 'plus' | 'minus' | null
+    bound?: K.TypeAnnotationKind | null
+    default?: K.FlowTypeKind | null
+  }
+  interface InterfaceTypeAnnotation extends Omit<FlowType, 'type'> {
+    type: 'InterfaceTypeAnnotation'
+    body: K.ObjectTypeAnnotationKind
+    extends?: K.InterfaceExtendsKind[] | null
+  }
+  interface InterfaceExtends extends Omit<Node, 'type'> {
+    type: 'InterfaceExtends'
+    id: K.IdentifierKind
+    typeParameters?: K.TypeParameterInstantiationKind | null
+  }
+  interface InterfaceDeclaration extends Omit<Declaration, 'type'> {
+    type: 'InterfaceDeclaration'
+    id: K.IdentifierKind
+    typeParameters?: K.TypeParameterDeclarationKind | null
+    body: K.ObjectTypeAnnotationKind
+    extends: K.InterfaceExtendsKind[]
+  }
+  interface DeclareInterface extends Omit<InterfaceDeclaration, 'type'> {
+    type: 'DeclareInterface'
+  }
+  interface TypeAlias extends Omit<Declaration, 'type'> {
+    type: 'TypeAlias'
+    id: K.IdentifierKind
+    typeParameters: K.TypeParameterDeclarationKind | null
+    right: K.FlowTypeKind
+  }
+  interface DeclareTypeAlias extends Omit<TypeAlias, 'type'> {
+    type: 'DeclareTypeAlias'
+  }
+  interface OpaqueType extends Omit<Declaration, 'type'> {
+    type: 'OpaqueType'
+    id: K.IdentifierKind
+    typeParameters: K.TypeParameterDeclarationKind | null
+    impltype: K.FlowTypeKind
+    supertype: K.FlowTypeKind | null
+  }
+  interface DeclareOpaqueType extends Omit<OpaqueType, 'type' | 'impltype'> {
+    type: 'DeclareOpaqueType'
+    impltype: K.FlowTypeKind | null
+  }
+  interface TypeCastExpression extends Omit<Expression, 'type'> {
+    type: 'TypeCastExpression'
+    expression: K.ExpressionKind
+    typeAnnotation: K.TypeAnnotationKind
+  }
+  interface TupleTypeAnnotation extends Omit<FlowType, 'type'> {
+    type: 'TupleTypeAnnotation'
+    types: K.FlowTypeKind[]
+  }
+  interface DeclareVariable extends Omit<Statement, 'type'> {
+    type: 'DeclareVariable'
+    id: K.IdentifierKind
+  }
+  interface DeclareFunction extends Omit<Statement, 'type'> {
+    type: 'DeclareFunction'
+    id: K.IdentifierKind
+    predicate?: K.FlowPredicateKind | null
+  }
+  interface FlowPredicate extends Flow {}
+  interface DeclareClass extends Omit<InterfaceDeclaration, 'type'> {
+    type: 'DeclareClass'
+  }
+  interface DeclareModule extends Omit<Statement, 'type'> {
+    type: 'DeclareModule'
+    id: K.IdentifierKind | K.LiteralKind
+    body: K.BlockStatementKind
+  }
+  interface DeclareModuleExports extends Omit<Statement, 'type'> {
+    type: 'DeclareModuleExports'
+    typeAnnotation: K.TypeAnnotationKind
+  }
+  interface DeclareExportDeclaration extends Omit<Declaration, 'type'> {
+    type: 'DeclareExportDeclaration'
+    default: boolean
+    declaration:
+      | K.DeclareVariableKind
+      | K.DeclareFunctionKind
+      | K.DeclareClassKind
+      | K.FlowTypeKind
+      | K.TypeAliasKind
+      | K.DeclareOpaqueTypeKind
+      | K.InterfaceDeclarationKind
+      | null
+    specifiers?: (K.ExportSpecifierKind | K.ExportBatchSpecifierKind)[]
+    source?: K.LiteralKind | null
+  }
+  interface ExportBatchSpecifier extends Omit<Specifier, 'type'> {
+    type: 'ExportBatchSpecifier'
+  }
+  interface DeclareExportAllDeclaration extends Omit<Declaration, 'type'> {
+    type: 'DeclareExportAllDeclaration'
+    source?: K.LiteralKind | null
+  }
+  interface InferredPredicate extends Omit<FlowPredicate, 'type'> {
+    type: 'InferredPredicate'
+  }
+  interface DeclaredPredicate extends Omit<FlowPredicate, 'type'> {
+    type: 'DeclaredPredicate'
+    value: K.ExpressionKind
+  }
+  interface EnumDeclaration extends Omit<Declaration, 'type'> {
+    type: 'EnumDeclaration'
+    id: K.IdentifierKind
+    body:
+      | K.EnumBooleanBodyKind
+      | K.EnumNumberBodyKind
+      | K.EnumStringBodyKind
+      | K.EnumSymbolBodyKind
+  }
+  interface EnumBooleanBody {
+    type: 'EnumBooleanBody'
+    members: K.EnumBooleanMemberKind[]
+    explicitType: boolean
+  }
+  interface EnumNumberBody {
+    type: 'EnumNumberBody'
+    members: K.EnumNumberMemberKind[]
+    explicitType: boolean
+  }
+  interface EnumStringBody {
+    type: 'EnumStringBody'
+    members: K.EnumStringMemberKind[] | K.EnumDefaultedMemberKind[]
+    explicitType: boolean
+  }
+  interface EnumSymbolBody {
+    type: 'EnumSymbolBody'
+    members: K.EnumDefaultedMemberKind[]
+  }
+  interface EnumBooleanMember {
+    type: 'EnumBooleanMember'
+    id: K.IdentifierKind
+    init: K.LiteralKind | boolean
+  }
+  interface EnumNumberMember {
+    type: 'EnumNumberMember'
+    id: K.IdentifierKind
+    init: K.LiteralKind
+  }
+  interface EnumStringMember {
+    type: 'EnumStringMember'
+    id: K.IdentifierKind
+    init: K.LiteralKind
+  }
+  interface EnumDefaultedMember {
+    type: 'EnumDefaultedMember'
+    id: K.IdentifierKind
+  }
+  interface ExportDeclaration extends Omit<Declaration, 'type'> {
+    type: 'ExportDeclaration'
+    default: boolean
+    declaration: K.DeclarationKind | K.ExpressionKind | null
+    specifiers?: (K.ExportSpecifierKind | K.ExportBatchSpecifierKind)[]
+    source?: K.LiteralKind | null
+  }
+  interface Block extends Comment {
+    type: 'Block'
+  }
+  interface Line extends Comment {
+    type: 'Line'
+  }
+  interface Noop extends Omit<Statement, 'type'> {
+    type: 'Noop'
+  }
+  interface DoExpression extends Omit<Expression, 'type'> {
+    type: 'DoExpression'
+    body: K.StatementKind[]
+  }
+  interface BindExpression extends Omit<Expression, 'type'> {
+    type: 'BindExpression'
+    object: K.ExpressionKind | null
+    callee: K.ExpressionKind
+  }
+  interface ParenthesizedExpression extends Omit<Expression, 'type'> {
+    type: 'ParenthesizedExpression'
+    expression: K.ExpressionKind
+  }
+  interface ExportNamespaceSpecifier extends Omit<Specifier, 'type'> {
+    type: 'ExportNamespaceSpecifier'
+    exported: K.IdentifierKind
+  }
+  interface ExportDefaultSpecifier extends Omit<Specifier, 'type'> {
+    type: 'ExportDefaultSpecifier'
+    exported: K.IdentifierKind
+  }
+  interface CommentBlock extends Comment {
+    type: 'CommentBlock'
+  }
+  interface CommentLine extends Comment {
+    type: 'CommentLine'
+  }
+  interface Directive extends Omit<Node, 'type'> {
+    type: 'Directive'
+    value: K.DirectiveLiteralKind
+  }
+  interface DirectiveLiteral
+    extends Omit<Node, 'type'>,
+      Omit<Expression, 'type'> {
+    type: 'DirectiveLiteral'
+    value?: string
+  }
+  interface InterpreterDirective extends Omit<Node, 'type'> {
+    type: 'InterpreterDirective'
+    value: string
+  }
+  interface StringLiteral extends Omit<Literal, 'type' | 'value'> {
+    type: 'StringLiteral'
+    value: string
+    extra?: {
+      rawValue: string
+      raw: string
+    }
+  }
+  interface NumericLiteral extends Omit<Literal, 'type' | 'value'> {
+    type: 'NumericLiteral'
+    value: number
+    raw?: string | null
+    extra?: {
+      rawValue: number
+      raw: string
+    }
+  }
+  interface BigIntLiteral extends Omit<Literal, 'type' | 'value'> {
+    type: 'BigIntLiteral'
+    value: string | number
+    extra?: {
+      rawValue: string
+      raw: string
+    }
+  }
+  interface DecimalLiteral extends Omit<Literal, 'type' | 'value'> {
+    type: 'DecimalLiteral'
+    value: string
+    extra?: {
+      rawValue: string
+      raw: string
+    }
+  }
+  interface NullLiteral extends Omit<Literal, 'type' | 'value'> {
+    type: 'NullLiteral'
+    value?: null
+  }
+  interface BooleanLiteral extends Omit<Literal, 'type' | 'value'> {
+    type: 'BooleanLiteral'
+    value: boolean
+  }
+  interface RegExpLiteral extends Omit<Literal, 'type' | 'value'> {
+    type: 'RegExpLiteral'
+    pattern: string
+    flags: string
+    value?: RegExp
+    extra?: {
+      rawValue: RegExp | undefined
+      raw: string
+    }
+    regex?: {
+      pattern: string
+      flags: string
+    }
+  }
+  interface ClassMethod
+    extends Omit<Declaration, 'type'>,
+      Omit<Function, 'type' | 'body'> {
+    type: 'ClassMethod'
+    key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind
+    kind?: 'get' | 'set' | 'method' | 'constructor'
+    body: K.BlockStatementKind
+    access?: 'public' | 'private' | 'protected' | null
+    computed?: boolean
+    static?: boolean
+    abstract?: boolean
+    accessibility?: 'public' | 'private' | 'protected' | null
+    decorators?: K.DecoratorKind[] | null
+    definite?: boolean
+    optional?: boolean
+    override?: boolean
+    readonly?: boolean
+  }
+  interface ClassPrivateMethod
+    extends Omit<Declaration, 'type'>,
+      Omit<Function, 'type' | 'body'> {
+    type: 'ClassPrivateMethod'
+    key: K.PrivateNameKind
+    kind?: 'get' | 'set' | 'method' | 'constructor'
+    body: K.BlockStatementKind
+    access?: 'public' | 'private' | 'protected' | null
+    computed?: boolean
+    static?: boolean
+    abstract?: boolean
+    accessibility?: 'public' | 'private' | 'protected' | null
+    decorators?: K.DecoratorKind[] | null
+    definite?: boolean
+    optional?: boolean
+    override?: boolean
+    readonly?: boolean
+  }
+  interface TSHasOptionalTypeAnnotation {
+    typeAnnotation?: K.TSTypeAnnotationKind | null
+  }
+  interface ClassAccessorProperty
+    extends Omit<Declaration, 'type'>,
+      TSHasOptionalTypeAnnotation {
+    type: 'ClassAccessorProperty'
+    key: K.LiteralKind | K.IdentifierKind | K.PrivateNameKind | K.ExpressionKind
+    value?: K.ExpressionKind | null
+    computed?: boolean
+    static?: boolean
+    abstract?: boolean
+    accessibility?: 'public' | 'private' | 'protected' | null
+    decorators?: K.DecoratorKind[] | null
+    definite?: boolean
+    optional?: boolean
+    override?: boolean
+    readonly?: boolean
+  }
+  interface RestProperty extends Omit<Node, 'type'> {
+    type: 'RestProperty'
+    argument: K.ExpressionKind
+  }
+  interface ForAwaitStatement extends Omit<Statement, 'type'> {
+    type: 'ForAwaitStatement'
+    left: K.VariableDeclarationKind | K.ExpressionKind
+    right: K.ExpressionKind
+    body: K.StatementKind
+  }
+  interface Import extends Omit<Expression, 'type'> {
+    type: 'Import'
+  }
+  interface V8IntrinsicIdentifier extends Omit<Expression, 'type'> {
+    type: 'V8IntrinsicIdentifier'
+    name: string
+  }
+  interface TopicReference extends Omit<Expression, 'type'> {
+    type: 'TopicReference'
+  }
+  interface TSQualifiedName extends Omit<Node, 'type'> {
+    type: 'TSQualifiedName'
+    left: K.IdentifierKind | K.TSQualifiedNameKind
+    right: K.IdentifierKind | K.TSQualifiedNameKind
+  }
+  interface TSTypeReference
+    extends Omit<TSType, 'type'>,
+      TSHasOptionalTypeParameterInstantiation {
+    type: 'TSTypeReference'
+    typeName: K.IdentifierKind | K.TSQualifiedNameKind
+  }
+  interface TSHasOptionalTypeParameters {
+    typeParameters?: K.TSTypeParameterDeclarationKind | null | undefined
+  }
+  interface TSAsExpression
+    extends Omit<Expression, 'type'>,
+      Omit<Pattern, 'type'> {
+    type: 'TSAsExpression'
+    expression: K.ExpressionKind
+    typeAnnotation: K.TSTypeKind
+    extra?: {
+      parenthesized: boolean
+    } | null
+  }
+  interface TSTypeCastExpression extends Omit<Expression, 'type'> {
+    type: 'TSTypeCastExpression'
+    expression: K.ExpressionKind
+    typeAnnotation: K.TSTypeKind
+  }
+  interface TSSatisfiesExpression
+    extends Omit<Expression, 'type'>,
+      Omit<Pattern, 'type'> {
+    type: 'TSSatisfiesExpression'
+    expression: K.ExpressionKind
+    typeAnnotation: K.TSTypeKind
+  }
+  interface TSNonNullExpression
+    extends Omit<Expression, 'type'>,
+      Omit<Pattern, 'type'> {
+    type: 'TSNonNullExpression'
+    expression: K.ExpressionKind
+  }
+  interface TSAnyKeyword extends Omit<TSType, 'type'> {
+    type: 'TSAnyKeyword'
+  }
+  interface TSBigIntKeyword extends Omit<TSType, 'type'> {
+    type: 'TSBigIntKeyword'
+  }
+  interface TSBooleanKeyword extends Omit<TSType, 'type'> {
+    type: 'TSBooleanKeyword'
+  }
+  interface TSNeverKeyword extends Omit<TSType, 'type'> {
+    type: 'TSNeverKeyword'
+  }
+  interface TSNullKeyword extends Omit<TSType, 'type'> {
+    type: 'TSNullKeyword'
+  }
+  interface TSNumberKeyword extends Omit<TSType, 'type'> {
+    type: 'TSNumberKeyword'
+  }
+  interface TSObjectKeyword extends Omit<TSType, 'type'> {
+    type: 'TSObjectKeyword'
+  }
+  interface TSStringKeyword extends Omit<TSType, 'type'> {
+    type: 'TSStringKeyword'
+  }
+  interface TSSymbolKeyword extends Omit<TSType, 'type'> {
+    type: 'TSSymbolKeyword'
+  }
+  interface TSUndefinedKeyword extends Omit<TSType, 'type'> {
+    type: 'TSUndefinedKeyword'
+  }
+  interface TSUnknownKeyword extends Omit<TSType, 'type'> {
+    type: 'TSUnknownKeyword'
+  }
+  interface TSVoidKeyword extends Omit<TSType, 'type'> {
+    type: 'TSVoidKeyword'
+  }
+  interface TSIntrinsicKeyword extends Omit<TSType, 'type'> {
+    type: 'TSIntrinsicKeyword'
+  }
+  interface TSThisType extends Omit<TSType, 'type'> {
+    type: 'TSThisType'
+  }
+  interface TSArrayType extends Omit<TSType, 'type'> {
+    type: 'TSArrayType'
+    elementType: K.TSTypeKind
+  }
+  interface TSLiteralType extends Omit<TSType, 'type'> {
+    type: 'TSLiteralType'
+    literal:
+      | K.NumericLiteralKind
+      | K.StringLiteralKind
+      | K.BooleanLiteralKind
+      | K.TemplateLiteralKind
+      | K.UnaryExpressionKind
+      | K.BigIntLiteralKind
+  }
+  interface TSUnionType extends Omit<TSType, 'type'> {
+    type: 'TSUnionType'
+    types: K.TSTypeKind[]
+  }
+  interface TSIntersectionType extends Omit<TSType, 'type'> {
+    type: 'TSIntersectionType'
+    types: K.TSTypeKind[]
+  }
+  interface TSConditionalType extends Omit<TSType, 'type'> {
+    type: 'TSConditionalType'
+    checkType: K.TSTypeKind
+    extendsType: K.TSTypeKind
+    trueType: K.TSTypeKind
+    falseType: K.TSTypeKind
+  }
+  interface TSInferType extends Omit<TSType, 'type'> {
+    type: 'TSInferType'
+    typeParameter: K.TSTypeParameterKind
+  }
+  interface TSTypeParameter extends Omit<Identifier, 'type' | 'name'> {
+    type: 'TSTypeParameter'
+    name: K.IdentifierKind | string
+    constraint?: K.TSTypeKind | undefined
+    default?: K.TSTypeKind | undefined
+  }
+  interface TSParenthesizedType extends Omit<TSType, 'type'> {
+    type: 'TSParenthesizedType'
+    typeAnnotation: K.TSTypeKind
+  }
+  interface TSFunctionType
+    extends Omit<TSType, 'type'>,
+      TSHasOptionalTypeParameters,
+      TSHasOptionalTypeAnnotation {
+    type: 'TSFunctionType'
+    parameters: (
+      | K.IdentifierKind
+      | K.RestElementKind
+      | K.ArrayPatternKind
+      | K.ObjectPatternKind
+    )[]
+  }
+  interface TSConstructorType
+    extends Omit<TSType, 'type'>,
+      TSHasOptionalTypeParameters,
+      TSHasOptionalTypeAnnotation {
+    type: 'TSConstructorType'
+    parameters: (
+      | K.IdentifierKind
+      | K.RestElementKind
+      | K.ArrayPatternKind
+      | K.ObjectPatternKind
+    )[]
+  }
+  interface TSDeclareFunction
+    extends Omit<Declaration, 'type'>,
+      TSHasOptionalTypeParameters {
+    type: 'TSDeclareFunction'
+    declare?: boolean
+    async?: boolean
+    generator?: boolean
+    id?: K.IdentifierKind | null
+    params: K.PatternKind[]
+    returnType?: K.TSTypeAnnotationKind | K.NoopKind | null
+  }
+  interface TSDeclareMethod
+    extends Omit<Declaration, 'type'>,
+      TSHasOptionalTypeParameters {
+    type: 'TSDeclareMethod'
+    async?: boolean
+    generator?: boolean
+    params: K.PatternKind[]
+    abstract?: boolean
+    accessibility?: 'public' | 'private' | 'protected' | undefined
+    static?: boolean
+    computed?: boolean
+    optional?: boolean
+    key:
+      | K.IdentifierKind
+      | K.StringLiteralKind
+      | K.NumericLiteralKind
+      | K.ExpressionKind
+    kind?: 'get' | 'set' | 'method' | 'constructor'
+    access?: 'public' | 'private' | 'protected' | undefined
+    decorators?: K.DecoratorKind[] | null
+    returnType?: K.TSTypeAnnotationKind | K.NoopKind | null
+  }
+  interface TSMappedType extends Omit<TSType, 'type'> {
+    type: 'TSMappedType'
+    readonly?: boolean | '+' | '-'
+    typeParameter: K.TSTypeParameterKind
+    optional?: boolean | '+' | '-'
+    typeAnnotation?: K.TSTypeKind | null
+  }
+  interface TSTupleType extends Omit<TSType, 'type'> {
+    type: 'TSTupleType'
+    elementTypes: (K.TSTypeKind | K.TSNamedTupleMemberKind)[]
+  }
+  interface TSNamedTupleMember extends Omit<TSType, 'type'> {
+    type: 'TSNamedTupleMember'
+    label: K.IdentifierKind
+    optional?: boolean
+    elementType: K.TSTypeKind
+  }
+  interface TSRestType extends Omit<TSType, 'type'> {
+    type: 'TSRestType'
+    typeAnnotation: K.TSTypeKind
+  }
+  interface TSOptionalType extends Omit<TSType, 'type'> {
+    type: 'TSOptionalType'
+    typeAnnotation: K.TSTypeKind
+  }
+  interface TSIndexedAccessType extends Omit<TSType, 'type'> {
+    type: 'TSIndexedAccessType'
+    objectType: K.TSTypeKind
+    indexType: K.TSTypeKind
+  }
+  interface TSTypeOperator extends Omit<TSType, 'type'> {
+    type: 'TSTypeOperator'
+    operator: string
+    typeAnnotation: K.TSTypeKind
+  }
+  interface TSIndexSignature
+    extends Omit<Declaration, 'type'>,
+      TSHasOptionalTypeAnnotation {
+    type: 'TSIndexSignature'
+    parameters: K.IdentifierKind[]
+    readonly?: boolean
+  }
+  interface TSPropertySignature
+    extends Omit<Declaration, 'type'>,
+      TSHasOptionalTypeAnnotation {
+    type: 'TSPropertySignature'
+    key: K.ExpressionKind
+    computed?: boolean
+    readonly?: boolean
+    optional?: boolean
+    initializer?: K.ExpressionKind | null
+  }
+  interface TSMethodSignature
+    extends Omit<Declaration, 'type'>,
+      TSHasOptionalTypeParameters,
+      TSHasOptionalTypeAnnotation {
+    type: 'TSMethodSignature'
+    key: K.ExpressionKind
+    computed?: boolean
+    optional?: boolean
+    parameters: (
+      | K.IdentifierKind
+      | K.RestElementKind
+      | K.ArrayPatternKind
+      | K.ObjectPatternKind
+    )[]
+  }
+  interface TSTypePredicate
+    extends Omit<TSTypeAnnotation, 'type' | 'typeAnnotation'>,
+      Omit<TSType, 'type'> {
+    type: 'TSTypePredicate'
+    parameterName: K.IdentifierKind | K.TSThisTypeKind
+    typeAnnotation?: K.TSTypeAnnotationKind | null
+    asserts?: boolean
+  }
+  interface TSCallSignatureDeclaration
+    extends Omit<Declaration, 'type'>,
+      TSHasOptionalTypeParameters,
+      TSHasOptionalTypeAnnotation {
+    type: 'TSCallSignatureDeclaration'
+    parameters: (
+      | K.IdentifierKind
+      | K.RestElementKind
+      | K.ArrayPatternKind
+      | K.ObjectPatternKind
+    )[]
+  }
+  interface TSConstructSignatureDeclaration
+    extends Omit<Declaration, 'type'>,
+      TSHasOptionalTypeParameters,
+      TSHasOptionalTypeAnnotation {
+    type: 'TSConstructSignatureDeclaration'
+    parameters: (
+      | K.IdentifierKind
+      | K.RestElementKind
+      | K.ArrayPatternKind
+      | K.ObjectPatternKind
+    )[]
+  }
+  interface TSEnumMember extends Omit<Node, 'type'> {
+    type: 'TSEnumMember'
+    id: K.IdentifierKind | K.StringLiteralKind
+    initializer?: K.ExpressionKind | null
+  }
+  interface TSTypeQuery extends Omit<TSType, 'type'> {
+    type: 'TSTypeQuery'
+    exprName: K.IdentifierKind | K.TSQualifiedNameKind | K.TSImportTypeKind
+  }
+  interface TSImportType
+    extends Omit<TSType, 'type'>,
+      TSHasOptionalTypeParameterInstantiation {
+    type: 'TSImportType'
+    argument: K.StringLiteralKind
+    qualifier?: K.IdentifierKind | K.TSQualifiedNameKind | undefined
+  }
+  interface TSTypeLiteral extends Omit<TSType, 'type'> {
+    type: 'TSTypeLiteral'
+    members: (
+      | K.TSCallSignatureDeclarationKind
+      | K.TSConstructSignatureDeclarationKind
+      | K.TSIndexSignatureKind
+      | K.TSMethodSignatureKind
+      | K.TSPropertySignatureKind
+    )[]
+  }
+  interface TSTypeAssertion
+    extends Omit<Expression, 'type'>,
+      Omit<Pattern, 'type'> {
+    type: 'TSTypeAssertion'
+    typeAnnotation: K.TSTypeKind
+    expression: K.ExpressionKind
+    extra?: {
+      parenthesized: boolean
+    } | null
+  }
+  interface TSInstantiationExpression
+    extends Omit<Expression, 'type'>,
+      TSHasOptionalTypeParameterInstantiation {
+    type: 'TSInstantiationExpression'
+    expression: K.ExpressionKind
+  }
+  interface TSEnumDeclaration extends Omit<Declaration, 'type'> {
+    type: 'TSEnumDeclaration'
+    id: K.IdentifierKind
+    const?: boolean
+    declare?: boolean
+    members: K.TSEnumMemberKind[]
+    initializer?: K.ExpressionKind | null
+  }
+  interface TSTypeAliasDeclaration
+    extends Omit<Declaration, 'type'>,
+      TSHasOptionalTypeParameters {
+    type: 'TSTypeAliasDeclaration'
+    id: K.IdentifierKind
+    declare?: boolean
+    typeAnnotation: K.TSTypeKind
+  }
+  interface TSModuleBlock extends Omit<Node, 'type'> {
+    type: 'TSModuleBlock'
+    body: K.StatementKind[]
+  }
+  interface TSModuleDeclaration extends Omit<Declaration, 'type'> {
+    type: 'TSModuleDeclaration'
+    id: K.StringLiteralKind | K.IdentifierKind | K.TSQualifiedNameKind
+    declare?: boolean
+    global?: boolean
+    body?: K.TSModuleBlockKind | K.TSModuleDeclarationKind | null
+  }
+  interface TSImportEqualsDeclaration extends Omit<Declaration, 'type'> {
+    type: 'TSImportEqualsDeclaration'
+    id: K.IdentifierKind
+    isExport?: boolean
+    moduleReference:
+      | K.IdentifierKind
+      | K.TSQualifiedNameKind
+      | K.TSExternalModuleReferenceKind
+  }
+  interface TSExternalModuleReference extends Omit<Declaration, 'type'> {
+    type: 'TSExternalModuleReference'
+    expression: K.StringLiteralKind
+  }
+  interface TSExportAssignment extends Omit<Statement, 'type'> {
+    type: 'TSExportAssignment'
+    expression: K.ExpressionKind
+  }
+  interface TSNamespaceExportDeclaration extends Omit<Declaration, 'type'> {
+    type: 'TSNamespaceExportDeclaration'
+    id: K.IdentifierKind
+  }
+  interface TSInterfaceBody extends Omit<Node, 'type'> {
+    type: 'TSInterfaceBody'
+    body: (
+      | K.TSCallSignatureDeclarationKind
+      | K.TSConstructSignatureDeclarationKind
+      | K.TSIndexSignatureKind
+      | K.TSMethodSignatureKind
+      | K.TSPropertySignatureKind
+    )[]
+  }
+  interface TSInterfaceDeclaration
+    extends Omit<Declaration, 'type'>,
+      TSHasOptionalTypeParameters {
+    type: 'TSInterfaceDeclaration'
+    id: K.IdentifierKind | K.TSQualifiedNameKind
+    declare?: boolean
+    extends?: K.TSExpressionWithTypeArgumentsKind[] | null
+    body: K.TSInterfaceBodyKind
+  }
+  interface TSParameterProperty extends Omit<Pattern, 'type'> {
+    type: 'TSParameterProperty'
+    accessibility?: 'public' | 'private' | 'protected' | undefined
+    readonly?: boolean
+    parameter: K.IdentifierKind | K.AssignmentPatternKind
+  }
+  type ASTNode =
+    | File
+    | Program
+    | Identifier
+    | BlockStatement
+    | EmptyStatement
+    | ExpressionStatement
+    | IfStatement
+    | LabeledStatement
+    | BreakStatement
+    | ContinueStatement
+    | WithStatement
+    | SwitchStatement
+    | SwitchCase
+    | ReturnStatement
+    | ThrowStatement
+    | TryStatement
+    | CatchClause
+    | WhileStatement
+    | DoWhileStatement
+    | ForStatement
+    | VariableDeclaration
+    | ForInStatement
+    | DebuggerStatement
+    | FunctionDeclaration
+    | FunctionExpression
+    | VariableDeclarator
+    | ThisExpression
+    | ArrayExpression
+    | ObjectExpression
+    | Property
+    | Literal
+    | SequenceExpression
+    | UnaryExpression
+    | BinaryExpression
+    | AssignmentExpression
+    | MemberExpression
+    | UpdateExpression
+    | LogicalExpression
+    | ConditionalExpression
+    | NewExpression
+    | CallExpression
+    | RestElement
+    | TypeAnnotation
+    | TSTypeAnnotation
+    | SpreadElementPattern
+    | ArrowFunctionExpression
+    | ForOfStatement
+    | YieldExpression
+    | GeneratorExpression
+    | ComprehensionBlock
+    | ComprehensionExpression
+    | ObjectProperty
+    | PropertyPattern
+    | ObjectPattern
+    | ArrayPattern
+    | SpreadElement
+    | AssignmentPattern
+    | MethodDefinition
+    | ClassPropertyDefinition
+    | ClassProperty
+    | StaticBlock
+    | ClassBody
+    | ClassDeclaration
+    | ClassExpression
+    | Super
+    | ImportSpecifier
+    | ImportDefaultSpecifier
+    | ImportNamespaceSpecifier
+    | ImportDeclaration
+    | ExportNamedDeclaration
+    | ExportSpecifier
+    | ExportDefaultDeclaration
+    | ExportAllDeclaration
+    | TaggedTemplateExpression
+    | TemplateLiteral
+    | TemplateElement
+    | MetaProperty
+    | AwaitExpression
+    | SpreadProperty
+    | SpreadPropertyPattern
+    | ImportExpression
+    | ChainExpression
+    | OptionalCallExpression
+    | OptionalMemberExpression
+    | Decorator
+    | PrivateName
+    | ClassPrivateProperty
+    | ImportAttribute
+    | RecordExpression
+    | ObjectMethod
+    | TupleExpression
+    | ModuleExpression
+    | JSXAttribute
+    | JSXIdentifier
+    | JSXNamespacedName
+    | JSXExpressionContainer
+    | JSXElement
+    | JSXFragment
+    | JSXMemberExpression
+    | JSXSpreadAttribute
+    | JSXEmptyExpression
+    | JSXText
+    | JSXSpreadChild
+    | JSXOpeningElement
+    | JSXClosingElement
+    | JSXOpeningFragment
+    | JSXClosingFragment
+    | TypeParameterDeclaration
+    | TSTypeParameterDeclaration
+    | TypeParameterInstantiation
+    | TSTypeParameterInstantiation
+    | ClassImplements
+    | TSExpressionWithTypeArguments
+    | AnyTypeAnnotation
+    | EmptyTypeAnnotation
+    | MixedTypeAnnotation
+    | VoidTypeAnnotation
+    | SymbolTypeAnnotation
+    | NumberTypeAnnotation
+    | BigIntTypeAnnotation
+    | NumberLiteralTypeAnnotation
+    | NumericLiteralTypeAnnotation
+    | BigIntLiteralTypeAnnotation
+    | StringTypeAnnotation
+    | StringLiteralTypeAnnotation
+    | BooleanTypeAnnotation
+    | BooleanLiteralTypeAnnotation
+    | NullableTypeAnnotation
+    | NullLiteralTypeAnnotation
+    | NullTypeAnnotation
+    | ThisTypeAnnotation
+    | ExistsTypeAnnotation
+    | ExistentialTypeParam
+    | FunctionTypeAnnotation
+    | FunctionTypeParam
+    | ArrayTypeAnnotation
+    | ObjectTypeAnnotation
+    | ObjectTypeProperty
+    | ObjectTypeSpreadProperty
+    | ObjectTypeIndexer
+    | ObjectTypeCallProperty
+    | ObjectTypeInternalSlot
+    | Variance
+    | QualifiedTypeIdentifier
+    | GenericTypeAnnotation
+    | MemberTypeAnnotation
+    | IndexedAccessType
+    | OptionalIndexedAccessType
+    | UnionTypeAnnotation
+    | IntersectionTypeAnnotation
+    | TypeofTypeAnnotation
+    | TypeParameter
+    | InterfaceTypeAnnotation
+    | InterfaceExtends
+    | InterfaceDeclaration
+    | DeclareInterface
+    | TypeAlias
+    | DeclareTypeAlias
+    | OpaqueType
+    | DeclareOpaqueType
+    | TypeCastExpression
+    | TupleTypeAnnotation
+    | DeclareVariable
+    | DeclareFunction
+    | DeclareClass
+    | DeclareModule
+    | DeclareModuleExports
+    | DeclareExportDeclaration
+    | ExportBatchSpecifier
+    | DeclareExportAllDeclaration
+    | InferredPredicate
+    | DeclaredPredicate
+    | EnumDeclaration
+    | EnumBooleanBody
+    | EnumNumberBody
+    | EnumStringBody
+    | EnumSymbolBody
+    | EnumBooleanMember
+    | EnumNumberMember
+    | EnumStringMember
+    | EnumDefaultedMember
+    | ExportDeclaration
+    | Block
+    | Line
+    | Noop
+    | DoExpression
+    | BindExpression
+    | ParenthesizedExpression
+    | ExportNamespaceSpecifier
+    | ExportDefaultSpecifier
+    | CommentBlock
+    | CommentLine
+    | Directive
+    | DirectiveLiteral
+    | InterpreterDirective
+    | StringLiteral
+    | NumericLiteral
+    | BigIntLiteral
+    | DecimalLiteral
+    | NullLiteral
+    | BooleanLiteral
+    | RegExpLiteral
+    | ClassMethod
+    | ClassPrivateMethod
+    | ClassAccessorProperty
+    | RestProperty
+    | ForAwaitStatement
+    | Import
+    | V8IntrinsicIdentifier
+    | TopicReference
+    | TSQualifiedName
+    | TSTypeReference
+    | TSAsExpression
+    | TSTypeCastExpression
+    | TSSatisfiesExpression
+    | TSNonNullExpression
+    | TSAnyKeyword
+    | TSBigIntKeyword
+    | TSBooleanKeyword
+    | TSNeverKeyword
+    | TSNullKeyword
+    | TSNumberKeyword
+    | TSObjectKeyword
+    | TSStringKeyword
+    | TSSymbolKeyword
+    | TSUndefinedKeyword
+    | TSUnknownKeyword
+    | TSVoidKeyword
+    | TSIntrinsicKeyword
+    | TSThisType
+    | TSArrayType
+    | TSLiteralType
+    | TSUnionType
+    | TSIntersectionType
+    | TSConditionalType
+    | TSInferType
+    | TSTypeParameter
+    | TSParenthesizedType
+    | TSFunctionType
+    | TSConstructorType
+    | TSDeclareFunction
+    | TSDeclareMethod
+    | TSMappedType
+    | TSTupleType
+    | TSNamedTupleMember
+    | TSRestType
+    | TSOptionalType
+    | TSIndexedAccessType
+    | TSTypeOperator
+    | TSIndexSignature
+    | TSPropertySignature
+    | TSMethodSignature
+    | TSTypePredicate
+    | TSCallSignatureDeclaration
+    | TSConstructSignatureDeclaration
+    | TSEnumMember
+    | TSTypeQuery
+    | TSImportType
+    | TSTypeLiteral
+    | TSTypeAssertion
+    | TSInstantiationExpression
+    | TSEnumDeclaration
+    | TSTypeAliasDeclaration
+    | TSModuleBlock
+    | TSModuleDeclaration
+    | TSImportEqualsDeclaration
+    | TSExternalModuleReference
+    | TSExportAssignment
+    | TSNamespaceExportDeclaration
+    | TSInterfaceBody
+    | TSInterfaceDeclaration
+    | TSParameterProperty
+  let Printable: Type<Printable>
+  let SourceLocation: Type<SourceLocation>
+  let Node: Type<Node>
+  let Comment: Type<Comment>
+  let Position: Type<Position>
+  let File: Type<File>
+  let Program: Type<Program>
+  let Statement: Type<Statement>
+  let Function: Type<Function>
+  let Expression: Type<Expression>
+  let Pattern: Type<Pattern>
+  let Identifier: Type<Identifier>
+  let BlockStatement: Type<BlockStatement>
+  let EmptyStatement: Type<EmptyStatement>
+  let ExpressionStatement: Type<ExpressionStatement>
+  let IfStatement: Type<IfStatement>
+  let LabeledStatement: Type<LabeledStatement>
+  let BreakStatement: Type<BreakStatement>
+  let ContinueStatement: Type<ContinueStatement>
+  let WithStatement: Type<WithStatement>
+  let SwitchStatement: Type<SwitchStatement>
+  let SwitchCase: Type<SwitchCase>
+  let ReturnStatement: Type<ReturnStatement>
+  let ThrowStatement: Type<ThrowStatement>
+  let TryStatement: Type<TryStatement>
+  let CatchClause: Type<CatchClause>
+  let WhileStatement: Type<WhileStatement>
+  let DoWhileStatement: Type<DoWhileStatement>
+  let ForStatement: Type<ForStatement>
+  let Declaration: Type<Declaration>
+  let VariableDeclaration: Type<VariableDeclaration>
+  let ForInStatement: Type<ForInStatement>
+  let DebuggerStatement: Type<DebuggerStatement>
+  let FunctionDeclaration: Type<FunctionDeclaration>
+  let FunctionExpression: Type<FunctionExpression>
+  let VariableDeclarator: Type<VariableDeclarator>
+  let ThisExpression: Type<ThisExpression>
+  let ArrayExpression: Type<ArrayExpression>
+  let ObjectExpression: Type<ObjectExpression>
+  let Property: Type<Property>
+  let Literal: Type<Literal>
+  let SequenceExpression: Type<SequenceExpression>
+  let UnaryExpression: Type<UnaryExpression>
+  let BinaryExpression: Type<BinaryExpression>
+  let AssignmentExpression: Type<AssignmentExpression>
+  let ChainElement: Type<ChainElement>
+  let MemberExpression: Type<MemberExpression>
+  let UpdateExpression: Type<UpdateExpression>
+  let LogicalExpression: Type<LogicalExpression>
+  let ConditionalExpression: Type<ConditionalExpression>
+  let NewExpression: Type<NewExpression>
+  let CallExpression: Type<CallExpression>
+  let RestElement: Type<RestElement>
+  let TypeAnnotation: Type<TypeAnnotation>
+  let TSTypeAnnotation: Type<TSTypeAnnotation>
+  let SpreadElementPattern: Type<SpreadElementPattern>
+  let ArrowFunctionExpression: Type<ArrowFunctionExpression>
+  let ForOfStatement: Type<ForOfStatement>
+  let YieldExpression: Type<YieldExpression>
+  let GeneratorExpression: Type<GeneratorExpression>
+  let ComprehensionBlock: Type<ComprehensionBlock>
+  let ComprehensionExpression: Type<ComprehensionExpression>
+  let ObjectProperty: Type<ObjectProperty>
+  let PropertyPattern: Type<PropertyPattern>
+  let ObjectPattern: Type<ObjectPattern>
+  let ArrayPattern: Type<ArrayPattern>
+  let SpreadElement: Type<SpreadElement>
+  let AssignmentPattern: Type<AssignmentPattern>
+  let MethodDefinition: Type<MethodDefinition>
+  let ClassPropertyDefinition: Type<ClassPropertyDefinition>
+  let ClassProperty: Type<ClassProperty>
+  let StaticBlock: Type<StaticBlock>
+  let ClassBody: Type<ClassBody>
+  let ClassDeclaration: Type<ClassDeclaration>
+  let ClassExpression: Type<ClassExpression>
+  let Super: Type<Super>
+  let Specifier: Type<Specifier>
+  let ModuleSpecifier: Type<ModuleSpecifier>
+  let ImportSpecifier: Type<ImportSpecifier>
+  let ImportDefaultSpecifier: Type<ImportDefaultSpecifier>
+  let ImportNamespaceSpecifier: Type<ImportNamespaceSpecifier>
+  let ImportDeclaration: Type<ImportDeclaration>
+  let ExportNamedDeclaration: Type<ExportNamedDeclaration>
+  let ExportSpecifier: Type<ExportSpecifier>
+  let ExportDefaultDeclaration: Type<ExportDefaultDeclaration>
+  let ExportAllDeclaration: Type<ExportAllDeclaration>
+  let TaggedTemplateExpression: Type<TaggedTemplateExpression>
+  let TemplateLiteral: Type<TemplateLiteral>
+  let TemplateElement: Type<TemplateElement>
+  let MetaProperty: Type<MetaProperty>
+  let AwaitExpression: Type<AwaitExpression>
+  let SpreadProperty: Type<SpreadProperty>
+  let SpreadPropertyPattern: Type<SpreadPropertyPattern>
+  let ImportExpression: Type<ImportExpression>
+  let ChainExpression: Type<ChainExpression>
+  let OptionalCallExpression: Type<OptionalCallExpression>
+  let OptionalMemberExpression: Type<OptionalMemberExpression>
+  let Decorator: Type<Decorator>
+  let PrivateName: Type<PrivateName>
+  let ClassPrivateProperty: Type<ClassPrivateProperty>
+  let ImportAttribute: Type<ImportAttribute>
+  let RecordExpression: Type<RecordExpression>
+  let ObjectMethod: Type<ObjectMethod>
+  let TupleExpression: Type<TupleExpression>
+  let ModuleExpression: Type<ModuleExpression>
+  let JSXAttribute: Type<JSXAttribute>
+  let JSXIdentifier: Type<JSXIdentifier>
+  let JSXNamespacedName: Type<JSXNamespacedName>
+  let JSXExpressionContainer: Type<JSXExpressionContainer>
+  let JSXElement: Type<JSXElement>
+  let JSXFragment: Type<JSXFragment>
+  let JSXMemberExpression: Type<JSXMemberExpression>
+  let JSXSpreadAttribute: Type<JSXSpreadAttribute>
+  let JSXEmptyExpression: Type<JSXEmptyExpression>
+  let JSXText: Type<JSXText>
+  let JSXSpreadChild: Type<JSXSpreadChild>
+  let JSXOpeningElement: Type<JSXOpeningElement>
+  let JSXClosingElement: Type<JSXClosingElement>
+  let JSXOpeningFragment: Type<JSXOpeningFragment>
+  let JSXClosingFragment: Type<JSXClosingFragment>
+  let TypeParameterDeclaration: Type<TypeParameterDeclaration>
+  let TSTypeParameterDeclaration: Type<TSTypeParameterDeclaration>
+  let TypeParameterInstantiation: Type<TypeParameterInstantiation>
+  let TSTypeParameterInstantiation: Type<TSTypeParameterInstantiation>
+  let ClassImplements: Type<ClassImplements>
+  let TSType: Type<TSType>
+  let TSHasOptionalTypeParameterInstantiation: Type<TSHasOptionalTypeParameterInstantiation>
+  let TSExpressionWithTypeArguments: Type<TSExpressionWithTypeArguments>
+  let Flow: Type<Flow>
+  let FlowType: Type<FlowType>
+  let AnyTypeAnnotation: Type<AnyTypeAnnotation>
+  let EmptyTypeAnnotation: Type<EmptyTypeAnnotation>
+  let MixedTypeAnnotation: Type<MixedTypeAnnotation>
+  let VoidTypeAnnotation: Type<VoidTypeAnnotation>
+  let SymbolTypeAnnotation: Type<SymbolTypeAnnotation>
+  let NumberTypeAnnotation: Type<NumberTypeAnnotation>
+  let BigIntTypeAnnotation: Type<BigIntTypeAnnotation>
+  let NumberLiteralTypeAnnotation: Type<NumberLiteralTypeAnnotation>
+  let NumericLiteralTypeAnnotation: Type<NumericLiteralTypeAnnotation>
+  let BigIntLiteralTypeAnnotation: Type<BigIntLiteralTypeAnnotation>
+  let StringTypeAnnotation: Type<StringTypeAnnotation>
+  let StringLiteralTypeAnnotation: Type<StringLiteralTypeAnnotation>
+  let BooleanTypeAnnotation: Type<BooleanTypeAnnotation>
+  let BooleanLiteralTypeAnnotation: Type<BooleanLiteralTypeAnnotation>
+  let NullableTypeAnnotation: Type<NullableTypeAnnotation>
+  let NullLiteralTypeAnnotation: Type<NullLiteralTypeAnnotation>
+  let NullTypeAnnotation: Type<NullTypeAnnotation>
+  let ThisTypeAnnotation: Type<ThisTypeAnnotation>
+  let ExistsTypeAnnotation: Type<ExistsTypeAnnotation>
+  let ExistentialTypeParam: Type<ExistentialTypeParam>
+  let FunctionTypeAnnotation: Type<FunctionTypeAnnotation>
+  let FunctionTypeParam: Type<FunctionTypeParam>
+  let ArrayTypeAnnotation: Type<ArrayTypeAnnotation>
+  let ObjectTypeAnnotation: Type<ObjectTypeAnnotation>
+  let ObjectTypeProperty: Type<ObjectTypeProperty>
+  let ObjectTypeSpreadProperty: Type<ObjectTypeSpreadProperty>
+  let ObjectTypeIndexer: Type<ObjectTypeIndexer>
+  let ObjectTypeCallProperty: Type<ObjectTypeCallProperty>
+  let ObjectTypeInternalSlot: Type<ObjectTypeInternalSlot>
+  let Variance: Type<Variance>
+  let QualifiedTypeIdentifier: Type<QualifiedTypeIdentifier>
+  let GenericTypeAnnotation: Type<GenericTypeAnnotation>
+  let MemberTypeAnnotation: Type<MemberTypeAnnotation>
+  let IndexedAccessType: Type<IndexedAccessType>
+  let OptionalIndexedAccessType: Type<OptionalIndexedAccessType>
+  let UnionTypeAnnotation: Type<UnionTypeAnnotation>
+  let IntersectionTypeAnnotation: Type<IntersectionTypeAnnotation>
+  let TypeofTypeAnnotation: Type<TypeofTypeAnnotation>
+  let TypeParameter: Type<TypeParameter>
+  let InterfaceTypeAnnotation: Type<InterfaceTypeAnnotation>
+  let InterfaceExtends: Type<InterfaceExtends>
+  let InterfaceDeclaration: Type<InterfaceDeclaration>
+  let DeclareInterface: Type<DeclareInterface>
+  let TypeAlias: Type<TypeAlias>
+  let DeclareTypeAlias: Type<DeclareTypeAlias>
+  let OpaqueType: Type<OpaqueType>
+  let DeclareOpaqueType: Type<DeclareOpaqueType>
+  let TypeCastExpression: Type<TypeCastExpression>
+  let TupleTypeAnnotation: Type<TupleTypeAnnotation>
+  let DeclareVariable: Type<DeclareVariable>
+  let DeclareFunction: Type<DeclareFunction>
+  let FlowPredicate: Type<FlowPredicate>
+  let DeclareClass: Type<DeclareClass>
+  let DeclareModule: Type<DeclareModule>
+  let DeclareModuleExports: Type<DeclareModuleExports>
+  let DeclareExportDeclaration: Type<DeclareExportDeclaration>
+  let ExportBatchSpecifier: Type<ExportBatchSpecifier>
+  let DeclareExportAllDeclaration: Type<DeclareExportAllDeclaration>
+  let InferredPredicate: Type<InferredPredicate>
+  let DeclaredPredicate: Type<DeclaredPredicate>
+  let EnumDeclaration: Type<EnumDeclaration>
+  let EnumBooleanBody: Type<EnumBooleanBody>
+  let EnumNumberBody: Type<EnumNumberBody>
+  let EnumStringBody: Type<EnumStringBody>
+  let EnumSymbolBody: Type<EnumSymbolBody>
+  let EnumBooleanMember: Type<EnumBooleanMember>
+  let EnumNumberMember: Type<EnumNumberMember>
+  let EnumStringMember: Type<EnumStringMember>
+  let EnumDefaultedMember: Type<EnumDefaultedMember>
+  let ExportDeclaration: Type<ExportDeclaration>
+  let Block: Type<Block>
+  let Line: Type<Line>
+  let Noop: Type<Noop>
+  let DoExpression: Type<DoExpression>
+  let BindExpression: Type<BindExpression>
+  let ParenthesizedExpression: Type<ParenthesizedExpression>
+  let ExportNamespaceSpecifier: Type<ExportNamespaceSpecifier>
+  let ExportDefaultSpecifier: Type<ExportDefaultSpecifier>
+  let CommentBlock: Type<CommentBlock>
+  let CommentLine: Type<CommentLine>
+  let Directive: Type<Directive>
+  let DirectiveLiteral: Type<DirectiveLiteral>
+  let InterpreterDirective: Type<InterpreterDirective>
+  let StringLiteral: Type<StringLiteral>
+  let NumericLiteral: Type<NumericLiteral>
+  let BigIntLiteral: Type<BigIntLiteral>
+  let DecimalLiteral: Type<DecimalLiteral>
+  let NullLiteral: Type<NullLiteral>
+  let BooleanLiteral: Type<BooleanLiteral>
+  let RegExpLiteral: Type<RegExpLiteral>
+  let ClassMethod: Type<ClassMethod>
+  let ClassPrivateMethod: Type<ClassPrivateMethod>
+  let TSHasOptionalTypeAnnotation: Type<TSHasOptionalTypeAnnotation>
+  let ClassAccessorProperty: Type<ClassAccessorProperty>
+  let RestProperty: Type<RestProperty>
+  let ForAwaitStatement: Type<ForAwaitStatement>
+  let Import: Type<Import>
+  let V8IntrinsicIdentifier: Type<V8IntrinsicIdentifier>
+  let TopicReference: Type<TopicReference>
+  let TSQualifiedName: Type<TSQualifiedName>
+  let TSTypeReference: Type<TSTypeReference>
+  let TSHasOptionalTypeParameters: Type<TSHasOptionalTypeParameters>
+  let TSAsExpression: Type<TSAsExpression>
+  let TSTypeCastExpression: Type<TSTypeCastExpression>
+  let TSSatisfiesExpression: Type<TSSatisfiesExpression>
+  let TSNonNullExpression: Type<TSNonNullExpression>
+  let TSAnyKeyword: Type<TSAnyKeyword>
+  let TSBigIntKeyword: Type<TSBigIntKeyword>
+  let TSBooleanKeyword: Type<TSBooleanKeyword>
+  let TSNeverKeyword: Type<TSNeverKeyword>
+  let TSNullKeyword: Type<TSNullKeyword>
+  let TSNumberKeyword: Type<TSNumberKeyword>
+  let TSObjectKeyword: Type<TSObjectKeyword>
+  let TSStringKeyword: Type<TSStringKeyword>
+  let TSSymbolKeyword: Type<TSSymbolKeyword>
+  let TSUndefinedKeyword: Type<TSUndefinedKeyword>
+  let TSUnknownKeyword: Type<TSUnknownKeyword>
+  let TSVoidKeyword: Type<TSVoidKeyword>
+  let TSIntrinsicKeyword: Type<TSIntrinsicKeyword>
+  let TSThisType: Type<TSThisType>
+  let TSArrayType: Type<TSArrayType>
+  let TSLiteralType: Type<TSLiteralType>
+  let TSUnionType: Type<TSUnionType>
+  let TSIntersectionType: Type<TSIntersectionType>
+  let TSConditionalType: Type<TSConditionalType>
+  let TSInferType: Type<TSInferType>
+  let TSTypeParameter: Type<TSTypeParameter>
+  let TSParenthesizedType: Type<TSParenthesizedType>
+  let TSFunctionType: Type<TSFunctionType>
+  let TSConstructorType: Type<TSConstructorType>
+  let TSDeclareFunction: Type<TSDeclareFunction>
+  let TSDeclareMethod: Type<TSDeclareMethod>
+  let TSMappedType: Type<TSMappedType>
+  let TSTupleType: Type<TSTupleType>
+  let TSNamedTupleMember: Type<TSNamedTupleMember>
+  let TSRestType: Type<TSRestType>
+  let TSOptionalType: Type<TSOptionalType>
+  let TSIndexedAccessType: Type<TSIndexedAccessType>
+  let TSTypeOperator: Type<TSTypeOperator>
+  let TSIndexSignature: Type<TSIndexSignature>
+  let TSPropertySignature: Type<TSPropertySignature>
+  let TSMethodSignature: Type<TSMethodSignature>
+  let TSTypePredicate: Type<TSTypePredicate>
+  let TSCallSignatureDeclaration: Type<TSCallSignatureDeclaration>
+  let TSConstructSignatureDeclaration: Type<TSConstructSignatureDeclaration>
+  let TSEnumMember: Type<TSEnumMember>
+  let TSTypeQuery: Type<TSTypeQuery>
+  let TSImportType: Type<TSImportType>
+  let TSTypeLiteral: Type<TSTypeLiteral>
+  let TSTypeAssertion: Type<TSTypeAssertion>
+  let TSInstantiationExpression: Type<TSInstantiationExpression>
+  let TSEnumDeclaration: Type<TSEnumDeclaration>
+  let TSTypeAliasDeclaration: Type<TSTypeAliasDeclaration>
+  let TSModuleBlock: Type<TSModuleBlock>
+  let TSModuleDeclaration: Type<TSModuleDeclaration>
+  let TSImportEqualsDeclaration: Type<TSImportEqualsDeclaration>
+  let TSExternalModuleReference: Type<TSExternalModuleReference>
+  let TSExportAssignment: Type<TSExportAssignment>
+  let TSNamespaceExportDeclaration: Type<TSNamespaceExportDeclaration>
+  let TSInterfaceBody: Type<TSInterfaceBody>
+  let TSInterfaceDeclaration: Type<TSInterfaceDeclaration>
+  let TSParameterProperty: Type<TSParameterProperty>
 }
 export interface NamedTypes {
-    Printable: Type<namedTypes.Printable>;
-    SourceLocation: Type<namedTypes.SourceLocation>;
-    Node: Type<namedTypes.Node>;
-    Comment: Type<namedTypes.Comment>;
-    Position: Type<namedTypes.Position>;
-    File: Type<namedTypes.File>;
-    Program: Type<namedTypes.Program>;
-    Statement: Type<namedTypes.Statement>;
-    Function: Type<namedTypes.Function>;
-    Expression: Type<namedTypes.Expression>;
-    Pattern: Type<namedTypes.Pattern>;
-    Identifier: Type<namedTypes.Identifier>;
-    BlockStatement: Type<namedTypes.BlockStatement>;
-    EmptyStatement: Type<namedTypes.EmptyStatement>;
-    ExpressionStatement: Type<namedTypes.ExpressionStatement>;
-    IfStatement: Type<namedTypes.IfStatement>;
-    LabeledStatement: Type<namedTypes.LabeledStatement>;
-    BreakStatement: Type<namedTypes.BreakStatement>;
-    ContinueStatement: Type<namedTypes.ContinueStatement>;
-    WithStatement: Type<namedTypes.WithStatement>;
-    SwitchStatement: Type<namedTypes.SwitchStatement>;
-    SwitchCase: Type<namedTypes.SwitchCase>;
-    ReturnStatement: Type<namedTypes.ReturnStatement>;
-    ThrowStatement: Type<namedTypes.ThrowStatement>;
-    TryStatement: Type<namedTypes.TryStatement>;
-    CatchClause: Type<namedTypes.CatchClause>;
-    WhileStatement: Type<namedTypes.WhileStatement>;
-    DoWhileStatement: Type<namedTypes.DoWhileStatement>;
-    ForStatement: Type<namedTypes.ForStatement>;
-    Declaration: Type<namedTypes.Declaration>;
-    VariableDeclaration: Type<namedTypes.VariableDeclaration>;
-    ForInStatement: Type<namedTypes.ForInStatement>;
-    DebuggerStatement: Type<namedTypes.DebuggerStatement>;
-    FunctionDeclaration: Type<namedTypes.FunctionDeclaration>;
-    FunctionExpression: Type<namedTypes.FunctionExpression>;
-    VariableDeclarator: Type<namedTypes.VariableDeclarator>;
-    ThisExpression: Type<namedTypes.ThisExpression>;
-    ArrayExpression: Type<namedTypes.ArrayExpression>;
-    ObjectExpression: Type<namedTypes.ObjectExpression>;
-    Property: Type<namedTypes.Property>;
-    Literal: Type<namedTypes.Literal>;
-    SequenceExpression: Type<namedTypes.SequenceExpression>;
-    UnaryExpression: Type<namedTypes.UnaryExpression>;
-    BinaryExpression: Type<namedTypes.BinaryExpression>;
-    AssignmentExpression: Type<namedTypes.AssignmentExpression>;
-    ChainElement: Type<namedTypes.ChainElement>;
-    MemberExpression: Type<namedTypes.MemberExpression>;
-    UpdateExpression: Type<namedTypes.UpdateExpression>;
-    LogicalExpression: Type<namedTypes.LogicalExpression>;
-    ConditionalExpression: Type<namedTypes.ConditionalExpression>;
-    NewExpression: Type<namedTypes.NewExpression>;
-    CallExpression: Type<namedTypes.CallExpression>;
-    RestElement: Type<namedTypes.RestElement>;
-    TypeAnnotation: Type<namedTypes.TypeAnnotation>;
-    TSTypeAnnotation: Type<namedTypes.TSTypeAnnotation>;
-    SpreadElementPattern: Type<namedTypes.SpreadElementPattern>;
-    ArrowFunctionExpression: Type<namedTypes.ArrowFunctionExpression>;
-    ForOfStatement: Type<namedTypes.ForOfStatement>;
-    YieldExpression: Type<namedTypes.YieldExpression>;
-    GeneratorExpression: Type<namedTypes.GeneratorExpression>;
-    ComprehensionBlock: Type<namedTypes.ComprehensionBlock>;
-    ComprehensionExpression: Type<namedTypes.ComprehensionExpression>;
-    ObjectProperty: Type<namedTypes.ObjectProperty>;
-    PropertyPattern: Type<namedTypes.PropertyPattern>;
-    ObjectPattern: Type<namedTypes.ObjectPattern>;
-    ArrayPattern: Type<namedTypes.ArrayPattern>;
-    SpreadElement: Type<namedTypes.SpreadElement>;
-    AssignmentPattern: Type<namedTypes.AssignmentPattern>;
-    MethodDefinition: Type<namedTypes.MethodDefinition>;
-    ClassPropertyDefinition: Type<namedTypes.ClassPropertyDefinition>;
-    ClassProperty: Type<namedTypes.ClassProperty>;
-    StaticBlock: Type<namedTypes.StaticBlock>;
-    ClassBody: Type<namedTypes.ClassBody>;
-    ClassDeclaration: Type<namedTypes.ClassDeclaration>;
-    ClassExpression: Type<namedTypes.ClassExpression>;
-    Super: Type<namedTypes.Super>;
-    Specifier: Type<namedTypes.Specifier>;
-    ModuleSpecifier: Type<namedTypes.ModuleSpecifier>;
-    ImportSpecifier: Type<namedTypes.ImportSpecifier>;
-    ImportDefaultSpecifier: Type<namedTypes.ImportDefaultSpecifier>;
-    ImportNamespaceSpecifier: Type<namedTypes.ImportNamespaceSpecifier>;
-    ImportDeclaration: Type<namedTypes.ImportDeclaration>;
-    ExportNamedDeclaration: Type<namedTypes.ExportNamedDeclaration>;
-    ExportSpecifier: Type<namedTypes.ExportSpecifier>;
-    ExportDefaultDeclaration: Type<namedTypes.ExportDefaultDeclaration>;
-    ExportAllDeclaration: Type<namedTypes.ExportAllDeclaration>;
-    TaggedTemplateExpression: Type<namedTypes.TaggedTemplateExpression>;
-    TemplateLiteral: Type<namedTypes.TemplateLiteral>;
-    TemplateElement: Type<namedTypes.TemplateElement>;
-    MetaProperty: Type<namedTypes.MetaProperty>;
-    AwaitExpression: Type<namedTypes.AwaitExpression>;
-    SpreadProperty: Type<namedTypes.SpreadProperty>;
-    SpreadPropertyPattern: Type<namedTypes.SpreadPropertyPattern>;
-    ImportExpression: Type<namedTypes.ImportExpression>;
-    ChainExpression: Type<namedTypes.ChainExpression>;
-    OptionalCallExpression: Type<namedTypes.OptionalCallExpression>;
-    OptionalMemberExpression: Type<namedTypes.OptionalMemberExpression>;
-    Decorator: Type<namedTypes.Decorator>;
-    PrivateName: Type<namedTypes.PrivateName>;
-    ClassPrivateProperty: Type<namedTypes.ClassPrivateProperty>;
-    ImportAttribute: Type<namedTypes.ImportAttribute>;
-    RecordExpression: Type<namedTypes.RecordExpression>;
-    ObjectMethod: Type<namedTypes.ObjectMethod>;
-    TupleExpression: Type<namedTypes.TupleExpression>;
-    ModuleExpression: Type<namedTypes.ModuleExpression>;
-    JSXAttribute: Type<namedTypes.JSXAttribute>;
-    JSXIdentifier: Type<namedTypes.JSXIdentifier>;
-    JSXNamespacedName: Type<namedTypes.JSXNamespacedName>;
-    JSXExpressionContainer: Type<namedTypes.JSXExpressionContainer>;
-    JSXElement: Type<namedTypes.JSXElement>;
-    JSXFragment: Type<namedTypes.JSXFragment>;
-    JSXMemberExpression: Type<namedTypes.JSXMemberExpression>;
-    JSXSpreadAttribute: Type<namedTypes.JSXSpreadAttribute>;
-    JSXEmptyExpression: Type<namedTypes.JSXEmptyExpression>;
-    JSXText: Type<namedTypes.JSXText>;
-    JSXSpreadChild: Type<namedTypes.JSXSpreadChild>;
-    JSXOpeningElement: Type<namedTypes.JSXOpeningElement>;
-    JSXClosingElement: Type<namedTypes.JSXClosingElement>;
-    JSXOpeningFragment: Type<namedTypes.JSXOpeningFragment>;
-    JSXClosingFragment: Type<namedTypes.JSXClosingFragment>;
-    TypeParameterDeclaration: Type<namedTypes.TypeParameterDeclaration>;
-    TSTypeParameterDeclaration: Type<namedTypes.TSTypeParameterDeclaration>;
-    TypeParameterInstantiation: Type<namedTypes.TypeParameterInstantiation>;
-    TSTypeParameterInstantiation: Type<namedTypes.TSTypeParameterInstantiation>;
-    ClassImplements: Type<namedTypes.ClassImplements>;
-    TSType: Type<namedTypes.TSType>;
-    TSHasOptionalTypeParameterInstantiation: Type<namedTypes.TSHasOptionalTypeParameterInstantiation>;
-    TSExpressionWithTypeArguments: Type<namedTypes.TSExpressionWithTypeArguments>;
-    Flow: Type<namedTypes.Flow>;
-    FlowType: Type<namedTypes.FlowType>;
-    AnyTypeAnnotation: Type<namedTypes.AnyTypeAnnotation>;
-    EmptyTypeAnnotation: Type<namedTypes.EmptyTypeAnnotation>;
-    MixedTypeAnnotation: Type<namedTypes.MixedTypeAnnotation>;
-    VoidTypeAnnotation: Type<namedTypes.VoidTypeAnnotation>;
-    SymbolTypeAnnotation: Type<namedTypes.SymbolTypeAnnotation>;
-    NumberTypeAnnotation: Type<namedTypes.NumberTypeAnnotation>;
-    BigIntTypeAnnotation: Type<namedTypes.BigIntTypeAnnotation>;
-    NumberLiteralTypeAnnotation: Type<namedTypes.NumberLiteralTypeAnnotation>;
-    NumericLiteralTypeAnnotation: Type<namedTypes.NumericLiteralTypeAnnotation>;
-    BigIntLiteralTypeAnnotation: Type<namedTypes.BigIntLiteralTypeAnnotation>;
-    StringTypeAnnotation: Type<namedTypes.StringTypeAnnotation>;
-    StringLiteralTypeAnnotation: Type<namedTypes.StringLiteralTypeAnnotation>;
-    BooleanTypeAnnotation: Type<namedTypes.BooleanTypeAnnotation>;
-    BooleanLiteralTypeAnnotation: Type<namedTypes.BooleanLiteralTypeAnnotation>;
-    NullableTypeAnnotation: Type<namedTypes.NullableTypeAnnotation>;
-    NullLiteralTypeAnnotation: Type<namedTypes.NullLiteralTypeAnnotation>;
-    NullTypeAnnotation: Type<namedTypes.NullTypeAnnotation>;
-    ThisTypeAnnotation: Type<namedTypes.ThisTypeAnnotation>;
-    ExistsTypeAnnotation: Type<namedTypes.ExistsTypeAnnotation>;
-    ExistentialTypeParam: Type<namedTypes.ExistentialTypeParam>;
-    FunctionTypeAnnotation: Type<namedTypes.FunctionTypeAnnotation>;
-    FunctionTypeParam: Type<namedTypes.FunctionTypeParam>;
-    ArrayTypeAnnotation: Type<namedTypes.ArrayTypeAnnotation>;
-    ObjectTypeAnnotation: Type<namedTypes.ObjectTypeAnnotation>;
-    ObjectTypeProperty: Type<namedTypes.ObjectTypeProperty>;
-    ObjectTypeSpreadProperty: Type<namedTypes.ObjectTypeSpreadProperty>;
-    ObjectTypeIndexer: Type<namedTypes.ObjectTypeIndexer>;
-    ObjectTypeCallProperty: Type<namedTypes.ObjectTypeCallProperty>;
-    ObjectTypeInternalSlot: Type<namedTypes.ObjectTypeInternalSlot>;
-    Variance: Type<namedTypes.Variance>;
-    QualifiedTypeIdentifier: Type<namedTypes.QualifiedTypeIdentifier>;
-    GenericTypeAnnotation: Type<namedTypes.GenericTypeAnnotation>;
-    MemberTypeAnnotation: Type<namedTypes.MemberTypeAnnotation>;
-    IndexedAccessType: Type<namedTypes.IndexedAccessType>;
-    OptionalIndexedAccessType: Type<namedTypes.OptionalIndexedAccessType>;
-    UnionTypeAnnotation: Type<namedTypes.UnionTypeAnnotation>;
-    IntersectionTypeAnnotation: Type<namedTypes.IntersectionTypeAnnotation>;
-    TypeofTypeAnnotation: Type<namedTypes.TypeofTypeAnnotation>;
-    TypeParameter: Type<namedTypes.TypeParameter>;
-    InterfaceTypeAnnotation: Type<namedTypes.InterfaceTypeAnnotation>;
-    InterfaceExtends: Type<namedTypes.InterfaceExtends>;
-    InterfaceDeclaration: Type<namedTypes.InterfaceDeclaration>;
-    DeclareInterface: Type<namedTypes.DeclareInterface>;
-    TypeAlias: Type<namedTypes.TypeAlias>;
-    DeclareTypeAlias: Type<namedTypes.DeclareTypeAlias>;
-    OpaqueType: Type<namedTypes.OpaqueType>;
-    DeclareOpaqueType: Type<namedTypes.DeclareOpaqueType>;
-    TypeCastExpression: Type<namedTypes.TypeCastExpression>;
-    TupleTypeAnnotation: Type<namedTypes.TupleTypeAnnotation>;
-    DeclareVariable: Type<namedTypes.DeclareVariable>;
-    DeclareFunction: Type<namedTypes.DeclareFunction>;
-    FlowPredicate: Type<namedTypes.FlowPredicate>;
-    DeclareClass: Type<namedTypes.DeclareClass>;
-    DeclareModule: Type<namedTypes.DeclareModule>;
-    DeclareModuleExports: Type<namedTypes.DeclareModuleExports>;
-    DeclareExportDeclaration: Type<namedTypes.DeclareExportDeclaration>;
-    ExportBatchSpecifier: Type<namedTypes.ExportBatchSpecifier>;
-    DeclareExportAllDeclaration: Type<namedTypes.DeclareExportAllDeclaration>;
-    InferredPredicate: Type<namedTypes.InferredPredicate>;
-    DeclaredPredicate: Type<namedTypes.DeclaredPredicate>;
-    EnumDeclaration: Type<namedTypes.EnumDeclaration>;
-    EnumBooleanBody: Type<namedTypes.EnumBooleanBody>;
-    EnumNumberBody: Type<namedTypes.EnumNumberBody>;
-    EnumStringBody: Type<namedTypes.EnumStringBody>;
-    EnumSymbolBody: Type<namedTypes.EnumSymbolBody>;
-    EnumBooleanMember: Type<namedTypes.EnumBooleanMember>;
-    EnumNumberMember: Type<namedTypes.EnumNumberMember>;
-    EnumStringMember: Type<namedTypes.EnumStringMember>;
-    EnumDefaultedMember: Type<namedTypes.EnumDefaultedMember>;
-    ExportDeclaration: Type<namedTypes.ExportDeclaration>;
-    Block: Type<namedTypes.Block>;
-    Line: Type<namedTypes.Line>;
-    Noop: Type<namedTypes.Noop>;
-    DoExpression: Type<namedTypes.DoExpression>;
-    BindExpression: Type<namedTypes.BindExpression>;
-    ParenthesizedExpression: Type<namedTypes.ParenthesizedExpression>;
-    ExportNamespaceSpecifier: Type<namedTypes.ExportNamespaceSpecifier>;
-    ExportDefaultSpecifier: Type<namedTypes.ExportDefaultSpecifier>;
-    CommentBlock: Type<namedTypes.CommentBlock>;
-    CommentLine: Type<namedTypes.CommentLine>;
-    Directive: Type<namedTypes.Directive>;
-    DirectiveLiteral: Type<namedTypes.DirectiveLiteral>;
-    InterpreterDirective: Type<namedTypes.InterpreterDirective>;
-    StringLiteral: Type<namedTypes.StringLiteral>;
-    NumericLiteral: Type<namedTypes.NumericLiteral>;
-    BigIntLiteral: Type<namedTypes.BigIntLiteral>;
-    DecimalLiteral: Type<namedTypes.DecimalLiteral>;
-    NullLiteral: Type<namedTypes.NullLiteral>;
-    BooleanLiteral: Type<namedTypes.BooleanLiteral>;
-    RegExpLiteral: Type<namedTypes.RegExpLiteral>;
-    ClassMethod: Type<namedTypes.ClassMethod>;
-    ClassPrivateMethod: Type<namedTypes.ClassPrivateMethod>;
-    TSHasOptionalTypeAnnotation: Type<namedTypes.TSHasOptionalTypeAnnotation>;
-    ClassAccessorProperty: Type<namedTypes.ClassAccessorProperty>;
-    RestProperty: Type<namedTypes.RestProperty>;
-    ForAwaitStatement: Type<namedTypes.ForAwaitStatement>;
-    Import: Type<namedTypes.Import>;
-    V8IntrinsicIdentifier: Type<namedTypes.V8IntrinsicIdentifier>;
-    TopicReference: Type<namedTypes.TopicReference>;
-    TSQualifiedName: Type<namedTypes.TSQualifiedName>;
-    TSTypeReference: Type<namedTypes.TSTypeReference>;
-    TSHasOptionalTypeParameters: Type<namedTypes.TSHasOptionalTypeParameters>;
-    TSAsExpression: Type<namedTypes.TSAsExpression>;
-    TSTypeCastExpression: Type<namedTypes.TSTypeCastExpression>;
-    TSSatisfiesExpression: Type<namedTypes.TSSatisfiesExpression>;
-    TSNonNullExpression: Type<namedTypes.TSNonNullExpression>;
-    TSAnyKeyword: Type<namedTypes.TSAnyKeyword>;
-    TSBigIntKeyword: Type<namedTypes.TSBigIntKeyword>;
-    TSBooleanKeyword: Type<namedTypes.TSBooleanKeyword>;
-    TSNeverKeyword: Type<namedTypes.TSNeverKeyword>;
-    TSNullKeyword: Type<namedTypes.TSNullKeyword>;
-    TSNumberKeyword: Type<namedTypes.TSNumberKeyword>;
-    TSObjectKeyword: Type<namedTypes.TSObjectKeyword>;
-    TSStringKeyword: Type<namedTypes.TSStringKeyword>;
-    TSSymbolKeyword: Type<namedTypes.TSSymbolKeyword>;
-    TSUndefinedKeyword: Type<namedTypes.TSUndefinedKeyword>;
-    TSUnknownKeyword: Type<namedTypes.TSUnknownKeyword>;
-    TSVoidKeyword: Type<namedTypes.TSVoidKeyword>;
-    TSIntrinsicKeyword: Type<namedTypes.TSIntrinsicKeyword>;
-    TSThisType: Type<namedTypes.TSThisType>;
-    TSArrayType: Type<namedTypes.TSArrayType>;
-    TSLiteralType: Type<namedTypes.TSLiteralType>;
-    TSUnionType: Type<namedTypes.TSUnionType>;
-    TSIntersectionType: Type<namedTypes.TSIntersectionType>;
-    TSConditionalType: Type<namedTypes.TSConditionalType>;
-    TSInferType: Type<namedTypes.TSInferType>;
-    TSTypeParameter: Type<namedTypes.TSTypeParameter>;
-    TSParenthesizedType: Type<namedTypes.TSParenthesizedType>;
-    TSFunctionType: Type<namedTypes.TSFunctionType>;
-    TSConstructorType: Type<namedTypes.TSConstructorType>;
-    TSDeclareFunction: Type<namedTypes.TSDeclareFunction>;
-    TSDeclareMethod: Type<namedTypes.TSDeclareMethod>;
-    TSMappedType: Type<namedTypes.TSMappedType>;
-    TSTupleType: Type<namedTypes.TSTupleType>;
-    TSNamedTupleMember: Type<namedTypes.TSNamedTupleMember>;
-    TSRestType: Type<namedTypes.TSRestType>;
-    TSOptionalType: Type<namedTypes.TSOptionalType>;
-    TSIndexedAccessType: Type<namedTypes.TSIndexedAccessType>;
-    TSTypeOperator: Type<namedTypes.TSTypeOperator>;
-    TSIndexSignature: Type<namedTypes.TSIndexSignature>;
-    TSPropertySignature: Type<namedTypes.TSPropertySignature>;
-    TSMethodSignature: Type<namedTypes.TSMethodSignature>;
-    TSTypePredicate: Type<namedTypes.TSTypePredicate>;
-    TSCallSignatureDeclaration: Type<namedTypes.TSCallSignatureDeclaration>;
-    TSConstructSignatureDeclaration: Type<namedTypes.TSConstructSignatureDeclaration>;
-    TSEnumMember: Type<namedTypes.TSEnumMember>;
-    TSTypeQuery: Type<namedTypes.TSTypeQuery>;
-    TSImportType: Type<namedTypes.TSImportType>;
-    TSTypeLiteral: Type<namedTypes.TSTypeLiteral>;
-    TSTypeAssertion: Type<namedTypes.TSTypeAssertion>;
-    TSInstantiationExpression: Type<namedTypes.TSInstantiationExpression>;
-    TSEnumDeclaration: Type<namedTypes.TSEnumDeclaration>;
-    TSTypeAliasDeclaration: Type<namedTypes.TSTypeAliasDeclaration>;
-    TSModuleBlock: Type<namedTypes.TSModuleBlock>;
-    TSModuleDeclaration: Type<namedTypes.TSModuleDeclaration>;
-    TSImportEqualsDeclaration: Type<namedTypes.TSImportEqualsDeclaration>;
-    TSExternalModuleReference: Type<namedTypes.TSExternalModuleReference>;
-    TSExportAssignment: Type<namedTypes.TSExportAssignment>;
-    TSNamespaceExportDeclaration: Type<namedTypes.TSNamespaceExportDeclaration>;
-    TSInterfaceBody: Type<namedTypes.TSInterfaceBody>;
-    TSInterfaceDeclaration: Type<namedTypes.TSInterfaceDeclaration>;
-    TSParameterProperty: Type<namedTypes.TSParameterProperty>;
+  Printable: Type<namedTypes.Printable>
+  SourceLocation: Type<namedTypes.SourceLocation>
+  Node: Type<namedTypes.Node>
+  Comment: Type<namedTypes.Comment>
+  Position: Type<namedTypes.Position>
+  File: Type<namedTypes.File>
+  Program: Type<namedTypes.Program>
+  Statement: Type<namedTypes.Statement>
+  Function: Type<namedTypes.Function>
+  Expression: Type<namedTypes.Expression>
+  Pattern: Type<namedTypes.Pattern>
+  Identifier: Type<namedTypes.Identifier>
+  BlockStatement: Type<namedTypes.BlockStatement>
+  EmptyStatement: Type<namedTypes.EmptyStatement>
+  ExpressionStatement: Type<namedTypes.ExpressionStatement>
+  IfStatement: Type<namedTypes.IfStatement>
+  LabeledStatement: Type<namedTypes.LabeledStatement>
+  BreakStatement: Type<namedTypes.BreakStatement>
+  ContinueStatement: Type<namedTypes.ContinueStatement>
+  WithStatement: Type<namedTypes.WithStatement>
+  SwitchStatement: Type<namedTypes.SwitchStatement>
+  SwitchCase: Type<namedTypes.SwitchCase>
+  ReturnStatement: Type<namedTypes.ReturnStatement>
+  ThrowStatement: Type<namedTypes.ThrowStatement>
+  TryStatement: Type<namedTypes.TryStatement>
+  CatchClause: Type<namedTypes.CatchClause>
+  WhileStatement: Type<namedTypes.WhileStatement>
+  DoWhileStatement: Type<namedTypes.DoWhileStatement>
+  ForStatement: Type<namedTypes.ForStatement>
+  Declaration: Type<namedTypes.Declaration>
+  VariableDeclaration: Type<namedTypes.VariableDeclaration>
+  ForInStatement: Type<namedTypes.ForInStatement>
+  DebuggerStatement: Type<namedTypes.DebuggerStatement>
+  FunctionDeclaration: Type<namedTypes.FunctionDeclaration>
+  FunctionExpression: Type<namedTypes.FunctionExpression>
+  VariableDeclarator: Type<namedTypes.VariableDeclarator>
+  ThisExpression: Type<namedTypes.ThisExpression>
+  ArrayExpression: Type<namedTypes.ArrayExpression>
+  ObjectExpression: Type<namedTypes.ObjectExpression>
+  Property: Type<namedTypes.Property>
+  Literal: Type<namedTypes.Literal>
+  SequenceExpression: Type<namedTypes.SequenceExpression>
+  UnaryExpression: Type<namedTypes.UnaryExpression>
+  BinaryExpression: Type<namedTypes.BinaryExpression>
+  AssignmentExpression: Type<namedTypes.AssignmentExpression>
+  ChainElement: Type<namedTypes.ChainElement>
+  MemberExpression: Type<namedTypes.MemberExpression>
+  UpdateExpression: Type<namedTypes.UpdateExpression>
+  LogicalExpression: Type<namedTypes.LogicalExpression>
+  ConditionalExpression: Type<namedTypes.ConditionalExpression>
+  NewExpression: Type<namedTypes.NewExpression>
+  CallExpression: Type<namedTypes.CallExpression>
+  RestElement: Type<namedTypes.RestElement>
+  TypeAnnotation: Type<namedTypes.TypeAnnotation>
+  TSTypeAnnotation: Type<namedTypes.TSTypeAnnotation>
+  SpreadElementPattern: Type<namedTypes.SpreadElementPattern>
+  ArrowFunctionExpression: Type<namedTypes.ArrowFunctionExpression>
+  ForOfStatement: Type<namedTypes.ForOfStatement>
+  YieldExpression: Type<namedTypes.YieldExpression>
+  GeneratorExpression: Type<namedTypes.GeneratorExpression>
+  ComprehensionBlock: Type<namedTypes.ComprehensionBlock>
+  ComprehensionExpression: Type<namedTypes.ComprehensionExpression>
+  ObjectProperty: Type<namedTypes.ObjectProperty>
+  PropertyPattern: Type<namedTypes.PropertyPattern>
+  ObjectPattern: Type<namedTypes.ObjectPattern>
+  ArrayPattern: Type<namedTypes.ArrayPattern>
+  SpreadElement: Type<namedTypes.SpreadElement>
+  AssignmentPattern: Type<namedTypes.AssignmentPattern>
+  MethodDefinition: Type<namedTypes.MethodDefinition>
+  ClassPropertyDefinition: Type<namedTypes.ClassPropertyDefinition>
+  ClassProperty: Type<namedTypes.ClassProperty>
+  StaticBlock: Type<namedTypes.StaticBlock>
+  ClassBody: Type<namedTypes.ClassBody>
+  ClassDeclaration: Type<namedTypes.ClassDeclaration>
+  ClassExpression: Type<namedTypes.ClassExpression>
+  Super: Type<namedTypes.Super>
+  Specifier: Type<namedTypes.Specifier>
+  ModuleSpecifier: Type<namedTypes.ModuleSpecifier>
+  ImportSpecifier: Type<namedTypes.ImportSpecifier>
+  ImportDefaultSpecifier: Type<namedTypes.ImportDefaultSpecifier>
+  ImportNamespaceSpecifier: Type<namedTypes.ImportNamespaceSpecifier>
+  ImportDeclaration: Type<namedTypes.ImportDeclaration>
+  ExportNamedDeclaration: Type<namedTypes.ExportNamedDeclaration>
+  ExportSpecifier: Type<namedTypes.ExportSpecifier>
+  ExportDefaultDeclaration: Type<namedTypes.ExportDefaultDeclaration>
+  ExportAllDeclaration: Type<namedTypes.ExportAllDeclaration>
+  TaggedTemplateExpression: Type<namedTypes.TaggedTemplateExpression>
+  TemplateLiteral: Type<namedTypes.TemplateLiteral>
+  TemplateElement: Type<namedTypes.TemplateElement>
+  MetaProperty: Type<namedTypes.MetaProperty>
+  AwaitExpression: Type<namedTypes.AwaitExpression>
+  SpreadProperty: Type<namedTypes.SpreadProperty>
+  SpreadPropertyPattern: Type<namedTypes.SpreadPropertyPattern>
+  ImportExpression: Type<namedTypes.ImportExpression>
+  ChainExpression: Type<namedTypes.ChainExpression>
+  OptionalCallExpression: Type<namedTypes.OptionalCallExpression>
+  OptionalMemberExpression: Type<namedTypes.OptionalMemberExpression>
+  Decorator: Type<namedTypes.Decorator>
+  PrivateName: Type<namedTypes.PrivateName>
+  ClassPrivateProperty: Type<namedTypes.ClassPrivateProperty>
+  ImportAttribute: Type<namedTypes.ImportAttribute>
+  RecordExpression: Type<namedTypes.RecordExpression>
+  ObjectMethod: Type<namedTypes.ObjectMethod>
+  TupleExpression: Type<namedTypes.TupleExpression>
+  ModuleExpression: Type<namedTypes.ModuleExpression>
+  JSXAttribute: Type<namedTypes.JSXAttribute>
+  JSXIdentifier: Type<namedTypes.JSXIdentifier>
+  JSXNamespacedName: Type<namedTypes.JSXNamespacedName>
+  JSXExpressionContainer: Type<namedTypes.JSXExpressionContainer>
+  JSXElement: Type<namedTypes.JSXElement>
+  JSXFragment: Type<namedTypes.JSXFragment>
+  JSXMemberExpression: Type<namedTypes.JSXMemberExpression>
+  JSXSpreadAttribute: Type<namedTypes.JSXSpreadAttribute>
+  JSXEmptyExpression: Type<namedTypes.JSXEmptyExpression>
+  JSXText: Type<namedTypes.JSXText>
+  JSXSpreadChild: Type<namedTypes.JSXSpreadChild>
+  JSXOpeningElement: Type<namedTypes.JSXOpeningElement>
+  JSXClosingElement: Type<namedTypes.JSXClosingElement>
+  JSXOpeningFragment: Type<namedTypes.JSXOpeningFragment>
+  JSXClosingFragment: Type<namedTypes.JSXClosingFragment>
+  TypeParameterDeclaration: Type<namedTypes.TypeParameterDeclaration>
+  TSTypeParameterDeclaration: Type<namedTypes.TSTypeParameterDeclaration>
+  TypeParameterInstantiation: Type<namedTypes.TypeParameterInstantiation>
+  TSTypeParameterInstantiation: Type<namedTypes.TSTypeParameterInstantiation>
+  ClassImplements: Type<namedTypes.ClassImplements>
+  TSType: Type<namedTypes.TSType>
+  TSHasOptionalTypeParameterInstantiation: Type<namedTypes.TSHasOptionalTypeParameterInstantiation>
+  TSExpressionWithTypeArguments: Type<namedTypes.TSExpressionWithTypeArguments>
+  Flow: Type<namedTypes.Flow>
+  FlowType: Type<namedTypes.FlowType>
+  AnyTypeAnnotation: Type<namedTypes.AnyTypeAnnotation>
+  EmptyTypeAnnotation: Type<namedTypes.EmptyTypeAnnotation>
+  MixedTypeAnnotation: Type<namedTypes.MixedTypeAnnotation>
+  VoidTypeAnnotation: Type<namedTypes.VoidTypeAnnotation>
+  SymbolTypeAnnotation: Type<namedTypes.SymbolTypeAnnotation>
+  NumberTypeAnnotation: Type<namedTypes.NumberTypeAnnotation>
+  BigIntTypeAnnotation: Type<namedTypes.BigIntTypeAnnotation>
+  NumberLiteralTypeAnnotation: Type<namedTypes.NumberLiteralTypeAnnotation>
+  NumericLiteralTypeAnnotation: Type<namedTypes.NumericLiteralTypeAnnotation>
+  BigIntLiteralTypeAnnotation: Type<namedTypes.BigIntLiteralTypeAnnotation>
+  StringTypeAnnotation: Type<namedTypes.StringTypeAnnotation>
+  StringLiteralTypeAnnotation: Type<namedTypes.StringLiteralTypeAnnotation>
+  BooleanTypeAnnotation: Type<namedTypes.BooleanTypeAnnotation>
+  BooleanLiteralTypeAnnotation: Type<namedTypes.BooleanLiteralTypeAnnotation>
+  NullableTypeAnnotation: Type<namedTypes.NullableTypeAnnotation>
+  NullLiteralTypeAnnotation: Type<namedTypes.NullLiteralTypeAnnotation>
+  NullTypeAnnotation: Type<namedTypes.NullTypeAnnotation>
+  ThisTypeAnnotation: Type<namedTypes.ThisTypeAnnotation>
+  ExistsTypeAnnotation: Type<namedTypes.ExistsTypeAnnotation>
+  ExistentialTypeParam: Type<namedTypes.ExistentialTypeParam>
+  FunctionTypeAnnotation: Type<namedTypes.FunctionTypeAnnotation>
+  FunctionTypeParam: Type<namedTypes.FunctionTypeParam>
+  ArrayTypeAnnotation: Type<namedTypes.ArrayTypeAnnotation>
+  ObjectTypeAnnotation: Type<namedTypes.ObjectTypeAnnotation>
+  ObjectTypeProperty: Type<namedTypes.ObjectTypeProperty>
+  ObjectTypeSpreadProperty: Type<namedTypes.ObjectTypeSpreadProperty>
+  ObjectTypeIndexer: Type<namedTypes.ObjectTypeIndexer>
+  ObjectTypeCallProperty: Type<namedTypes.ObjectTypeCallProperty>
+  ObjectTypeInternalSlot: Type<namedTypes.ObjectTypeInternalSlot>
+  Variance: Type<namedTypes.Variance>
+  QualifiedTypeIdentifier: Type<namedTypes.QualifiedTypeIdentifier>
+  GenericTypeAnnotation: Type<namedTypes.GenericTypeAnnotation>
+  MemberTypeAnnotation: Type<namedTypes.MemberTypeAnnotation>
+  IndexedAccessType: Type<namedTypes.IndexedAccessType>
+  OptionalIndexedAccessType: Type<namedTypes.OptionalIndexedAccessType>
+  UnionTypeAnnotation: Type<namedTypes.UnionTypeAnnotation>
+  IntersectionTypeAnnotation: Type<namedTypes.IntersectionTypeAnnotation>
+  TypeofTypeAnnotation: Type<namedTypes.TypeofTypeAnnotation>
+  TypeParameter: Type<namedTypes.TypeParameter>
+  InterfaceTypeAnnotation: Type<namedTypes.InterfaceTypeAnnotation>
+  InterfaceExtends: Type<namedTypes.InterfaceExtends>
+  InterfaceDeclaration: Type<namedTypes.InterfaceDeclaration>
+  DeclareInterface: Type<namedTypes.DeclareInterface>
+  TypeAlias: Type<namedTypes.TypeAlias>
+  DeclareTypeAlias: Type<namedTypes.DeclareTypeAlias>
+  OpaqueType: Type<namedTypes.OpaqueType>
+  DeclareOpaqueType: Type<namedTypes.DeclareOpaqueType>
+  TypeCastExpression: Type<namedTypes.TypeCastExpression>
+  TupleTypeAnnotation: Type<namedTypes.TupleTypeAnnotation>
+  DeclareVariable: Type<namedTypes.DeclareVariable>
+  DeclareFunction: Type<namedTypes.DeclareFunction>
+  FlowPredicate: Type<namedTypes.FlowPredicate>
+  DeclareClass: Type<namedTypes.DeclareClass>
+  DeclareModule: Type<namedTypes.DeclareModule>
+  DeclareModuleExports: Type<namedTypes.DeclareModuleExports>
+  DeclareExportDeclaration: Type<namedTypes.DeclareExportDeclaration>
+  ExportBatchSpecifier: Type<namedTypes.ExportBatchSpecifier>
+  DeclareExportAllDeclaration: Type<namedTypes.DeclareExportAllDeclaration>
+  InferredPredicate: Type<namedTypes.InferredPredicate>
+  DeclaredPredicate: Type<namedTypes.DeclaredPredicate>
+  EnumDeclaration: Type<namedTypes.EnumDeclaration>
+  EnumBooleanBody: Type<namedTypes.EnumBooleanBody>
+  EnumNumberBody: Type<namedTypes.EnumNumberBody>
+  EnumStringBody: Type<namedTypes.EnumStringBody>
+  EnumSymbolBody: Type<namedTypes.EnumSymbolBody>
+  EnumBooleanMember: Type<namedTypes.EnumBooleanMember>
+  EnumNumberMember: Type<namedTypes.EnumNumberMember>
+  EnumStringMember: Type<namedTypes.EnumStringMember>
+  EnumDefaultedMember: Type<namedTypes.EnumDefaultedMember>
+  ExportDeclaration: Type<namedTypes.ExportDeclaration>
+  Block: Type<namedTypes.Block>
+  Line: Type<namedTypes.Line>
+  Noop: Type<namedTypes.Noop>
+  DoExpression: Type<namedTypes.DoExpression>
+  BindExpression: Type<namedTypes.BindExpression>
+  ParenthesizedExpression: Type<namedTypes.ParenthesizedExpression>
+  ExportNamespaceSpecifier: Type<namedTypes.ExportNamespaceSpecifier>
+  ExportDefaultSpecifier: Type<namedTypes.ExportDefaultSpecifier>
+  CommentBlock: Type<namedTypes.CommentBlock>
+  CommentLine: Type<namedTypes.CommentLine>
+  Directive: Type<namedTypes.Directive>
+  DirectiveLiteral: Type<namedTypes.DirectiveLiteral>
+  InterpreterDirective: Type<namedTypes.InterpreterDirective>
+  StringLiteral: Type<namedTypes.StringLiteral>
+  NumericLiteral: Type<namedTypes.NumericLiteral>
+  BigIntLiteral: Type<namedTypes.BigIntLiteral>
+  DecimalLiteral: Type<namedTypes.DecimalLiteral>
+  NullLiteral: Type<namedTypes.NullLiteral>
+  BooleanLiteral: Type<namedTypes.BooleanLiteral>
+  RegExpLiteral: Type<namedTypes.RegExpLiteral>
+  ClassMethod: Type<namedTypes.ClassMethod>
+  ClassPrivateMethod: Type<namedTypes.ClassPrivateMethod>
+  TSHasOptionalTypeAnnotation: Type<namedTypes.TSHasOptionalTypeAnnotation>
+  ClassAccessorProperty: Type<namedTypes.ClassAccessorProperty>
+  RestProperty: Type<namedTypes.RestProperty>
+  ForAwaitStatement: Type<namedTypes.ForAwaitStatement>
+  Import: Type<namedTypes.Import>
+  V8IntrinsicIdentifier: Type<namedTypes.V8IntrinsicIdentifier>
+  TopicReference: Type<namedTypes.TopicReference>
+  TSQualifiedName: Type<namedTypes.TSQualifiedName>
+  TSTypeReference: Type<namedTypes.TSTypeReference>
+  TSHasOptionalTypeParameters: Type<namedTypes.TSHasOptionalTypeParameters>
+  TSAsExpression: Type<namedTypes.TSAsExpression>
+  TSTypeCastExpression: Type<namedTypes.TSTypeCastExpression>
+  TSSatisfiesExpression: Type<namedTypes.TSSatisfiesExpression>
+  TSNonNullExpression: Type<namedTypes.TSNonNullExpression>
+  TSAnyKeyword: Type<namedTypes.TSAnyKeyword>
+  TSBigIntKeyword: Type<namedTypes.TSBigIntKeyword>
+  TSBooleanKeyword: Type<namedTypes.TSBooleanKeyword>
+  TSNeverKeyword: Type<namedTypes.TSNeverKeyword>
+  TSNullKeyword: Type<namedTypes.TSNullKeyword>
+  TSNumberKeyword: Type<namedTypes.TSNumberKeyword>
+  TSObjectKeyword: Type<namedTypes.TSObjectKeyword>
+  TSStringKeyword: Type<namedTypes.TSStringKeyword>
+  TSSymbolKeyword: Type<namedTypes.TSSymbolKeyword>
+  TSUndefinedKeyword: Type<namedTypes.TSUndefinedKeyword>
+  TSUnknownKeyword: Type<namedTypes.TSUnknownKeyword>
+  TSVoidKeyword: Type<namedTypes.TSVoidKeyword>
+  TSIntrinsicKeyword: Type<namedTypes.TSIntrinsicKeyword>
+  TSThisType: Type<namedTypes.TSThisType>
+  TSArrayType: Type<namedTypes.TSArrayType>
+  TSLiteralType: Type<namedTypes.TSLiteralType>
+  TSUnionType: Type<namedTypes.TSUnionType>
+  TSIntersectionType: Type<namedTypes.TSIntersectionType>
+  TSConditionalType: Type<namedTypes.TSConditionalType>
+  TSInferType: Type<namedTypes.TSInferType>
+  TSTypeParameter: Type<namedTypes.TSTypeParameter>
+  TSParenthesizedType: Type<namedTypes.TSParenthesizedType>
+  TSFunctionType: Type<namedTypes.TSFunctionType>
+  TSConstructorType: Type<namedTypes.TSConstructorType>
+  TSDeclareFunction: Type<namedTypes.TSDeclareFunction>
+  TSDeclareMethod: Type<namedTypes.TSDeclareMethod>
+  TSMappedType: Type<namedTypes.TSMappedType>
+  TSTupleType: Type<namedTypes.TSTupleType>
+  TSNamedTupleMember: Type<namedTypes.TSNamedTupleMember>
+  TSRestType: Type<namedTypes.TSRestType>
+  TSOptionalType: Type<namedTypes.TSOptionalType>
+  TSIndexedAccessType: Type<namedTypes.TSIndexedAccessType>
+  TSTypeOperator: Type<namedTypes.TSTypeOperator>
+  TSIndexSignature: Type<namedTypes.TSIndexSignature>
+  TSPropertySignature: Type<namedTypes.TSPropertySignature>
+  TSMethodSignature: Type<namedTypes.TSMethodSignature>
+  TSTypePredicate: Type<namedTypes.TSTypePredicate>
+  TSCallSignatureDeclaration: Type<namedTypes.TSCallSignatureDeclaration>
+  TSConstructSignatureDeclaration: Type<namedTypes.TSConstructSignatureDeclaration>
+  TSEnumMember: Type<namedTypes.TSEnumMember>
+  TSTypeQuery: Type<namedTypes.TSTypeQuery>
+  TSImportType: Type<namedTypes.TSImportType>
+  TSTypeLiteral: Type<namedTypes.TSTypeLiteral>
+  TSTypeAssertion: Type<namedTypes.TSTypeAssertion>
+  TSInstantiationExpression: Type<namedTypes.TSInstantiationExpression>
+  TSEnumDeclaration: Type<namedTypes.TSEnumDeclaration>
+  TSTypeAliasDeclaration: Type<namedTypes.TSTypeAliasDeclaration>
+  TSModuleBlock: Type<namedTypes.TSModuleBlock>
+  TSModuleDeclaration: Type<namedTypes.TSModuleDeclaration>
+  TSImportEqualsDeclaration: Type<namedTypes.TSImportEqualsDeclaration>
+  TSExternalModuleReference: Type<namedTypes.TSExternalModuleReference>
+  TSExportAssignment: Type<namedTypes.TSExportAssignment>
+  TSNamespaceExportDeclaration: Type<namedTypes.TSNamespaceExportDeclaration>
+  TSInterfaceBody: Type<namedTypes.TSInterfaceBody>
+  TSInterfaceDeclaration: Type<namedTypes.TSInterfaceDeclaration>
+  TSParameterProperty: Type<namedTypes.TSParameterProperty>
 }
